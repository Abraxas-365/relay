package channels

import (
	"encoding/json"
	"time"

	"github.com/Abraxas-365/relay/pkg/kernel"
)

// ============================================================================
// Channel Entity (Single struct for DB)
// ============================================================================

// Channel estructura única que se guarda en la DB
type Channel struct {
	ID          kernel.ChannelID `db:"id" json:"id"`
	TenantID    kernel.TenantID  `db:"tenant_id" json:"tenant_id"`
	Type        ChannelType      `db:"type" json:"type"`
	Name        string           `db:"name" json:"name"`
	Description string           `db:"description" json:"description"`
	Config      json.RawMessage  `db:"config" json:"config"` // JSON que se deserializa según Type
	IsActive    bool             `db:"is_active" json:"is_active"`
	WebhookURL  string           `db:"webhook_url" json:"webhook_url"`
	CreatedAt   time.Time        `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time        `db:"updated_at" json:"updated_at"`
}

// ChannelType tipo de canal
type ChannelType string

const (
	ChannelTypeWhatsApp  ChannelType = "WHATSAPP"
	ChannelTypeInstagram ChannelType = "INSTAGRAM"
	ChannelTypeTelegram  ChannelType = "TELEGRAM"
	ChannelTypeInfobip   ChannelType = "INFOBIP"
	ChannelTypeEmail     ChannelType = "EMAIL"
	ChannelTypeSMS       ChannelType = "SMS"
	ChannelTypeWebChat   ChannelType = "WEBCHAT"
	ChannelTypeVoice     ChannelType = "VOICE"
	ChannelTypeTestHTTP  ChannelType = "TEST_HTTP"
)

// ============================================================================
// Channel Features
// ============================================================================

// ChannelFeatures características/capacidades de un canal
type ChannelFeatures struct {
	SupportsText                bool     `json:"supports_text"`
	SupportsAttachments         bool     `json:"supports_attachments"`
	SupportsImages              bool     `json:"supports_images"`
	SupportsAudio               bool     `json:"supports_audio"`
	SupportsVideo               bool     `json:"supports_video"`
	SupportsDocuments           bool     `json:"supports_documents"`
	SupportsInteractiveMessages bool     `json:"supports_interactive_messages"`
	SupportsButtons             bool     `json:"supports_buttons"`
	SupportsQuickReplies        bool     `json:"supports_quick_replies"`
	SupportsTemplates           bool     `json:"supports_templates"`
	SupportsLocation            bool     `json:"supports_location"`
	SupportsContacts            bool     `json:"supports_contacts"`
	SupportsReactions           bool     `json:"supports_reactions"`
	SupportsThreads             bool     `json:"supports_threads"`
	MaxMessageLength            int      `json:"max_message_length"`
	MaxAttachmentSize           int64    `json:"max_attachment_size_bytes"`
	SupportedMimeTypes          []string `json:"supported_mime_types,omitempty"`
}

// ============================================================================
// Config Interface
// ============================================================================

// ChannelConfig interfaz que todos los configs deben implementar
type ChannelConfig interface {
	Validate() error
	GetProvider() string
	GetFeatures() ChannelFeatures
	GetType() ChannelType
}

// ============================================================================
// WhatsApp Config
// ============================================================================

// WhatsAppConfig configuración para WhatsApp
type WhatsAppConfig struct {
	Provider           string `json:"provider"` // meta, twilio, infobip
	PhoneNumberID      string `json:"phone_number_id"`
	BusinessAccountID  string `json:"business_account_id"`
	AccessToken        string `json:"access_token"`
	AppSecret          string `json:"app_secret,omitempty"`
	WebhookVerifyToken string `json:"webhook_verify_token"`
	APIVersion         string `json:"api_version,omitempty"` // v17.0, v18.0

	// Buffer configuration
	BufferEnabled        bool `json:"buffer_enabled,omitempty"`          // Enable message buffering
	BufferTimeSeconds    int  `json:"buffer_time_seconds,omitempty"`     // Time window to buffer messages (e.g., 5 seconds)
	BufferResetOnMessage bool `json:"buffer_reset_on_message,omitempty"` // Reset timer on each new message
}

func (c WhatsAppConfig) Validate() error {
	if c.Provider == "" {
		return ErrInvalidChannelConfig().WithDetail("reason", "provider is required")
	}
	if c.PhoneNumberID == "" {
		return ErrInvalidChannelConfig().WithDetail("reason", "phone_number_id is required")
	}
	if c.AccessToken == "" {
		return ErrInvalidChannelConfig().WithDetail("reason", "access_token is required")
	}

	// Validate buffer config
	if c.BufferEnabled {
		if c.BufferTimeSeconds <= 0 {
			c.BufferTimeSeconds = 5 // Default 5 seconds
		}
		if c.BufferTimeSeconds > 60 {
			return ErrInvalidChannelConfig().WithDetail("reason", "buffer_time_seconds cannot exceed 60 seconds")
		}
	}

	return nil
}

func (c WhatsAppConfig) GetProvider() string {
	return c.Provider
}

func (c WhatsAppConfig) GetType() ChannelType {
	return ChannelTypeWhatsApp
}

func (c WhatsAppConfig) GetFeatures() ChannelFeatures {
	return ChannelFeatures{
		SupportsText:                true,
		SupportsAttachments:         true,
		SupportsImages:              true,
		SupportsAudio:               true,
		SupportsVideo:               true,
		SupportsDocuments:           true,
		SupportsInteractiveMessages: true,
		SupportsButtons:             true,
		SupportsQuickReplies:        true,
		SupportsTemplates:           true,
		SupportsLocation:            true,
		SupportsContacts:            true,
		SupportsReactions:           true,
		SupportsThreads:             false,
		MaxMessageLength:            4096,
		MaxAttachmentSize:           16 * 1024 * 1024, // 16MB
		SupportedMimeTypes: []string{
			"image/jpeg", "image/png",
			"video/mp4", "video/3gpp",
			"audio/aac", "audio/mp4", "audio/mpeg", "audio/amr", "audio/ogg",
			"application/pdf",
		},
	}
}

// ============================================================================
// Instagram Config
// ============================================================================

// InstagramConfig configuración para Instagram
type InstagramConfig struct {
	Provider    string `json:"provider"` // meta
	PageID      string `json:"page_id"`
	PageToken   string `json:"page_token"`
	AppSecret   string `json:"app_secret"`
	VerifyToken string `json:"verify_token"`
}

func (c InstagramConfig) Validate() error {
	if c.PageID == "" {
		return ErrInvalidChannelConfig().WithDetail("reason", "page_id is required")
	}
	if c.PageToken == "" {
		return ErrInvalidChannelConfig().WithDetail("reason", "page_token is required")
	}
	return nil
}

func (c InstagramConfig) GetProvider() string {
	return c.Provider
}

func (c InstagramConfig) GetType() ChannelType {
	return ChannelTypeInstagram
}

func (c InstagramConfig) GetFeatures() ChannelFeatures {
	return ChannelFeatures{
		SupportsText:                true,
		SupportsAttachments:         true,
		SupportsImages:              true,
		SupportsAudio:               false,
		SupportsVideo:               true,
		SupportsDocuments:           false,
		SupportsInteractiveMessages: true,
		SupportsButtons:             true,
		SupportsQuickReplies:        true,
		SupportsTemplates:           false,
		SupportsLocation:            false,
		SupportsContacts:            false,
		SupportsReactions:           true,
		SupportsThreads:             true,
		MaxMessageLength:            1000,
		MaxAttachmentSize:           8 * 1024 * 1024, // 8MB
		SupportedMimeTypes: []string{
			"image/jpeg", "image/png",
			"video/mp4",
		},
	}
}

// ============================================================================
// Telegram Config
// ============================================================================

// TelegramConfig configuración para Telegram
type TelegramConfig struct {
	Provider      string `json:"provider"` // telegram
	BotToken      string `json:"bot_token"`
	BotUsername   string `json:"bot_username,omitempty"`
	WebhookSecret string `json:"webhook_secret,omitempty"`
}

func (c TelegramConfig) Validate() error {
	if c.BotToken == "" {
		return ErrInvalidChannelConfig().WithDetail("reason", "bot_token is required")
	}
	return nil
}

func (c TelegramConfig) GetProvider() string {
	return c.Provider
}

func (c TelegramConfig) GetType() ChannelType {
	return ChannelTypeTelegram
}

func (c TelegramConfig) GetFeatures() ChannelFeatures {
	return ChannelFeatures{
		SupportsText:                true,
		SupportsAttachments:         true,
		SupportsImages:              true,
		SupportsAudio:               true,
		SupportsVideo:               true,
		SupportsDocuments:           true,
		SupportsInteractiveMessages: true,
		SupportsButtons:             true,
		SupportsQuickReplies:        false,
		SupportsTemplates:           false,
		SupportsLocation:            true,
		SupportsContacts:            true,
		SupportsReactions:           false,
		SupportsThreads:             true,
		MaxMessageLength:            4096,
		MaxAttachmentSize:           50 * 1024 * 1024, // 50MB
		SupportedMimeTypes: []string{
			"image/jpeg", "image/png", "image/gif",
			"video/mp4",
			"audio/mpeg", "audio/ogg",
			"application/pdf", "application/zip",
		},
	}
}

// ============================================================================
// Infobip Config
// ============================================================================

// InfobipConfig configuración para Infobip (multi-canal)
type InfobipConfig struct {
	Provider       string `json:"provider"` // infobip
	APIKey         string `json:"api_key"`
	BaseURL        string `json:"base_url"`         // https://api.infobip.com
	Sender         string `json:"sender"`           // número o ID de remitente
	SubChannelType string `json:"sub_channel_type"` // whatsapp, sms, email, viber
}

func (c InfobipConfig) Validate() error {
	if c.APIKey == "" {
		return ErrInvalidChannelConfig().WithDetail("reason", "api_key is required")
	}
	if c.BaseURL == "" {
		return ErrInvalidChannelConfig().WithDetail("reason", "base_url is required")
	}
	return nil
}

func (c InfobipConfig) GetProvider() string {
	return c.Provider
}

func (c InfobipConfig) GetType() ChannelType {
	return ChannelTypeInfobip
}

func (c InfobipConfig) GetFeatures() ChannelFeatures {
	// Features varían según SubChannelType, aquí las más comunes
	return ChannelFeatures{
		SupportsText:                true,
		SupportsAttachments:         true,
		SupportsImages:              true,
		SupportsAudio:               true,
		SupportsVideo:               true,
		SupportsDocuments:           true,
		SupportsInteractiveMessages: true,
		SupportsButtons:             true,
		SupportsQuickReplies:        true,
		SupportsTemplates:           true,
		SupportsLocation:            true,
		SupportsContacts:            false,
		SupportsReactions:           false,
		SupportsThreads:             false,
		MaxMessageLength:            4096,
		MaxAttachmentSize:           10 * 1024 * 1024, // 10MB
		SupportedMimeTypes: []string{
			"image/jpeg", "image/png",
			"video/mp4",
			"audio/mpeg",
			"application/pdf",
		},
	}
}

// ============================================================================
// Email Config
// ============================================================================

// EmailConfig configuración para Email
type EmailConfig struct {
	Provider  string `json:"provider"` // sendgrid, ses, smtp
	FromEmail string `json:"from_email"`
	FromName  string `json:"from_name"`
	APIKey    string `json:"api_key,omitempty"`

	// SMTP específico
	SMTPHost     string `json:"smtp_host,omitempty"`
	SMTPPort     int    `json:"smtp_port,omitempty"`
	SMTPUsername string `json:"smtp_username,omitempty"`
	SMTPPassword string `json:"smtp_password,omitempty"`
	UseTLS       bool   `json:"use_tls,omitempty"`
}

func (c EmailConfig) Validate() error {
	if c.Provider == "" {
		return ErrInvalidChannelConfig().WithDetail("reason", "provider is required")
	}
	if c.FromEmail == "" {
		return ErrInvalidChannelConfig().WithDetail("reason", "from_email is required")
	}
	return nil
}

func (c EmailConfig) GetProvider() string {
	return c.Provider
}

func (c EmailConfig) GetType() ChannelType {
	return ChannelTypeEmail
}

func (c EmailConfig) GetFeatures() ChannelFeatures {
	return ChannelFeatures{
		SupportsText:                true,
		SupportsAttachments:         true,
		SupportsImages:              true,
		SupportsAudio:               false,
		SupportsVideo:               false,
		SupportsDocuments:           true,
		SupportsInteractiveMessages: false,
		SupportsButtons:             false,
		SupportsQuickReplies:        false,
		SupportsTemplates:           true,
		SupportsLocation:            false,
		SupportsContacts:            false,
		SupportsReactions:           false,
		SupportsThreads:             true,
		MaxMessageLength:            100000,
		MaxAttachmentSize:           25 * 1024 * 1024, // 25MB
		SupportedMimeTypes: []string{
			"image/jpeg", "image/png", "image/gif",
			"application/pdf",
			"application/msword",
			"application/vnd.ms-excel",
		},
	}
}

// ============================================================================
// SMS Config
// ============================================================================

// SMSConfig configuración para SMS
type SMSConfig struct {
	Provider  string `json:"provider"` // twilio, infobip, nexmo
	APIKey    string `json:"api_key"`
	APISecret string `json:"api_secret,omitempty"`
	Sender    string `json:"sender"` // número de remitente
}

func (c SMSConfig) Validate() error {
	if c.Provider == "" {
		return ErrInvalidChannelConfig().WithDetail("reason", "provider is required")
	}
	if c.APIKey == "" {
		return ErrInvalidChannelConfig().WithDetail("reason", "api_key is required")
	}
	if c.Sender == "" {
		return ErrInvalidChannelConfig().WithDetail("reason", "sender is required")
	}
	return nil
}

func (c SMSConfig) GetProvider() string {
	return c.Provider
}

func (c SMSConfig) GetType() ChannelType {
	return ChannelTypeSMS
}

func (c SMSConfig) GetFeatures() ChannelFeatures {
	return ChannelFeatures{
		SupportsText:                true,
		SupportsAttachments:         false,
		SupportsImages:              false,
		SupportsAudio:               false,
		SupportsVideo:               false,
		SupportsDocuments:           false,
		SupportsInteractiveMessages: false,
		SupportsButtons:             false,
		SupportsQuickReplies:        false,
		SupportsTemplates:           false,
		SupportsLocation:            false,
		SupportsContacts:            false,
		SupportsReactions:           false,
		SupportsThreads:             false,
		MaxMessageLength:            160, // o 1600 para concatenados
		MaxAttachmentSize:           0,
		SupportedMimeTypes:          []string{},
	}
}

// ============================================================================
// WebChat Config
// ============================================================================

// WebChatConfig configuración para WebChat
type WebChatConfig struct {
	Provider   string            `json:"provider"` // custom, tawk, intercom
	WidgetID   string            `json:"widget_id"`
	APIKey     string            `json:"api_key,omitempty"`
	Settings   map[string]string `json:"settings,omitempty"`
	CustomCSS  string            `json:"custom_css,omitempty"`
	WelcomeMsg string            `json:"welcome_message,omitempty"`
}

func (c WebChatConfig) Validate() error {
	if c.WidgetID == "" {
		return ErrInvalidChannelConfig().WithDetail("reason", "widget_id is required")
	}
	return nil
}

func (c WebChatConfig) GetProvider() string {
	return c.Provider
}

func (c WebChatConfig) GetType() ChannelType {
	return ChannelTypeWebChat
}

func (c WebChatConfig) GetFeatures() ChannelFeatures {
	return ChannelFeatures{
		SupportsText:                true,
		SupportsAttachments:         true,
		SupportsImages:              true,
		SupportsAudio:               false,
		SupportsVideo:               false,
		SupportsDocuments:           true,
		SupportsInteractiveMessages: true,
		SupportsButtons:             true,
		SupportsQuickReplies:        true,
		SupportsTemplates:           false,
		SupportsLocation:            false,
		SupportsContacts:            false,
		SupportsReactions:           true,
		SupportsThreads:             true,
		MaxMessageLength:            10000,
		MaxAttachmentSize:           10 * 1024 * 1024, // 10MB
		SupportedMimeTypes: []string{
			"image/jpeg", "image/png", "image/gif",
			"application/pdf",
		},
	}
}

// ============================================================================
// Channel Domain Methods
// ============================================================================

// IsValid verifica si el canal es válido
func (c *Channel) IsValid() bool {
	return c.Name != "" && c.Type != "" && !c.TenantID.IsEmpty()
}

// Activate activa el canal
func (c *Channel) Activate() {
	c.IsActive = true
	c.UpdatedAt = time.Now()
}

// Deactivate desactiva el canal
func (c *Channel) Deactivate() {
	c.IsActive = false
	c.UpdatedAt = time.Now()
}

// UpdateDetails actualiza nombre y descripción
func (c *Channel) UpdateDetails(name, description string) {
	if name != "" {
		c.Name = name
	}
	if description != "" {
		c.Description = description
	}
	c.UpdatedAt = time.Now()
}

// UpdateConfig actualiza la configuración
func (c *Channel) UpdateConfig(config ChannelConfig) error {
	configJSON, err := json.Marshal(config)
	if err != nil {
		return err
	}
	c.Config = configJSON
	c.UpdatedAt = time.Now()
	return nil
}

// GetConfigStruct deserializa el config según el tipo
func (c *Channel) GetConfigStruct() (ChannelConfig, error) {
	switch c.Type {
	case ChannelTypeWhatsApp:
		var config WhatsAppConfig
		if err := json.Unmarshal(c.Config, &config); err != nil {
			return nil, err
		}
		return config, nil

	case ChannelTypeInstagram:
		var config InstagramConfig
		if err := json.Unmarshal(c.Config, &config); err != nil {
			return nil, err
		}
		return config, nil

	case ChannelTypeTelegram:
		var config TelegramConfig
		if err := json.Unmarshal(c.Config, &config); err != nil {
			return nil, err
		}
		return config, nil

	case ChannelTypeInfobip:
		var config InfobipConfig
		if err := json.Unmarshal(c.Config, &config); err != nil {
			return nil, err
		}
		return config, nil

	case ChannelTypeEmail:
		var config EmailConfig
		if err := json.Unmarshal(c.Config, &config); err != nil {
			return nil, err
		}
		return config, nil

	case ChannelTypeSMS:
		var config SMSConfig
		if err := json.Unmarshal(c.Config, &config); err != nil {
			return nil, err
		}
		return config, nil

	case ChannelTypeWebChat:
		var config WebChatConfig
		if err := json.Unmarshal(c.Config, &config); err != nil {
			return nil, err
		}
		return config, nil
	case ChannelTypeTestHTTP:
		var config TestHTTPConfig
		if err := json.Unmarshal(c.Config, &config); err != nil {
			return nil, err
		}
		return config, nil

	default:
		return nil, ErrChannelNotSupported().WithDetail("type", string(c.Type))
	}

}

// GetFeatures obtiene las features del canal
func (c *Channel) GetFeatures() (ChannelFeatures, error) {
	config, err := c.GetConfigStruct()
	if err != nil {
		return ChannelFeatures{}, err
	}
	return config.GetFeatures(), nil
}

// HasCredentials verifica si tiene credenciales configuradas
func (c *Channel) HasCredentials() bool {
	config, err := c.GetConfigStruct()
	if err != nil {
		return false
	}
	return config.GetProvider() != ""
}

// GetProvider retorna el proveedor
func (c *Channel) GetProvider() string {
	config, err := c.GetConfigStruct()
	if err != nil {
		return ""
	}
	return config.GetProvider()
}

// ============================================================================
// Helper Functions
// ============================================================================

// NewChannelFromConfig crea un canal desde una config
func NewChannelFromConfig(
	id kernel.ChannelID,
	tenantID kernel.TenantID,
	name string,
	description string,
	config ChannelConfig,
	webhookURL string,
) (*Channel, error) {
	configJSON, err := json.Marshal(config)
	if err != nil {
		return nil, err
	}

	return &Channel{
		ID:          id,
		TenantID:    tenantID,
		Type:        config.GetType(),
		Name:        name,
		Description: description,
		Config:      configJSON,
		IsActive:    true,
		WebhookURL:  webhookURL,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}, nil
}

type TestHTTPConfig struct {
	Provider string `json:"provider"` // test
	Secret   string `json:"secret,omitempty"`
}

func (c TestHTTPConfig) Validate() error {
	return nil // No required fields for testing
}

func (c TestHTTPConfig) GetProvider() string {
	return "test"
}

func (c TestHTTPConfig) GetType() ChannelType {
	return ChannelTypeTestHTTP
}

func (c TestHTTPConfig) GetFeatures() ChannelFeatures {
	return ChannelFeatures{
		SupportsText:        true,
		SupportsAttachments: false,
		MaxMessageLength:    10000,
		SupportedMimeTypes:  []string{},
	}
}
package channelmanager

import (
	"context"
	"log"
	"sync"

	"github.com/Abraxas-365/relay/channels"
	"github.com/Abraxas-365/relay/pkg/kernel"
)

// DefaultChannelManager implementación del ChannelManager
type DefaultChannelManager struct {
	mu sync.RWMutex

	// Adapters registrados por tipo de canal
	adapters map[channels.ChannelType]channels.ChannelAdapter

	// Canales registrados por ID
	channels map[kernel.ChannelID]*channels.Channel

	// Channel repository para persistencia
	channelRepo channels.ChannelRepository
}

// NewDefaultChannelManager crea una nueva instancia
func NewDefaultChannelManager(channelRepo channels.ChannelRepository) *DefaultChannelManager {
	return &DefaultChannelManager{
		adapters:    make(map[channels.ChannelType]channels.ChannelAdapter),
		channels:    make(map[kernel.ChannelID]*channels.Channel),
		channelRepo: channelRepo,
	}
}

// RegisterAdapter registra un adapter para un tipo de canal
func (cm *DefaultChannelManager) RegisterAdapter(adapter channels.ChannelAdapter) {
	cm.mu.Lock()
	defer cm.mu.Unlock()

	channelType := adapter.GetType()
	cm.adapters[channelType] = adapter

	log.Printf("📝 Registered adapter for channel type: %s", channelType)
}

// RegisterChannel registra un canal en el manager
func (cm *DefaultChannelManager) RegisterChannel(ctx context.Context, channel channels.Channel) error {
	cm.mu.Lock()
	defer cm.mu.Unlock()

	// Verificar que el canal sea válido
	if !channel.IsValid() {
		return channels.ErrInvalidChannelConfig().WithDetail("reason", "channel is not valid")
	}

	// Verificar que exista adapter para este tipo
	if _, exists := cm.adapters[channel.Type]; !exists {
		log.Printf("⚠️  No adapter found for channel type: %s (channel: %s)", channel.Type, channel.ID.String())
		// No fallar, solo advertir - permite registro sin adapter
	}

	// Registrar canal en memoria
	cm.channels[channel.ID] = &channel

	log.Printf("✅ Channel registered: %s (type: %s, id: %s)", channel.Name, channel.Type, channel.ID.String())

	return nil
}

// GetAdapter obtiene el adapter para un tipo de canal
func (cm *DefaultChannelManager) GetAdapter(channelType channels.ChannelType) (channels.ChannelAdapter, error) {
	cm.mu.RLock()
	defer cm.mu.RUnlock()

	adapter, exists := cm.adapters[channelType]
	if !exists {
		return nil, channels.ErrChannelNotSupported().WithDetail("type", string(channelType))
	}

	return adapter, nil
}

// SendMessage envía un mensaje a través de un canal
func (cm *DefaultChannelManager) SendMessage(ctx context.Context, channelID kernel.ChannelID, msg channels.OutgoingMessage) error {
	// Obtener canal
	channel, err := cm.getChannel(ctx, channelID)
	if err != nil {
		return err
	}

	// Verificar que el canal esté activo
	if !channel.IsActive {
		return channels.ErrChannelInactive().WithDetail("channel_id", channelID.String())
	}

	// Obtener adapter
	adapter, err := cm.GetAdapter(channel.Type)
	if err != nil {
		return err
	}

	// Enviar mensaje usando el adapter
	log.Printf("📤 Sending message via channel %s (type: %s) to %s", channel.Name, channel.Type, msg.RecipientID)

	if err := adapter.SendMessage(ctx, msg); err != nil {
		log.Printf("❌ Failed to send message: %v", err)
		return channels.ErrMessageSendFailed().
			WithDetail("channel_id", channelID.String()).
			WithDetail("error", err.Error())
	}

	log.Printf("✅ Message sent successfully via %s", channel.Name)
	return nil
}

// ProcessIncomingMessage procesa un mensaje entrante
func (cm *DefaultChannelManager) ProcessIncomingMessage(ctx context.Context, channelID kernel.ChannelID, msg channels.IncomingMessage) error {
	// Obtener canal
	channel, err := cm.getChannel(ctx, channelID)
	if err != nil {
		return err
	}

	// Verificar que el canal esté activo
	if !channel.IsActive {
		return channels.ErrChannelInactive().WithDetail("channel_id", channelID.String())
	}

	log.Printf("📥 Processing incoming message from %s via channel %s", msg.SenderID, channel.Name)

	// TODO: Aquí puedes agregar lógica adicional de procesamiento
	// Por ejemplo, validación, transformación, etc.

	return nil
}

// TestChannel prueba la conexión de un canal
func (cm *DefaultChannelManager) TestChannel(ctx context.Context, channelID kernel.ChannelID) error {
	// Obtener canal
	channel, err := cm.getChannel(ctx, channelID)
	if err != nil {
		return err
	}

	// Obtener adapter
	adapter, err := cm.GetAdapter(channel.Type)
	if err != nil {
		return err
	}

	// Obtener configuración del canal
	config, err := channel.GetConfigStruct()
	if err != nil {
		return channels.ErrInvalidChannelConfig().
			WithDetail("channel_id", channelID.String()).
			WithDetail("error", err.Error())
	}

	// Probar conexión
	log.Printf("🧪 Testing channel: %s (type: %s)", channel.Name, channel.Type)

	if err := adapter.TestConnection(ctx, config); err != nil {
		log.Printf("❌ Channel test failed: %v", err)
		return err
	}

	log.Printf("✅ Channel test successful: %s", channel.Name)
	return nil
}

// getChannel obtiene un canal por ID (primero de cache, luego de DB)
func (cm *DefaultChannelManager) getChannel(ctx context.Context, channelID kernel.ChannelID) (*channels.Channel, error) {
	// Intentar obtener de cache primero
	cm.mu.RLock()
	channel, exists := cm.channels[channelID]
	cm.mu.RUnlock()

	if exists {
		return channel, nil
	}

	// Si no está en cache, intentar cargar de DB
	// Nota: necesitamos el tenantID, pero no lo tenemos aquí
	// Por ahora, retornamos error
	log.Printf("⚠️  Channel %s not found in cache", channelID.String())

	return nil, channels.ErrChannelNotFound().WithDetail("channel_id", channelID.String())
}

// LoadChannels carga canales de un tenant en memoria
func (cm *DefaultChannelManager) LoadChannels(ctx context.Context, tenantID kernel.TenantID) error {
	if cm.channelRepo == nil {
		log.Println("⚠️  Channel repository not available, skipping channel loading")
		return nil
	}

	channels, err := cm.channelRepo.FindByTenant(ctx, tenantID)
	if err != nil {
		return err
	}

	cm.mu.Lock()
	defer cm.mu.Unlock()

	for _, ch := range channels {
		cm.channels[ch.ID] = ch
		log.Printf("📥 Loaded channel: %s (type: %s)", ch.Name, ch.Type)
	}

	log.Printf("✅ Loaded %d channels for tenant %s", len(channels), tenantID.String())
	return nil
}

// GetRegisteredAdapters retorna los tipos de adaptadores registrados
func (cm *DefaultChannelManager) GetRegisteredAdapters() []channels.ChannelType {
	cm.mu.RLock()
	defer cm.mu.RUnlock()

	types := make([]channels.ChannelType, 0, len(cm.adapters))
	for channelType := range cm.adapters {
		types = append(types, channelType)
	}

	return types
}

// GetRegisteredChannels retorna los IDs de canales registrados
func (cm *DefaultChannelManager) GetRegisteredChannels() []kernel.ChannelID {
	cm.mu.RLock()
	defer cm.mu.RUnlock()

	ids := make([]kernel.ChannelID, 0, len(cm.channels))
	for channelID := range cm.channels {
		ids = append(ids, channelID)
	}

	return ids
}
package whatsapp

import (
	"context"
	"strings"
	"time"

	"github.com/Abraxas-365/relay/channels"
	"github.com/Abraxas-365/relay/pkg/kernel"
	"github.com/go-redis/redis/v8"
)

// BufferWorker periodically checks and flushes expired buffers
type BufferWorker struct {
	redis         *redis.Client
	bufferService *BufferService
	interval      time.Duration
	stopChan      chan struct{}
}

// NewBufferWorker creates a new buffer worker
func NewBufferWorker(
	redisClient *redis.Client,
	bufferService *BufferService,
	interval time.Duration,
) *BufferWorker {
	return &BufferWorker{
		redis:         redisClient,
		bufferService: bufferService,
		interval:      interval,
		stopChan:      make(chan struct{}),
	}
}

// Start starts the buffer worker
func (w *BufferWorker) Start(ctx context.Context, onFlush func(context.Context, *channels.IncomingMessage) error) {
	ticker := time.NewTicker(w.interval)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			return
		case <-w.stopChan:
			return
		case <-ticker.C:
			w.checkBuffers(ctx, onFlush)
		}
	}
}

// Stop stops the buffer worker
func (w *BufferWorker) Stop() {
	close(w.stopChan)
}

// checkBuffers checks all buffers and flushes expired ones
func (w *BufferWorker) checkBuffers(ctx context.Context, onFlush func(context.Context, *channels.IncomingMessage) error) {
	// Scan for all buffer keys
	var cursor uint64
	pattern := "relay:buffer:*"

	for {
		keys, nextCursor, err := w.redis.Scan(ctx, cursor, pattern, 100).Result()
		if err != nil {
			break
		}

		for _, key := range keys {
			// Skip timer keys
			if strings.Contains(key, ":timer:") {
				continue
			}

			// Extract channel ID and sender ID from key
			parts := strings.Split(key, ":")
			if len(parts) < 4 {
				continue
			}

			channelID := parts[2]
			senderID := parts[3]

			// Try to flush
			msg, err := w.bufferService.CheckAndFlush(ctx, kernel.NewChannelID(channelID), senderID)
			if err != nil || msg == nil {
				continue
			}

			// Call flush callback
			if onFlush != nil {
				onFlush(ctx, msg)
			}
		}

		cursor = nextCursor
		if cursor == 0 {
			break
		}
	}
}
package whatsapp

import (
	"bytes"
	"context"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"

	"github.com/Abraxas-365/relay/channels"
	"github.com/Abraxas-365/relay/pkg/kernel"
	"github.com/go-redis/redis/v8"
)

const (
	whatsappAPIBaseURL = "https://graph.facebook.com"
	defaultAPIVersion  = "v18.0"
)

// WhatsAppAdapter implements ChannelAdapter for WhatsApp Business API
type WhatsAppAdapter struct {
	config        channels.WhatsAppConfig
	httpClient    *http.Client
	bufferService *BufferService
	apiURL        string
}

// NewWhatsAppAdapter creates a new WhatsApp adapter
func NewWhatsAppAdapter(config channels.WhatsAppConfig, redisClient *redis.Client) *WhatsAppAdapter {
	apiVersion := config.APIVersion
	if apiVersion == "" {
		apiVersion = defaultAPIVersion
	}

	return &WhatsAppAdapter{
		config:        config,
		httpClient:    &http.Client{Timeout: 30 * time.Second},
		bufferService: NewBufferService(redisClient, config),
		apiURL:        fmt.Sprintf("%s/%s/%s", whatsappAPIBaseURL, apiVersion, config.PhoneNumberID),
	}
}

// GetType returns the channel type
func (a *WhatsAppAdapter) GetType() channels.ChannelType {
	return channels.ChannelTypeWhatsApp
}

// SendMessage sends a message via WhatsApp
func (a *WhatsAppAdapter) SendMessage(ctx context.Context, msg channels.OutgoingMessage) error {
	// Build WhatsApp API payload
	payload := a.buildMessagePayload(msg)

	// Send to WhatsApp API
	url := fmt.Sprintf("%s/messages", a.apiURL)

	jsonData, err := json.Marshal(payload)
	if err != nil {
		return fmt.Errorf("failed to marshal message: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewBuffer(jsonData))
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("Authorization", "Bearer "+a.config.AccessToken)
	req.Header.Set("Content-Type", "application/json")

	resp, err := a.httpClient.Do(req)
	if err != nil {
		return fmt.Errorf("failed to send request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("whatsapp API error %d: %s", resp.StatusCode, string(body))
	}

	return nil
}

// ValidateConfig validates the WhatsApp configuration
func (a *WhatsAppAdapter) ValidateConfig(config channels.ChannelConfig) error {
	whatsappConfig, ok := config.(channels.WhatsAppConfig)
	if !ok {
		return channels.ErrInvalidChannelConfig().WithDetail("reason", "invalid config type")
	}

	return whatsappConfig.Validate()
}

// ProcessWebhook processes incoming WhatsApp webhooks WITH BUFFERING
func (a *WhatsAppAdapter) ProcessWebhook(
	ctx context.Context,
	payload []byte,
	headers map[string]string,
) (*channels.IncomingMessage, error) {
	// Verify signature
	if err := a.verifySignature(payload, headers); err != nil {
		return nil, err
	}

	// Parse webhook
	var webhook WhatsAppWebhook
	if err := json.Unmarshal(payload, &webhook); err != nil {
		return nil, fmt.Errorf("failed to parse webhook: %w", err)
	}

	// Extract message from webhook
	incomingMsg, err := a.extractIncomingMessage(webhook)
	if err != nil {
		return nil, err
	}

	if incomingMsg == nil {
		return nil, nil // No message (status update, etc.)
	}

	// Add to buffer
	processedMsg, shouldProcess, err := a.bufferService.AddMessage(
		ctx,
		incomingMsg.ChannelID,
		*incomingMsg,
	)

	if err != nil {
		return nil, fmt.Errorf("buffer error: %w", err)
	}

	// If shouldProcess is false, message is buffered - return nil
	if !shouldProcess {
		return nil, nil
	}

	// Message should be processed immediately
	return processedMsg, nil
}

// GetFeatures returns WhatsApp channel features
func (a *WhatsAppAdapter) GetFeatures() channels.ChannelFeatures {
	return a.config.GetFeatures()
}

// TestConnection tests the WhatsApp API connection
func (a *WhatsAppAdapter) TestConnection(ctx context.Context, config channels.ChannelConfig) error {
	whatsappConfig, ok := config.(channels.WhatsAppConfig)
	if !ok {
		return channels.ErrInvalidChannelConfig()
	}

	// Test by fetching phone number info
	url := fmt.Sprintf("%s/%s/%s",
		whatsappAPIBaseURL,
		whatsappConfig.APIVersion,
		whatsappConfig.PhoneNumberID,
	)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return err
	}

	req.Header.Set("Authorization", "Bearer "+whatsappConfig.AccessToken)

	resp, err := a.httpClient.Do(req)
	if err != nil {
		return channels.ErrProviderAPIError().WithCause(err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return channels.ErrProviderAuthFailed().
			WithDetail("status", resp.StatusCode).
			WithDetail("response", string(body))
	}

	return nil
}

// buildMessagePayload builds WhatsApp API payload
func (a *WhatsAppAdapter) buildMessagePayload(msg channels.OutgoingMessage) map[string]interface{} {
	payload := map[string]interface{}{
		"messaging_product": "whatsapp",
		"recipient_type":    "individual",
		"to":                msg.RecipientID,
	}

	// Handle different content types
	if msg.Content.Type == "text" {
		payload["type"] = "text"
		payload["text"] = map[string]interface{}{
			"body": msg.Content.Text,
		}
	} else if msg.Content.Type == "template" && msg.TemplateID != "" {
		payload["type"] = "template"
		payload["template"] = a.buildTemplatePayload(msg)
	}
	// Add more content types as needed

	return payload
}

// buildTemplatePayload builds template message payload
func (a *WhatsAppAdapter) buildTemplatePayload(msg channels.OutgoingMessage) map[string]interface{} {
	template := map[string]interface{}{
		"name":     msg.TemplateID,
		"language": map[string]string{"code": "en"},
	}

	if len(msg.Variables) > 0 {
		components := []map[string]interface{}{}
		parameters := []map[string]interface{}{}

		for _, value := range msg.Variables {
			parameters = append(parameters, map[string]interface{}{
				"type": "text",
				"text": value,
			})
		}

		components = append(components, map[string]interface{}{
			"type":       "body",
			"parameters": parameters,
		})

		template["components"] = components
	}

	return template
}

// verifySignature verifies WhatsApp webhook signature
func (a *WhatsAppAdapter) verifySignature(payload []byte, headers map[string]string) error {
	if a.config.AppSecret == "" {
		return nil // Skip verification if no secret configured
	}

	signature := headers["X-Hub-Signature-256"]
	if signature == "" {
		signature = headers["x-hub-signature-256"]
	}

	if signature == "" {
		return channels.ErrInvalidWebhookSignature()
	}

	// Remove "sha256=" prefix
	signature = strings.TrimPrefix(signature, "sha256=")

	// Calculate expected signature
	mac := hmac.New(sha256.New, []byte(a.config.AppSecret))
	mac.Write(payload)
	expectedSignature := hex.EncodeToString(mac.Sum(nil))

	if !hmac.Equal([]byte(signature), []byte(expectedSignature)) {
		return channels.ErrInvalidWebhookSignature()
	}

	return nil
}

// extractIncomingMessage extracts message from webhook
func (a *WhatsAppAdapter) extractIncomingMessage(webhook WhatsAppWebhook) (*channels.IncomingMessage, error) {
	for _, entry := range webhook.Entry {
		for _, change := range entry.Changes {
			if change.Value.MessagingProduct != "whatsapp" {
				continue
			}

			for _, msg := range change.Value.Messages {
				return &channels.IncomingMessage{
					MessageID: msg.ID,
					ChannelID: kernel.NewChannelID(a.config.PhoneNumberID),
					SenderID:  msg.From,
					Content: channels.MessageContent{
						Type: msg.Type,
						Text: a.extractText(msg),
					},
					Timestamp: msg.Timestamp,
					Metadata: map[string]any{
						"whatsapp_message_id": msg.ID,
					},
				}, nil
			}
		}
	}

	return nil, nil // No message found
}

// extractText extracts text from message
func (a *WhatsAppAdapter) extractText(msg WebhookMessage) string {
	if msg.Text != nil {
		return msg.Text.Body
	}
	if msg.Image != nil && msg.Image.Caption != "" {
		return msg.Image.Caption
	}
	return ""
}

// WhatsApp webhook structures
type WhatsAppWebhook struct {
	Object string         `json:"object"`
	Entry  []WebhookEntry `json:"entry"`
}

type WebhookEntry struct {
	ID      string          `json:"id"`
	Changes []WebhookChange `json:"changes"`
}

type WebhookChange struct {
	Value WebhookValue `json:"value"`
	Field string       `json:"field"`
}

type WebhookValue struct {
	MessagingProduct string           `json:"messaging_product"`
	Metadata         WebhookMetadata  `json:"metadata"`
	Messages         []WebhookMessage `json:"messages"`
	Statuses         []WebhookStatus  `json:"statuses"`
}

type WebhookMetadata struct {
	DisplayPhoneNumber string `json:"display_phone_number"`
	PhoneNumberID      string `json:"phone_number_id"`
}

type WebhookMessage struct {
	ID        kernel.MessageID `json:"id"`
	From      string           `json:"from"`
	Timestamp int64            `json:"timestamp,string"`
	Type      string           `json:"type"`
	Text      *WebhookText     `json:"text,omitempty"`
	Image     *WebhookMedia    `json:"image,omitempty"`
	Document  *WebhookMedia    `json:"document,omitempty"`
	Audio     *WebhookMedia    `json:"audio,omitempty"`
	Video     *WebhookMedia    `json:"video,omitempty"`
}

type WebhookText struct {
	Body string `json:"body"`
}

type WebhookMedia struct {
	ID       string `json:"id"`
	MimeType string `json:"mime_type"`
	SHA256   string `json:"sha256"`
	Caption  string `json:"caption,omitempty"`
}

type WebhookStatus struct {
	ID          string `json:"id"`
	Status      string `json:"status"`
	Timestamp   int64  `json:"timestamp,string"`
	RecipientID string `json:"recipient_id"`
}
package whatsapp

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/Abraxas-365/relay/channels"
	"github.com/Abraxas-365/relay/pkg/kernel"
	"github.com/go-redis/redis/v8"
)

// BufferedMessage represents a message waiting in the buffer
type BufferedMessage struct {
	MessageID   kernel.MessageID      `json:"message_id"`
	SenderID    string                `json:"sender_id"`
	Content     string                `json:"content"`
	ReceivedAt  time.Time             `json:"received_at"`
	Attachments []channels.Attachment `json:"attachments,omitempty"`
	Metadata    map[string]any        `json:"metadata,omitempty"`
}

// MessageBuffer represents the complete buffer state for a user
type MessageBuffer struct {
	ChannelID    kernel.ChannelID  `json:"channel_id"`
	SenderID     string            `json:"sender_id"`
	Messages     []BufferedMessage `json:"messages"`
	FirstMessage time.Time         `json:"first_message"`
	LastMessage  time.Time         `json:"last_message"`
	TimerKey     string            `json:"timer_key,omitempty"`
}

// BufferService handles message buffering with Redis
type BufferService struct {
	redis  *redis.Client
	config channels.WhatsAppConfig
}

// NewBufferService creates a new buffer service
func NewBufferService(redisClient *redis.Client, config channels.WhatsAppConfig) *BufferService {
	return &BufferService{
		redis:  redisClient,
		config: config,
	}
}

// getBufferKey generates Redis key for message buffer
func (s *BufferService) getBufferKey(channelID kernel.ChannelID, senderID string) string {
	return fmt.Sprintf("relay:buffer:%s:%s", channelID, senderID)
}

// getTimerKey generates Redis key for buffer timer
func (s *BufferService) getTimerKey(channelID kernel.ChannelID, senderID string) string {
	return fmt.Sprintf("relay:buffer:timer:%s:%s", channelID, senderID)
}

// AddMessage adds a message to the buffer or triggers flush if buffer is disabled
func (s *BufferService) AddMessage(
	ctx context.Context,
	channelID kernel.ChannelID,
	message channels.IncomingMessage,
) (*channels.IncomingMessage, bool, error) {
	// If buffering is disabled, return message immediately
	if !s.config.BufferEnabled {
		return &message, true, nil
	}

	bufferKey := s.getBufferKey(channelID, message.SenderID)
	timerKey := s.getTimerKey(channelID, message.SenderID)

	// Get existing buffer
	buffer, err := s.getBuffer(ctx, bufferKey)
	if err != nil && err != redis.Nil {
		return nil, false, fmt.Errorf("failed to get buffer: %w", err)
	}

	now := time.Now()

	// Initialize new buffer if doesn't exist
	if buffer == nil {
		buffer = &MessageBuffer{
			ChannelID:    channelID,
			SenderID:     message.SenderID,
			Messages:     []BufferedMessage{},
			FirstMessage: now,
			LastMessage:  now,
		}
	}

	// Add message to buffer
	bufferedMsg := BufferedMessage{
		MessageID:   message.MessageID,
		SenderID:    message.SenderID,
		Content:     s.extractContent(message),
		ReceivedAt:  now,
		Attachments: message.Content.Attachments,
		Metadata:    message.Metadata,
	}

	buffer.Messages = append(buffer.Messages, bufferedMsg)
	buffer.LastMessage = now

	// Save buffer
	if err := s.saveBuffer(ctx, bufferKey, buffer); err != nil {
		return nil, false, fmt.Errorf("failed to save buffer: %w", err)
	}

	// Calculate TTL for buffer timeout
	bufferDuration := time.Duration(s.config.BufferTimeSeconds) * time.Second

	// If BufferResetOnMessage is true, reset the timer on each new message
	if s.config.BufferResetOnMessage {
		// Delete old timer if exists
		s.redis.Del(ctx, timerKey)

		// Set new timer
		s.redis.SetEX(ctx, timerKey, "1", bufferDuration)

		// Set buffer expiry (slightly longer than timer)
		s.redis.Expire(ctx, bufferKey, bufferDuration+time.Second)

		// Return nil to indicate message is buffered (don't process yet)
		return nil, false, nil
	}

	// If NOT resetting on each message, check if this is first message
	exists, _ := s.redis.Exists(ctx, timerKey).Result()
	if exists == 0 {
		// First message - start timer
		s.redis.SetEX(ctx, timerKey, "1", bufferDuration)
		s.redis.Expire(ctx, bufferKey, bufferDuration+time.Second)

		// Return nil to indicate message is buffered
		return nil, false, nil
	}

	// Timer already running, just add to buffer
	return nil, false, nil
}

// CheckAndFlush checks if buffer should be flushed and returns combined message
func (s *BufferService) CheckAndFlush(
	ctx context.Context,
	channelID kernel.ChannelID,
	senderID string,
) (*channels.IncomingMessage, error) {
	if !s.config.BufferEnabled {
		return nil, nil
	}

	bufferKey := s.getBufferKey(channelID, senderID)
	timerKey := s.getTimerKey(channelID, senderID)

	// Check if timer has expired
	exists, _ := s.redis.Exists(ctx, timerKey).Result()
	if exists > 0 {
		// Timer still running, don't flush
		return nil, nil
	}

	// Timer expired, flush buffer
	buffer, err := s.getBuffer(ctx, bufferKey)
	if err != nil {
		if err == redis.Nil {
			return nil, nil // No buffer exists
		}
		return nil, fmt.Errorf("failed to get buffer: %w", err)
	}

	if buffer == nil || len(buffer.Messages) == 0 {
		return nil, nil
	}

	// Combine messages
	combinedMessage := s.combineMessages(buffer)

	// Delete buffer and timer
	s.redis.Del(ctx, bufferKey, timerKey)

	return combinedMessage, nil
}

// FlushNow immediately flushes the buffer for a user
func (s *BufferService) FlushNow(
	ctx context.Context,
	channelID kernel.ChannelID,
	senderID string,
) (*channels.IncomingMessage, error) {
	bufferKey := s.getBufferKey(channelID, senderID)
	timerKey := s.getTimerKey(channelID, senderID)

	buffer, err := s.getBuffer(ctx, bufferKey)
	if err != nil {
		if err == redis.Nil {
			return nil, nil
		}
		return nil, err
	}

	if buffer == nil || len(buffer.Messages) == 0 {
		return nil, nil
	}

	combinedMessage := s.combineMessages(buffer)

	// Delete buffer and timer
	s.redis.Del(ctx, bufferKey, timerKey)

	return combinedMessage, nil
}

// getBuffer retrieves buffer from Redis
func (s *BufferService) getBuffer(ctx context.Context, key string) (*MessageBuffer, error) {
	data, err := s.redis.Get(ctx, key).Result()
	if err != nil {
		return nil, err
	}

	var buffer MessageBuffer
	if err := json.Unmarshal([]byte(data), &buffer); err != nil {
		return nil, err
	}

	return &buffer, nil
}

// saveBuffer saves buffer to Redis
func (s *BufferService) saveBuffer(ctx context.Context, key string, buffer *MessageBuffer) error {
	data, err := json.Marshal(buffer)
	if err != nil {
		return err
	}

	// Buffer expires after timeout + 1 second
	expiry := time.Duration(s.config.BufferTimeSeconds+1) * time.Second
	return s.redis.Set(ctx, key, data, expiry).Err()
}

// combineMessages combines buffered messages into a single message
func (s *BufferService) combineMessages(buffer *MessageBuffer) *channels.IncomingMessage {
	if len(buffer.Messages) == 0 {
		return nil
	}

	// Use first message as base
	firstMsg := buffer.Messages[0]

	// Combine all message contents with line breaks
	var combinedContent string
	var allAttachments []channels.Attachment
	combinedMetadata := make(map[string]any)

	for i, msg := range buffer.Messages {
		if i > 0 {
			combinedContent += "\n"
		}
		combinedContent += msg.Content

		// Collect attachments
		allAttachments = append(allAttachments, msg.Attachments...)

		// Merge metadata
		for k, v := range msg.Metadata {
			combinedMetadata[k] = v
		}
	}

	// Add buffer metadata
	combinedMetadata["buffered"] = true
	combinedMetadata["message_count"] = len(buffer.Messages)
	combinedMetadata["first_message_at"] = buffer.FirstMessage
	combinedMetadata["last_message_at"] = buffer.LastMessage
	combinedMetadata["buffer_duration_seconds"] = buffer.LastMessage.Sub(buffer.FirstMessage).Seconds()

	// Create combined message
	return &channels.IncomingMessage{
		MessageID: firstMsg.MessageID,
		ChannelID: buffer.ChannelID,
		SenderID:  buffer.SenderID,
		Content: channels.MessageContent{
			Type:        "text",
			Text:        combinedContent,
			Attachments: allAttachments,
		},
		Timestamp: buffer.FirstMessage.Unix(),
		Metadata:  combinedMetadata,
	}
}

// extractContent extracts text content from message
func (s *BufferService) extractContent(msg channels.IncomingMessage) string {
	if msg.Content.Text != "" {
		return msg.Content.Text
	}
	if msg.Content.Caption != "" {
		return msg.Content.Caption
	}
	if msg.Content.Type != "" {
		return fmt.Sprintf("[%s]", msg.Content.Type)
	}
	return ""
}
package channelsrv

import (
	"context"
	"time"

	"github.com/Abraxas-365/craftable/errx"
	"github.com/Abraxas-365/relay/channels"
	"github.com/Abraxas-365/relay/iam/tenant"
	"github.com/Abraxas-365/relay/pkg/kernel"
	"github.com/google/uuid"
)

// ChannelService proporciona operaciones de negocio para canales
type ChannelService struct {
	channelRepo    channels.ChannelRepository
	tenantRepo     tenant.TenantRepository
	channelManager channels.ChannelManager
}

// NewChannelService crea una nueva instancia del servicio de canales
func NewChannelService(
	channelRepo channels.ChannelRepository,
	tenantRepo tenant.TenantRepository,
	channelManager channels.ChannelManager,
) *ChannelService {
	return &ChannelService{
		channelRepo:    channelRepo,
		tenantRepo:     tenantRepo,
		channelManager: channelManager,
	}
}

// ============================================================================
// CRUD Operations
// ============================================================================

// CreateChannel crea un nuevo canal
func (s *ChannelService) CreateChannel(ctx context.Context, req channels.CreateChannelRequest) (*channels.Channel, error) {
	// Verificar que el tenant exista y esté activo
	tenantEntity, err := s.tenantRepo.FindByID(ctx, req.TenantID)
	if err != nil {
		return nil, tenant.ErrTenantNotFound()
	}

	if !tenantEntity.IsActive() {
		return nil, tenant.ErrTenantSuspended()
	}

	// Verificar que no exista un canal con el mismo nombre
	exists, err := s.channelRepo.ExistsByName(ctx, req.Name, req.TenantID)
	if err != nil {
		return nil, errx.Wrap(err, "failed to check channel name existence", errx.TypeInternal)
	}
	if exists {
		return nil, channels.ErrChannelAlreadyExists().WithDetail("name", req.Name)
	}

	// Generar webhook URL
	webhookURL := s.generateWebhookURL(req.TenantID, req.Type)

	// Crear canal usando el helper
	newChannel, err := channels.NewChannelFromConfig(
		kernel.NewChannelID(uuid.NewString()),
		req.TenantID,
		req.Name,
		req.Description,
		req.Config,
		webhookURL,
	)
	if err != nil {
		return nil, errx.Wrap(err, "failed to create channel", errx.TypeInternal)
	}

	// Validar config usando el adapter si está disponible
	if adapter, err := s.channelManager.GetAdapter(newChannel.Type); err == nil {
		if err := adapter.ValidateConfig(req.Config); err != nil {
			return nil, channels.ErrInvalidChannelConfig().
				WithDetail("reason", err.Error())
		}
	}

	// Guardar canal
	if err := s.channelRepo.Save(ctx, *newChannel); err != nil {
		return nil, errx.Wrap(err, "failed to save channel", errx.TypeInternal)
	}

	// Registrar en el channel manager
	if err := s.channelManager.RegisterChannel(ctx, *newChannel); err != nil {
		// Log error but don't fail
		// logger.Error("Failed to register channel in manager", err)
	}

	return newChannel, nil
}

// GetChannelByID obtiene un canal por ID
func (s *ChannelService) GetChannelByID(ctx context.Context, channelID kernel.ChannelID, tenantID kernel.TenantID) (*channels.ChannelResponse, error) {
	channel, err := s.channelRepo.FindByID(ctx, channelID, tenantID)
	if err != nil {
		return nil, channels.ErrChannelNotFound().WithDetail("channel_id", channelID.String())
	}

	features, err := channel.GetFeatures()
	if err != nil {
		// Return channel without features
		features = channels.ChannelFeatures{}
	}

	return &channels.ChannelResponse{
		Channel:  *channel,
		Features: features,
	}, nil
}

// GetChannelByName obtiene un canal por nombre
func (s *ChannelService) GetChannelByName(ctx context.Context, name string, tenantID kernel.TenantID) (*channels.ChannelResponse, error) {
	channel, err := s.channelRepo.FindByName(ctx, name, tenantID)
	if err != nil {
		return nil, channels.ErrChannelNotFound().WithDetail("name", name)
	}

	features, _ := channel.GetFeatures()

	return &channels.ChannelResponse{
		Channel:  *channel,
		Features: features,
	}, nil
}

// GetChannelsByTenant obtiene todos los canales de un tenant
func (s *ChannelService) GetChannelsByTenant(ctx context.Context, tenantID kernel.TenantID) ([]*channels.Channel, error) {
	return s.channelRepo.FindByTenant(ctx, tenantID)
}

// GetActiveChannels obtiene canales activos de un tenant
func (s *ChannelService) GetActiveChannels(ctx context.Context, tenantID kernel.TenantID) ([]*channels.Channel, error) {
	return s.channelRepo.FindActive(ctx, tenantID)
}

// GetChannelsByType obtiene canales por tipo
func (s *ChannelService) GetChannelsByType(ctx context.Context, channelType channels.ChannelType, tenantID kernel.TenantID) ([]*channels.Channel, error) {
	return s.channelRepo.FindByType(ctx, channelType, tenantID)
}

// UpdateChannel actualiza un canal
func (s *ChannelService) UpdateChannel(ctx context.Context, channelID kernel.ChannelID, req channels.UpdateChannelRequest, tenantID kernel.TenantID) (*channels.Channel, error) {
	channel, err := s.channelRepo.FindByID(ctx, channelID, tenantID)
	if err != nil {
		return nil, channels.ErrChannelNotFound().WithDetail("channel_id", channelID.String())
	}

	// Actualizar campos si se proporcionaron
	if req.Name != nil {
		// Verificar que no exista otro canal con el mismo nombre
		if *req.Name != channel.Name {
			exists, err := s.channelRepo.ExistsByName(ctx, *req.Name, tenantID)
			if err != nil {
				return nil, errx.Wrap(err, "failed to check channel name", errx.TypeInternal)
			}
			if exists {
				return nil, channels.ErrChannelAlreadyExists().WithDetail("name", *req.Name)
			}
		}
		channel.Name = *req.Name
	}

	if req.Description != nil {
		channel.Description = *req.Description
	}

	if req.Config != nil {
		// Validar config
		if adapter, err := s.channelManager.GetAdapter(channel.Type); err == nil {
			if err := adapter.ValidateConfig(*req.Config); err != nil {
				return nil, channels.ErrInvalidChannelConfig().WithDetail("reason", err.Error())
			}
		}

		if err := channel.UpdateConfig(*req.Config); err != nil {
			return nil, errx.Wrap(err, "failed to update config", errx.TypeInternal)
		}
	}

	if req.IsActive != nil {
		if *req.IsActive {
			channel.Activate()
		} else {
			channel.Deactivate()
		}
	}

	channel.UpdatedAt = time.Now()

	// Guardar cambios
	if err := s.channelRepo.Save(ctx, *channel); err != nil {
		return nil, errx.Wrap(err, "failed to update channel", errx.TypeInternal)
	}

	return channel, nil
}

// ActivateChannel activa un canal
func (s *ChannelService) ActivateChannel(ctx context.Context, channelID kernel.ChannelID, tenantID kernel.TenantID) error {
	channel, err := s.channelRepo.FindByID(ctx, channelID, tenantID)
	if err != nil {
		return channels.ErrChannelNotFound().WithDetail("channel_id", channelID.String())
	}

	channel.Activate()
	return s.channelRepo.Save(ctx, *channel)
}

// DeactivateChannel desactiva un canal
func (s *ChannelService) DeactivateChannel(ctx context.Context, channelID kernel.ChannelID, tenantID kernel.TenantID) error {
	channel, err := s.channelRepo.FindByID(ctx, channelID, tenantID)
	if err != nil {
		return channels.ErrChannelNotFound().WithDetail("channel_id", channelID.String())
	}

	channel.Deactivate()
	return s.channelRepo.Save(ctx, *channel)
}

// DeleteChannel elimina un canal
func (s *ChannelService) DeleteChannel(ctx context.Context, channelID kernel.ChannelID, tenantID kernel.TenantID) error {
	// Verificar que el canal existe
	_, err := s.channelRepo.FindByID(ctx, channelID, tenantID)
	if err != nil {
		return channels.ErrChannelNotFound().WithDetail("channel_id", channelID.String())
	}

	// Eliminar canal
	return s.channelRepo.Delete(ctx, channelID, tenantID)
}

// ============================================================================
// Messaging Operations
// ============================================================================

// SendMessage envía un mensaje a través de un canal
func (s *ChannelService) SendMessage(ctx context.Context, channelID kernel.ChannelID, msg channels.OutgoingMessage) (*channels.SendMessageResponse, error) {
	// Verificar que el canal existe y está activo
	channel, err := s.channelRepo.FindByID(ctx, channelID, msg.Metadata["tenant_id"].(kernel.TenantID))
	if err != nil {
		return nil, channels.ErrChannelNotFound().WithDetail("channel_id", channelID.String())
	}

	if !channel.IsActive {
		return nil, channels.ErrChannelInactive().WithDetail("channel_id", channelID.String())
	}

	// Enviar mensaje usando el channel manager
	startTime := time.Now()
	if err := s.channelManager.SendMessage(ctx, channelID, msg); err != nil {
		return &channels.SendMessageResponse{
			Success:   false,
			Timestamp: time.Now().Unix(),
			Error:     err.Error(),
		}, err
	}

	return &channels.SendMessageResponse{
		Success:   true,
		Timestamp: time.Now().Unix(),
		Metadata: map[string]any{
			"processing_time_ms": time.Since(startTime).Milliseconds(),
		},
	}, nil
}

// TestChannel prueba la conexión de un canal
func (s *ChannelService) TestChannel(ctx context.Context, channelID kernel.ChannelID, tenantID kernel.TenantID) (*channels.TestChannelResponse, error) {
	channel, err := s.channelRepo.FindByID(ctx, channelID, tenantID)
	if err != nil {
		return nil, channels.ErrChannelNotFound().WithDetail("channel_id", channelID.String())
	}

	// Obtener adapter
	adapter, err := s.channelManager.GetAdapter(channel.Type)
	if err != nil {
		return &channels.TestChannelResponse{
			Success: false,
			Message: "Adapter not available",
			Error:   err.Error(),
		}, err
	}

	// Probar conexión
	startTime := time.Now()
	config, err := channel.GetConfigStruct()
	if err != nil {
		return &channels.TestChannelResponse{
			Success: false,
			Message: "Invalid channel configuration",
			Error:   err.Error(),
		}, err
	}

	if err := adapter.TestConnection(ctx, config); err != nil {
		return &channels.TestChannelResponse{
			Success:      false,
			Message:      "Connection test failed",
			ResponseTime: time.Since(startTime).Milliseconds(),
			Error:        err.Error(),
		}, err
	}

	return &channels.TestChannelResponse{
		Success:      true,
		Message:      "Connection test successful",
		ResponseTime: time.Since(startTime).Milliseconds(),
	}, nil
}

// ============================================================================
// Bulk Operations
// ============================================================================

// BulkActivateChannels activa múltiples canales
func (s *ChannelService) BulkActivateChannels(ctx context.Context, channelIDs []kernel.ChannelID, tenantID kernel.TenantID) (*channels.BulkChannelOperationResponse, error) {
	result := &channels.BulkChannelOperationResponse{
		Successful: []kernel.ChannelID{},
		Failed:     make(map[kernel.ChannelID]string),
		Total:      len(channelIDs),
	}

	for _, channelID := range channelIDs {
		if err := s.ActivateChannel(ctx, channelID, tenantID); err != nil {
			result.Failed[channelID] = err.Error()
		} else {
			result.Successful = append(result.Successful, channelID)
		}
	}

	return result, nil
}

// BulkDeactivateChannels desactiva múltiples canales
func (s *ChannelService) BulkDeactivateChannels(ctx context.Context, channelIDs []kernel.ChannelID, tenantID kernel.TenantID) (*channels.BulkChannelOperationResponse, error) {
	result := &channels.BulkChannelOperationResponse{
		Successful: []kernel.ChannelID{},
		Failed:     make(map[kernel.ChannelID]string),
		Total:      len(channelIDs),
	}

	for _, channelID := range channelIDs {
		if err := s.DeactivateChannel(ctx, channelID, tenantID); err != nil {
			result.Failed[channelID] = err.Error()
		} else {
			result.Successful = append(result.Successful, channelID)
		}
	}

	return result, nil
}

// ============================================================================
// Helper Methods
// ============================================================================

// generateWebhookURL genera una URL de webhook para el canal
func (s *ChannelService) generateWebhookURL(tenantID kernel.TenantID, channelType channels.ChannelType) string {
	// En producción, esto debería usar la configuración real del servidor
	baseURL := "https://api.yourdomain.com" // O desde config
	return baseURL + "/webhooks/channels/" + string(channelType) + "/" + tenantID.String()
}
package channels

import (
	"context"

	"github.com/Abraxas-365/relay/pkg/kernel"
)

// ============================================================================
// Repository Interfaces
// ============================================================================

// ChannelRepository define el contrato para persistencia de canales
type ChannelRepository interface {
	// CRUD básico
	Save(ctx context.Context, channel Channel) error
	FindByID(ctx context.Context, id kernel.ChannelID, tenantID kernel.TenantID) (*Channel, error)
	FindByName(ctx context.Context, name string, tenantID kernel.TenantID) (*Channel, error)
	Delete(ctx context.Context, id kernel.ChannelID, tenantID kernel.TenantID) error
	ExistsByName(ctx context.Context, name string, tenantID kernel.TenantID) (bool, error)

	// Búsquedas específicas
	FindByTenant(ctx context.Context, tenantID kernel.TenantID) ([]*Channel, error)
	FindByType(ctx context.Context, channelType ChannelType, tenantID kernel.TenantID) ([]*Channel, error)
	FindActive(ctx context.Context, tenantID kernel.TenantID) ([]*Channel, error)
	FindByProvider(ctx context.Context, provider string, tenantID kernel.TenantID) ([]*Channel, error)

	// List con paginación
	List(ctx context.Context, req ListChannelsRequest) (ChannelListResponse, error)

	// Bulk operations
	BulkUpdateStatus(ctx context.Context, ids []kernel.ChannelID, tenantID kernel.TenantID, isActive bool) error

	// Stats
	CountByType(ctx context.Context, channelType ChannelType, tenantID kernel.TenantID) (int, error)
	CountByTenant(ctx context.Context, tenantID kernel.TenantID) (int, error)
}

// ============================================================================
// Adapter Interfaces
// ============================================================================

// ChannelAdapter interfaz para adaptadores de canal específicos
type ChannelAdapter interface {
	// GetType retorna el tipo de canal que maneja
	GetType() ChannelType

	// SendMessage envía un mensaje a través del canal
	SendMessage(ctx context.Context, msg OutgoingMessage) error

	// ValidateConfig valida la configuración del canal
	ValidateConfig(config ChannelConfig) error

	// ProcessWebhook procesa webhooks entrantes del proveedor
	ProcessWebhook(ctx context.Context, payload []byte, headers map[string]string) (*IncomingMessage, error)

	// GetFeatures retorna las características soportadas
	GetFeatures() ChannelFeatures

	// TestConnection prueba la conexión con el proveedor
	TestConnection(ctx context.Context, config ChannelConfig) error
}

// ============================================================================
// Manager Interfaces
// ============================================================================

// ChannelManager gestiona operaciones de alto nivel con canales
type ChannelManager interface {
	// RegisterChannel registra un nuevo canal
	RegisterChannel(ctx context.Context, channel Channel) error

	// SendMessage envía un mensaje a través de un canal
	SendMessage(ctx context.Context, channelID kernel.ChannelID, msg OutgoingMessage) error

	// ProcessIncomingMessage procesa un mensaje entrante
	ProcessIncomingMessage(ctx context.Context, channelID kernel.ChannelID, msg IncomingMessage) error

	// GetAdapter obtiene el adapter para un tipo de canal
	GetAdapter(channelType ChannelType) (ChannelAdapter, error)

	// RegisterAdapter registra un adapter
	RegisterAdapter(adapter ChannelAdapter)

	// TestChannel prueba la conexión de un canal
	TestChannel(ctx context.Context, channelID kernel.ChannelID) error
}
package channels

import (
	"github.com/Abraxas-365/craftable/storex"
	"github.com/Abraxas-365/relay/pkg/kernel"
)

// ============================================================================
// Message DTOs
// ============================================================================

// OutgoingMessage mensaje saliente a enviar por el canal
type OutgoingMessage struct {
	RecipientID string            `json:"recipient_id" validate:"required"`
	Content     MessageContent    `json:"content" validate:"required"`
	Metadata    map[string]any    `json:"metadata,omitempty"`
	ReplyToID   string            `json:"reply_to_id,omitempty"`
	TemplateID  string            `json:"template_id,omitempty"`
	Variables   map[string]string `json:"variables,omitempty"`
}

// IncomingMessage mensaje entrante recibido del canal
type IncomingMessage struct {
	MessageID  kernel.MessageID `json:"message_id"`
	ChannelID  kernel.ChannelID `json:"channel_id"`
	SenderID   string           `json:"sender_id"`
	Content    MessageContent   `json:"content"`
	Timestamp  int64            `json:"timestamp"`
	Metadata   map[string]any   `json:"metadata,omitempty"`
	RawPayload map[string]any   `json:"raw_payload,omitempty"`
}

// MessageContent contenido del mensaje
type MessageContent struct {
	Type        string         `json:"type"` // text, image, audio, video, document, location, contact
	Text        string         `json:"text,omitempty"`
	MediaURL    string         `json:"media_url,omitempty"`
	Caption     string         `json:"caption,omitempty"`
	MimeType    string         `json:"mime_type,omitempty"`
	Filename    string         `json:"filename,omitempty"`
	Attachments []Attachment   `json:"attachments,omitempty"`
	Location    *Location      `json:"location,omitempty"`
	Contact     *Contact       `json:"contact,omitempty"`
	Interactive *Interactive   `json:"interactive,omitempty"`
	Metadata    map[string]any `json:"metadata,omitempty"`
}

// Attachment archivo adjunto
type Attachment struct {
	Type     string `json:"type"` // image, audio, video, document
	URL      string `json:"url"`
	MimeType string `json:"mime_type,omitempty"`
	Filename string `json:"filename,omitempty"`
	Size     int64  `json:"size,omitempty"`
	Caption  string `json:"caption,omitempty"`
}

// Location ubicación geográfica
type Location struct {
	Latitude  float64 `json:"latitude"`
	Longitude float64 `json:"longitude"`
	Name      string  `json:"name,omitempty"`
	Address   string  `json:"address,omitempty"`
}

// Contact contacto compartido
type Contact struct {
	Name         string `json:"name"`
	PhoneNumber  string `json:"phone_number,omitempty"`
	Email        string `json:"email,omitempty"`
	Organization string `json:"organization,omitempty"`
}

// Interactive mensaje interactivo (botones, listas, etc)
type Interactive struct {
	Type    string   `json:"type"` // button, list, template
	Header  string   `json:"header,omitempty"`
	Body    string   `json:"body"`
	Footer  string   `json:"footer,omitempty"`
	Buttons []Button `json:"buttons,omitempty"`
	Items   []Item   `json:"items,omitempty"`
}

// Button botón interactivo
type Button struct {
	ID    string `json:"id"`
	Title string `json:"title"`
	Type  string `json:"type,omitempty"` // reply, url, call
	URL   string `json:"url,omitempty"`
	Phone string `json:"phone,omitempty"`
}

// Item elemento de lista
type Item struct {
	ID          string `json:"id"`
	Title       string `json:"title"`
	Description string `json:"description,omitempty"`
}

// ============================================================================
// Request DTOs
// ============================================================================

// CreateChannelRequest request para crear un canal
type CreateChannelRequest struct {
	TenantID    kernel.TenantID `json:"tenant_id" validate:"required"`
	Name        string          `json:"name" validate:"required,min=2"`
	Description string          `json:"description"`
	Type        ChannelType     `json:"type" validate:"required"`
	Config      ChannelConfig   `json:"config" validate:"required"`
}

// UpdateChannelRequest request para actualizar un canal
type UpdateChannelRequest struct {
	Name        *string        `json:"name,omitempty"`
	Description *string        `json:"description,omitempty"`
	Config      *ChannelConfig `json:"config,omitempty"`
	IsActive    *bool          `json:"is_active,omitempty"`
}

// SendMessageRequest request para enviar mensaje
type SendMessageRequest struct {
	ChannelID   kernel.ChannelID  `json:"channel_id" validate:"required"`
	RecipientID string            `json:"recipient_id" validate:"required"`
	Content     MessageContent    `json:"content" validate:"required"`
	ReplyToID   string            `json:"reply_to_id,omitempty"`
	TemplateID  string            `json:"template_id,omitempty"`
	Variables   map[string]string `json:"variables,omitempty"`
}

// TestChannelRequest request para probar un canal
type TestChannelRequest struct {
	ChannelID   kernel.ChannelID `json:"channel_id" validate:"required"`
	RecipientID string           `json:"recipient_id" validate:"required"`
	Message     string           `json:"message"`
}

// ProcessWebhookRequest request para procesar webhook
type ProcessWebhookRequest struct {
	ChannelID kernel.ChannelID  `json:"channel_id" validate:"required"`
	Payload   map[string]any    `json:"payload" validate:"required"`
	Headers   map[string]string `json:"headers,omitempty"`
	Signature string            `json:"signature,omitempty"`
}

// ============================================================================
// List Request DTOs
// ============================================================================

// ListChannelsRequest request para listar canales
type ListChannelsRequest struct {
	storex.PaginationOptions

	TenantID kernel.TenantID `json:"tenant_id" validate:"required"`
	Type     *ChannelType    `json:"type,omitempty"`
	IsActive *bool           `json:"is_active,omitempty"`
	Provider *string         `json:"provider,omitempty"`
	Search   string          `json:"search,omitempty"`
}

func (lcr ListChannelsRequest) GetOffset() int {
	page := lcr.Page
	size := lcr.PageSize
	return (page - 1) * size
}

// ============================================================================
// Response DTOs
// ============================================================================

// ChannelResponse respuesta con canal
type ChannelResponse struct {
	Channel  Channel         `json:"channel"`
	Features ChannelFeatures `json:"features"`
	Stats    *ChannelStats   `json:"stats,omitempty"`
}

// ChannelListResponse lista paginada de canales
type ChannelListResponse = storex.Paginated[Channel]

// SendMessageResponse respuesta de envío de mensaje
type SendMessageResponse struct {
	Success       bool           `json:"success"`
	MessageID     string         `json:"message_id,omitempty"`
	ProviderMsgID string         `json:"provider_message_id,omitempty"`
	Timestamp     int64          `json:"timestamp"`
	Error         string         `json:"error,omitempty"`
	Metadata      map[string]any `json:"metadata,omitempty"`
}

// TestChannelResponse respuesta de prueba de canal
type TestChannelResponse struct {
	Success      bool           `json:"success"`
	Message      string         `json:"message"`
	ResponseTime int64          `json:"response_time_ms"`
	ProviderInfo map[string]any `json:"provider_info,omitempty"`
	Error        string         `json:"error,omitempty"`
}

// ProcessWebhookResponse respuesta de procesamiento de webhook
type ProcessWebhookResponse struct {
	Success   bool            `json:"success"`
	Message   IncomingMessage `json:"message,omitempty"`
	Processed bool            `json:"processed"`
	Error     string          `json:"error,omitempty"`
}

// ============================================================================
// Stats DTOs
// ============================================================================

// ChannelStats estadísticas de un canal
type ChannelStats struct {
	ChannelID         kernel.ChannelID `json:"channel_id"`
	ChannelName       string           `json:"channel_name"`
	TotalMessagesSent int              `json:"total_messages_sent"`
	TotalMessagesRecv int              `json:"total_messages_received"`
	SuccessRate       float64          `json:"success_rate"`
	AvgResponseTime   float64          `json:"avg_response_time_ms"`
	LastMessageAt     *string          `json:"last_message_at,omitempty"`
	ErrorCount        int              `json:"error_count"`
}

// ChannelUsageResponse uso de canales en un periodo
type ChannelUsageResponse struct {
	TenantID         kernel.TenantID         `json:"tenant_id"`
	Period           string                  `json:"period"` // day, week, month
	TotalMessages    int                     `json:"total_messages"`
	MessagesSent     int                     `json:"messages_sent"`
	MessagesReceived int                     `json:"messages_received"`
	SuccessRate      float64                 `json:"success_rate"`
	ChannelBreakdown []ChannelUsageBreakdown `json:"channel_breakdown"`
}

type ChannelUsageBreakdown struct {
	ChannelID    kernel.ChannelID `json:"channel_id"`
	ChannelName  string           `json:"channel_name"`
	ChannelType  ChannelType      `json:"channel_type"`
	MessagesSent int              `json:"messages_sent"`
	MessagesRecv int              `json:"messages_received"`
	SuccessRate  float64          `json:"success_rate"`
}

// ============================================================================
// Bulk Operation DTOs
// ============================================================================

// BulkChannelOperationRequest request para operaciones masivas
type BulkChannelOperationRequest struct {
	TenantID   kernel.TenantID    `json:"tenant_id" validate:"required"`
	ChannelIDs []kernel.ChannelID `json:"channel_ids" validate:"required,min=1"`
	Operation  string             `json:"operation" validate:"required,oneof=activate deactivate delete test"`
}

// BulkChannelOperationResponse respuesta de operación masiva
type BulkChannelOperationResponse struct {
	Successful []kernel.ChannelID          `json:"successful"`
	Failed     map[kernel.ChannelID]string `json:"failed"`
	Total      int                         `json:"total"`
}

// ============================================================================
// Simple DTOs
// ============================================================================

// ChannelDetailsDTO DTO simplificado de canal
type ChannelDetailsDTO struct {
	ID         kernel.ChannelID `json:"id"`
	Name       string           `json:"name"`
	Type       ChannelType      `json:"type"`
	Provider   string           `json:"provider"`
	IsActive   bool             `json:"is_active"`
	WebhookURL string           `json:"webhook_url"`
}

// ToDTO convierte Channel a ChannelDetailsDTO
func (c *Channel) ToDTO() ChannelDetailsDTO {
	return ChannelDetailsDTO{
		ID:         c.ID,
		Name:       c.Name,
		Type:       c.Type,
		Provider:   c.GetProvider(),
		IsActive:   c.IsActive,
		WebhookURL: c.WebhookURL,
	}
}

// ============================================================================
// Validation DTOs
// ============================================================================

// ValidateChannelConfigRequest request para validar config de canal
type ValidateChannelConfigRequest struct {
	Type   ChannelType   `json:"type" validate:"required"`
	Config ChannelConfig `json:"config" validate:"required"`
}

// ValidateChannelConfigResponse respuesta de validación
type ValidateChannelConfigResponse struct {
	IsValid  bool     `json:"is_valid"`
	Errors   []string `json:"errors,omitempty"`
	Warnings []string `json:"warnings,omitempty"`
}

// ChannelFeaturesResponse características de un tipo de canal
type ChannelFeaturesResponse struct {
	ChannelType ChannelType     `json:"channel_type"`
	Features    ChannelFeatures `json:"features"`
}

// AvailableChannelTypesResponse tipos de canales disponibles
type AvailableChannelTypesResponse struct {
	Types []ChannelTypeInfo `json:"types"`
}

type ChannelTypeInfo struct {
	Type        ChannelType     `json:"type"`
	Name        string          `json:"name"`
	Description string          `json:"description"`
	Providers   []string        `json:"providers"`
	Features    ChannelFeatures `json:"features"`
}
package channelsinfra

import (
	"context"
	"database/sql"
	"fmt"
	"strings"

	"github.com/Abraxas-365/craftable/errx"
	"github.com/Abraxas-365/craftable/storex"
	"github.com/Abraxas-365/relay/channels"
	"github.com/Abraxas-365/relay/pkg/kernel"
	"github.com/jmoiron/sqlx"
	"github.com/lib/pq"
)

type PostgresChannelRepository struct {
	db *sqlx.DB
}

var _ channels.ChannelRepository = (*PostgresChannelRepository)(nil)

func NewPostgresChannelRepository(db *sqlx.DB) *PostgresChannelRepository {
	return &PostgresChannelRepository{db: db}
}

func (r *PostgresChannelRepository) Save(ctx context.Context, channel channels.Channel) error {
	exists, err := r.channelExists(ctx, channel.ID, channel.TenantID)
	if err != nil {
		return errx.Wrap(err, "failed to check channel existence", errx.TypeInternal)
	}

	if exists {
		return r.update(ctx, channel)
	}
	return r.create(ctx, channel)
}

func (r *PostgresChannelRepository) create(ctx context.Context, channel channels.Channel) error {
	query := `
		INSERT INTO channels (
			id, tenant_id, type, name, description, config, 
			is_active, webhook_url, created_at, updated_at
		) VALUES (
			:id, :tenant_id, :type, :name, :description, :config,
			:is_active, :webhook_url, :created_at, :updated_at
		)`

	_, err := r.db.NamedExecContext(ctx, query, channel)
	if err != nil {
		if pqErr, ok := err.(*pq.Error); ok {
			if pqErr.Code == "23505" && pqErr.Constraint == "channels_name_tenant_id_key" {
				return channels.ErrChannelAlreadyExists().
					WithDetail("name", channel.Name).
					WithDetail("tenant_id", channel.TenantID.String())
			}
		}
		return errx.Wrap(err, "failed to create channel", errx.TypeInternal).
			WithDetail("channel_id", channel.ID.String())
	}

	return nil
}

func (r *PostgresChannelRepository) update(ctx context.Context, channel channels.Channel) error {
	query := `
		UPDATE channels SET
			type = :type,
			name = :name,
			description = :description,
			config = :config,
			is_active = :is_active,
			webhook_url = :webhook_url,
			updated_at = :updated_at
		WHERE id = :id AND tenant_id = :tenant_id`

	result, err := r.db.NamedExecContext(ctx, query, channel)
	if err != nil {
		if pqErr, ok := err.(*pq.Error); ok {
			if pqErr.Code == "23505" {
				return channels.ErrChannelAlreadyExists().WithDetail("name", channel.Name)
			}
		}
		return errx.Wrap(err, "failed to update channel", errx.TypeInternal).
			WithDetail("channel_id", channel.ID.String())
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return errx.Wrap(err, "failed to get rows affected", errx.TypeInternal)
	}

	if rowsAffected == 0 {
		return channels.ErrChannelNotFound().WithDetail("channel_id", channel.ID.String())
	}

	return nil
}

func (r *PostgresChannelRepository) FindByID(ctx context.Context, id kernel.ChannelID, tenantID kernel.TenantID) (*channels.Channel, error) {
	query := `
		SELECT 
			id, tenant_id, type, name, description, config,
			is_active, webhook_url, created_at, updated_at
		FROM channels
		WHERE id = $1 AND tenant_id = $2`

	var channel channels.Channel
	err := r.db.GetContext(ctx, &channel, query, id.String(), tenantID.String())
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, channels.ErrChannelNotFound().WithDetail("channel_id", id.String())
		}
		return nil, errx.Wrap(err, "failed to find channel by id", errx.TypeInternal).
			WithDetail("channel_id", id.String())
	}

	return &channel, nil
}

func (r *PostgresChannelRepository) FindByName(ctx context.Context, name string, tenantID kernel.TenantID) (*channels.Channel, error) {
	query := `
		SELECT 
			id, tenant_id, type, name, description, config,
			is_active, webhook_url, created_at, updated_at
		FROM channels
		WHERE name = $1 AND tenant_id = $2`

	var channel channels.Channel
	err := r.db.GetContext(ctx, &channel, query, name, tenantID.String())
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, channels.ErrChannelNotFound().WithDetail("name", name)
		}
		return nil, errx.Wrap(err, "failed to find channel by name", errx.TypeInternal).
			WithDetail("name", name)
	}

	return &channel, nil
}

func (r *PostgresChannelRepository) Delete(ctx context.Context, id kernel.ChannelID, tenantID kernel.TenantID) error {
	query := `DELETE FROM channels WHERE id = $1 AND tenant_id = $2`

	result, err := r.db.ExecContext(ctx, query, id.String(), tenantID.String())
	if err != nil {
		return errx.Wrap(err, "failed to delete channel", errx.TypeInternal).
			WithDetail("channel_id", id.String())
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return errx.Wrap(err, "failed to get rows affected", errx.TypeInternal)
	}

	if rowsAffected == 0 {
		return channels.ErrChannelNotFound().WithDetail("channel_id", id.String())
	}

	return nil
}

func (r *PostgresChannelRepository) ExistsByName(ctx context.Context, name string, tenantID kernel.TenantID) (bool, error) {
	query := `SELECT EXISTS(SELECT 1 FROM channels WHERE name = $1 AND tenant_id = $2)`

	var exists bool
	err := r.db.GetContext(ctx, &exists, query, name, tenantID.String())
	if err != nil {
		return false, errx.Wrap(err, "failed to check channel existence by name", errx.TypeInternal).
			WithDetail("name", name)
	}

	return exists, nil
}

func (r *PostgresChannelRepository) FindByTenant(ctx context.Context, tenantID kernel.TenantID) ([]*channels.Channel, error) {
	query := `
		SELECT 
			id, tenant_id, type, name, description, config,
			is_active, webhook_url, created_at, updated_at
		FROM channels
		WHERE tenant_id = $1
		ORDER BY name ASC`

	var channelList []channels.Channel
	err := r.db.SelectContext(ctx, &channelList, query, tenantID.String())
	if err != nil {
		return nil, errx.Wrap(err, "failed to find channels by tenant", errx.TypeInternal).
			WithDetail("tenant_id", tenantID.String())
	}

	result := make([]*channels.Channel, len(channelList))
	for i := range channelList {
		result[i] = &channelList[i]
	}

	return result, nil
}

func (r *PostgresChannelRepository) FindByType(ctx context.Context, channelType channels.ChannelType, tenantID kernel.TenantID) ([]*channels.Channel, error) {
	query := `
		SELECT 
			id, tenant_id, type, name, description, config,
			is_active, webhook_url, created_at, updated_at
		FROM channels
		WHERE type = $1 AND tenant_id = $2
		ORDER BY name ASC`

	var channelList []channels.Channel
	err := r.db.SelectContext(ctx, &channelList, query, channelType, tenantID.String())
	if err != nil {
		return nil, errx.Wrap(err, "failed to find channels by type", errx.TypeInternal).
			WithDetail("type", string(channelType))
	}

	result := make([]*channels.Channel, len(channelList))
	for i := range channelList {
		result[i] = &channelList[i]
	}

	return result, nil
}

func (r *PostgresChannelRepository) FindActive(ctx context.Context, tenantID kernel.TenantID) ([]*channels.Channel, error) {
	query := `
		SELECT 
			id, tenant_id, type, name, description, config,
			is_active, webhook_url, created_at, updated_at
		FROM channels
		WHERE tenant_id = $1 AND is_active = true
		ORDER BY name ASC`

	var channelList []channels.Channel
	err := r.db.SelectContext(ctx, &channelList, query, tenantID.String())
	if err != nil {
		return nil, errx.Wrap(err, "failed to find active channels", errx.TypeInternal)
	}

	result := make([]*channels.Channel, len(channelList))
	for i := range channelList {
		result[i] = &channelList[i]
	}

	return result, nil
}

func (r *PostgresChannelRepository) FindByProvider(ctx context.Context, provider string, tenantID kernel.TenantID) ([]*channels.Channel, error) {
	query := `
		SELECT 
			id, tenant_id, type, name, description, config,
			is_active, webhook_url, created_at, updated_at
		FROM channels
		WHERE tenant_id = $1 AND config->>'provider' = $2
		ORDER BY name ASC`

	var channelList []channels.Channel
	err := r.db.SelectContext(ctx, &channelList, query, tenantID.String(), provider)
	if err != nil {
		return nil, errx.Wrap(err, "failed to find channels by provider", errx.TypeInternal).
			WithDetail("provider", provider)
	}

	result := make([]*channels.Channel, len(channelList))
	for i := range channelList {
		result[i] = &channelList[i]
	}

	return result, nil
}

func (r *PostgresChannelRepository) List(ctx context.Context, req channels.ListChannelsRequest) (channels.ChannelListResponse, error) {
	// Build WHERE conditions
	var conditions []string
	var args []any
	argPos := 1

	conditions = append(conditions, fmt.Sprintf("tenant_id = $%d", argPos))
	args = append(args, req.TenantID.String())
	argPos++

	if req.Type != nil {
		conditions = append(conditions, fmt.Sprintf("type = $%d", argPos))
		args = append(args, *req.Type)
		argPos++
	}

	if req.IsActive != nil {
		conditions = append(conditions, fmt.Sprintf("is_active = $%d", argPos))
		args = append(args, *req.IsActive)
		argPos++
	}

	if req.Provider != nil {
		conditions = append(conditions, fmt.Sprintf("config->>'provider' = $%d", argPos))
		args = append(args, *req.Provider)
		argPos++
	}

	if req.Search != "" {
		conditions = append(conditions, fmt.Sprintf("(name ILIKE $%d OR description ILIKE $%d)", argPos, argPos+1))
		searchPattern := "%" + req.Search + "%"
		args = append(args, searchPattern, searchPattern)
		argPos += 2
	}

	whereClause := strings.Join(conditions, " AND ")

	// Count query
	countQuery := fmt.Sprintf("SELECT COUNT(*) FROM channels WHERE %s", whereClause)
	var total int
	err := r.db.GetContext(ctx, &total, countQuery, args...)
	if err != nil {
		return channels.ChannelListResponse{}, errx.Wrap(err, "failed to count channels", errx.TypeInternal)
	}

	// Data query with pagination
	dataQuery := fmt.Sprintf(`
		SELECT 
			id, tenant_id, type, name, description, config,
			is_active, webhook_url, created_at, updated_at
		FROM channels
		WHERE %s
		ORDER BY name ASC
		LIMIT $%d OFFSET $%d`,
		whereClause, argPos, argPos+1)

	args = append(args, req.PageSize, req.GetOffset())

	var channelList []channels.Channel
	err = r.db.SelectContext(ctx, &channelList, dataQuery, args...)
	if err != nil {
		return channels.ChannelListResponse{}, errx.Wrap(err, "failed to list channels", errx.TypeInternal)
	}

	return storex.NewPaginated(channelList, total, req.Page, req.PageSize), nil
}

func (r *PostgresChannelRepository) BulkUpdateStatus(ctx context.Context, ids []kernel.ChannelID, tenantID kernel.TenantID, isActive bool) error {
	if len(ids) == 0 {
		return nil
	}

	idStrings := make([]string, len(ids))
	for i, id := range ids {
		idStrings[i] = id.String()
	}

	query := `
		UPDATE channels 
		SET is_active = $1, updated_at = NOW()
		WHERE tenant_id = $2 AND id = ANY($3)`

	_, err := r.db.ExecContext(ctx, query, isActive, tenantID.String(), pq.Array(idStrings))
	if err != nil {
		return errx.Wrap(err, "failed to bulk update channel status", errx.TypeInternal)
	}

	return nil
}

func (r *PostgresChannelRepository) CountByType(ctx context.Context, channelType channels.ChannelType, tenantID kernel.TenantID) (int, error) {
	query := `SELECT COUNT(*) FROM channels WHERE type = $1 AND tenant_id = $2`

	var count int
	err := r.db.GetContext(ctx, &count, query, channelType, tenantID.String())
	if err != nil {
		return 0, errx.Wrap(err, "failed to count channels by type", errx.TypeInternal)
	}

	return count, nil
}

func (r *PostgresChannelRepository) CountByTenant(ctx context.Context, tenantID kernel.TenantID) (int, error) {
	query := `SELECT COUNT(*) FROM channels WHERE tenant_id = $1`

	var count int
	err := r.db.GetContext(ctx, &count, query, tenantID.String())
	if err != nil {
		return 0, errx.Wrap(err, "failed to count channels by tenant", errx.TypeInternal)
	}

	return count, nil
}

func (r *PostgresChannelRepository) channelExists(ctx context.Context, id kernel.ChannelID, tenantID kernel.TenantID) (bool, error) {
	query := `SELECT EXISTS(SELECT 1 FROM channels WHERE id = $1 AND tenant_id = $2)`

	var exists bool
	err := r.db.GetContext(ctx, &exists, query, id.String(), tenantID.String())
	if err != nil {
		return false, errx.Wrap(err, "failed to check channel existence", errx.TypeInternal)
	}

	return exists, nil
}
package channels

import (
	"net/http"

	"github.com/Abraxas-365/craftable/errx"
)

// ============================================================================
// Error Registry
// ============================================================================

var ErrRegistry = errx.NewRegistry("CHANNEL")

// ============================================================================
// Error Codes
// ============================================================================

var (
	// Channel errors
	CodeChannelNotFound      = ErrRegistry.Register("NOT_FOUND", errx.TypeNotFound, http.StatusNotFound, "Canal no encontrado")
	CodeChannelAlreadyExists = ErrRegistry.Register("ALREADY_EXISTS", errx.TypeConflict, http.StatusConflict, "Canal ya existe")
	CodeInvalidChannelType   = ErrRegistry.Register("INVALID_TYPE", errx.TypeValidation, http.StatusBadRequest, "Tipo de canal inválido")
	CodeInvalidChannelConfig = ErrRegistry.Register("INVALID_CONFIG", errx.TypeValidation, http.StatusBadRequest, "Configuración de canal inválida")
	CodeChannelInactive      = ErrRegistry.Register("CHANNEL_INACTIVE", errx.TypeBusiness, http.StatusForbidden, "Canal está inactivo")
	CodeChannelNotSupported  = ErrRegistry.Register("NOT_SUPPORTED", errx.TypeValidation, http.StatusBadRequest, "Tipo de canal no soportado")

	// Message sending errors
	CodeMessageSendFailed    = ErrRegistry.Register("MESSAGE_SEND_FAILED", errx.TypeExternal, http.StatusBadGateway, "Envío de mensaje falló")
	CodeInvalidRecipient     = ErrRegistry.Register("INVALID_RECIPIENT", errx.TypeValidation, http.StatusBadRequest, "Destinatario inválido")
	CodeInvalidMessageFormat = ErrRegistry.Register("INVALID_MESSAGE_FORMAT", errx.TypeValidation, http.StatusBadRequest, "Formato de mensaje inválido")
	CodeAttachmentTooLarge   = ErrRegistry.Register("ATTACHMENT_TOO_LARGE", errx.TypeValidation, http.StatusRequestEntityTooLarge, "Archivo adjunto muy grande")
	CodeUnsupportedMediaType = ErrRegistry.Register("UNSUPPORTED_MEDIA_TYPE", errx.TypeValidation, http.StatusUnsupportedMediaType, "Tipo de medio no soportado")

	// Provider errors
	CodeProviderNotConfigured = ErrRegistry.Register("PROVIDER_NOT_CONFIGURED", errx.TypeValidation, http.StatusBadRequest, "Proveedor no configurado")
	CodeProviderAuthFailed    = ErrRegistry.Register("PROVIDER_AUTH_FAILED", errx.TypeExternal, http.StatusUnauthorized, "Autenticación con proveedor falló")
	CodeProviderAPIError      = ErrRegistry.Register("PROVIDER_API_ERROR", errx.TypeExternal, http.StatusBadGateway, "Error en API del proveedor")
	CodeProviderRateLimited   = ErrRegistry.Register("PROVIDER_RATE_LIMITED", errx.TypeExternal, http.StatusTooManyRequests, "Proveedor limitó la tasa de requests")

	// Webhook errors
	CodeInvalidWebhookSignature = ErrRegistry.Register("INVALID_WEBHOOK_SIGNATURE", errx.TypeValidation, http.StatusUnauthorized, "Firma de webhook inválida")
	CodeWebhookProcessingFailed = ErrRegistry.Register("WEBHOOK_PROCESSING_FAILED", errx.TypeInternal, http.StatusInternalServerError, "Procesamiento de webhook falló")

	// Feature errors
	CodeFeatureNotSupported = ErrRegistry.Register("FEATURE_NOT_SUPPORTED", errx.TypeBusiness, http.StatusNotImplemented, "Característica no soportada por el canal")
)

// ============================================================================
// Error Constructor Functions
// ============================================================================

// Channel errors
func ErrChannelNotFound() *errx.Error {
	return ErrRegistry.New(CodeChannelNotFound)
}

func ErrChannelAlreadyExists() *errx.Error {
	return ErrRegistry.New(CodeChannelAlreadyExists)
}

func ErrInvalidChannelType() *errx.Error {
	return ErrRegistry.New(CodeInvalidChannelType)
}

func ErrInvalidChannelConfig() *errx.Error {
	return ErrRegistry.New(CodeInvalidChannelConfig)
}

func ErrChannelInactive() *errx.Error {
	return ErrRegistry.New(CodeChannelInactive)
}

func ErrChannelNotSupported() *errx.Error {
	return ErrRegistry.New(CodeChannelNotSupported)
}

// Message sending errors
func ErrMessageSendFailed() *errx.Error {
	return ErrRegistry.New(CodeMessageSendFailed)
}

func ErrInvalidRecipient() *errx.Error {
	return ErrRegistry.New(CodeInvalidRecipient)
}

func ErrInvalidMessageFormat() *errx.Error {
	return ErrRegistry.New(CodeInvalidMessageFormat)
}

func ErrAttachmentTooLarge() *errx.Error {
	return ErrRegistry.New(CodeAttachmentTooLarge)
}

func ErrUnsupportedMediaType() *errx.Error {
	return ErrRegistry.New(CodeUnsupportedMediaType)
}

// Provider errors
func ErrProviderNotConfigured() *errx.Error {
	return ErrRegistry.New(CodeProviderNotConfigured)
}

func ErrProviderAuthFailed() *errx.Error {
	return ErrRegistry.New(CodeProviderAuthFailed)
}

func ErrProviderAPIError() *errx.Error {
	return ErrRegistry.New(CodeProviderAPIError)
}

func ErrProviderRateLimited() *errx.Error {
	return ErrRegistry.New(CodeProviderRateLimited)
}

// Webhook errors
func ErrInvalidWebhookSignature() *errx.Error {
	return ErrRegistry.New(CodeInvalidWebhookSignature)
}

func ErrWebhookProcessingFailed() *errx.Error {
	return ErrRegistry.New(CodeWebhookProcessingFailed)
}

// Feature errors
func ErrFeatureNotSupported() *errx.Error {
	return ErrRegistry.New(CodeFeatureNotSupported)
}
