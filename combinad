package engine

import (
	"time"

	"github.com/Abraxas-365/relay/pkg/kernel"
)

// ============================================================================
// Message Entity
// ============================================================================

// Message representa un mensaje normalizado
type Message struct {
	ID        kernel.MessageID `db:"id" json:"id"`
	TenantID  kernel.TenantID  `db:"tenant_id" json:"tenant_id"`
	ChannelID kernel.ChannelID `db:"channel_id" json:"channel_id"`
	SenderID  string           `db:"sender_id" json:"sender_id"`
	Content   MessageContent   `db:"content" json:"content"`
	Context   map[string]any   `db:"context" json:"context"`
	Status    MessageStatus    `db:"status" json:"status"`
	CreatedAt time.Time        `db:"created_at" json:"created_at"`
	UpdatedAt time.Time        `db:"updated_at" json:"updated_at"`
}

// MessageContent contenido del mensaje
type MessageContent struct {
	Type        string         `json:"type"` // text, image, audio, video, document
	Text        string         `json:"text,omitempty"`
	Attachments []string       `json:"attachments,omitempty"`
	Metadata    map[string]any `json:"metadata,omitempty"`
}

// MessageStatus estado del mensaje
type MessageStatus string

const (
	MessageStatusPending    MessageStatus = "PENDING"
	MessageStatusProcessing MessageStatus = "PROCESSING"
	MessageStatusProcessed  MessageStatus = "PROCESSED"
	MessageStatusFailed     MessageStatus = "FAILED"
)

// ============================================================================
// Workflow Entity
// ============================================================================

// Workflow representa un flujo de trabajo
type Workflow struct {
	ID          kernel.WorkflowID `db:"id" json:"id"`
	TenantID    kernel.TenantID   `db:"tenant_id" json:"tenant_id"`
	Name        string            `db:"name" json:"name"`
	Description string            `db:"description" json:"description"`
	Trigger     WorkflowTrigger   `db:"trigger" json:"trigger"`
	Steps       []WorkflowStep    `db:"steps" json:"steps"`
	IsActive    bool              `db:"is_active" json:"is_active"`
	CreatedAt   time.Time         `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time         `db:"updated_at" json:"updated_at"`
}

// WorkflowTrigger define cuándo se ejecuta el workflow
type WorkflowTrigger struct {
	Type       TriggerType    `json:"type"` // message_received, scheduled, webhook, manual
	ChannelIDs []string       `json:"channel_ids,omitempty"`
	Schedule   *string        `json:"schedule,omitempty"` // Cron expression
	Filters    map[string]any `json:"filters,omitempty"`  // Filtros adicionales
}

// TriggerType tipo de trigger
type TriggerType string

const (
	TriggerTypeMessageReceived TriggerType = "MESSAGE_RECEIVED"
	TriggerTypeScheduled       TriggerType = "SCHEDULED"
	TriggerTypeWebhook         TriggerType = "WEBHOOK"
	TriggerTypeManual          TriggerType = "MANUAL"
)

// WorkflowStep paso de un workflow
type WorkflowStep struct {
	ID        string         `json:"id"`
	Name      string         `json:"name"`
	Type      StepType       `json:"type"` // condition, parser, tool, action, delay
	Config    map[string]any `json:"config"`
	OnSuccess string         `json:"on_success,omitempty"` // next step ID
	OnFailure string         `json:"on_failure,omitempty"` // next step ID
	Timeout   *int           `json:"timeout,omitempty"`    // seconds
}

// StepType tipo de paso
type StepType string

const (
	StepTypeCondition StepType = "CONDITION"
	StepTypeParser    StepType = "PARSER"
	StepTypeTool      StepType = "TOOL"
	StepTypeAction    StepType = "ACTION"
	StepTypeDelay     StepType = "DELAY"
	StepTypeResponse  StepType = "RESPONSE"
)

// ============================================================================
// Session Entity
// ============================================================================

// Session representa contexto de conversación
type Session struct {
	ID             kernel.SessionID `db:"id" json:"id"`
	TenantID       kernel.TenantID  `db:"tenant_id" json:"tenant_id"`
	ChannelID      kernel.ChannelID `db:"channel_id" json:"channel_id"`
	SenderID       string           `db:"sender_id" json:"sender_id"`
	Context        map[string]any   `db:"context" json:"context"`
	History        []MessageRef     `db:"history" json:"history"` // Referencias a mensajes
	CurrentState   string           `db:"current_state" json:"current_state"`
	ExpiresAt      time.Time        `db:"expires_at" json:"expires_at"`
	CreatedAt      time.Time        `db:"created_at" json:"created_at"`
	LastActivityAt time.Time        `db:"last_activity_at" json:"last_activity_at"`
}

// MessageRef referencia a un mensaje en el historial
type MessageRef struct {
	MessageID kernel.MessageID `json:"message_id"`
	Role      string           `json:"role"` // user, assistant, system
	Timestamp time.Time        `json:"timestamp"`
}

// ============================================================================
// Execution Result
// ============================================================================

// ExecutionResult resultado de la ejecución de un workflow
type ExecutionResult struct {
	Success       bool           `json:"success"`
	Response      string         `json:"response,omitempty"`
	ShouldRespond bool           `json:"should_respond"`
	NextState     string         `json:"next_state,omitempty"`
	Context       map[string]any `json:"context,omitempty"`
	Error         error          `json:"-"`
	ErrorMessage  string         `json:"error,omitempty"`
	ExecutedSteps []StepResult   `json:"executed_steps,omitempty"`
}

// StepResult resultado de un paso
type StepResult struct {
	StepID    string         `json:"step_id"`
	StepName  string         `json:"step_name"`
	Success   bool           `json:"success"`
	Output    map[string]any `json:"output,omitempty"`
	Error     string         `json:"error,omitempty"`
	Duration  int64          `json:"duration_ms"`
	Timestamp time.Time      `json:"timestamp"`
}

// ============================================================================
// Domain Methods - Message
// ============================================================================

// IsValid verifica si el mensaje es válido
func (m *Message) IsValid() bool {
	return !m.ID.IsEmpty() && !m.ChannelID.IsEmpty() && m.SenderID != ""
}

// MarkAsProcessing marca el mensaje como en procesamiento
func (m *Message) MarkAsProcessing() {
	m.Status = MessageStatusProcessing
	m.UpdatedAt = time.Now()
}

// MarkAsProcessed marca el mensaje como procesado
func (m *Message) MarkAsProcessed() {
	m.Status = MessageStatusProcessed
	m.UpdatedAt = time.Now()
}

// MarkAsFailed marca el mensaje como fallido
func (m *Message) MarkAsFailed() {
	m.Status = MessageStatusFailed
	m.UpdatedAt = time.Now()
}

// HasTextContent verifica si el mensaje tiene contenido de texto
func (m *Message) HasTextContent() bool {
	return m.Content.Type == "text" && m.Content.Text != ""
}

// HasAttachments verifica si el mensaje tiene adjuntos
func (m *Message) HasAttachments() bool {
	return len(m.Content.Attachments) > 0
}

// ============================================================================
// Domain Methods - Workflow
// ============================================================================

// IsValid verifica si el workflow es válido
func (w *Workflow) IsValid() bool {
	return w.Name != "" && len(w.Steps) > 0 && !w.TenantID.IsEmpty()
}

// Activate activa el workflow
func (w *Workflow) Activate() {
	w.IsActive = true
	w.UpdatedAt = time.Now()
}

// Deactivate desactiva el workflow
func (w *Workflow) Deactivate() {
	w.IsActive = false
	w.UpdatedAt = time.Now()
}

// UpdateDetails actualiza nombre y descripción
func (w *Workflow) UpdateDetails(name, description string) {
	if name != "" {
		w.Name = name
	}
	if description != "" {
		w.Description = description
	}
	w.UpdatedAt = time.Now()
}

// UpdateSteps actualiza los pasos del workflow
func (w *Workflow) UpdateSteps(steps []WorkflowStep) {
	w.Steps = steps
	w.UpdatedAt = time.Now()
}

// GetStepByID obtiene un paso por ID
func (w *Workflow) GetStepByID(stepID string) *WorkflowStep {
	for i := range w.Steps {
		if w.Steps[i].ID == stepID {
			return &w.Steps[i]
		}
	}
	return nil
}

// MatchesTrigger verifica si el workflow coincide con un trigger dado
func (w *Workflow) MatchesTrigger(trigger WorkflowTrigger) bool {
	if w.Trigger.Type != trigger.Type {
		return false
	}

	// Si tiene filtro de canales, verificar coincidencia
	if len(w.Trigger.ChannelIDs) > 0 && len(trigger.ChannelIDs) > 0 {
		for _, wChannelID := range w.Trigger.ChannelIDs {
			for _, tChannelID := range trigger.ChannelIDs {
				if wChannelID == tChannelID {
					return true
				}
			}
		}
		return false
	}

	return true
}

// ============================================================================
// Domain Methods - Session
// ============================================================================

// IsValid verifica si la sesión es válida
func (s *Session) IsValid() bool {
	return s.ID != "" && !s.ChannelID.IsEmpty() && s.SenderID != ""
}

// IsExpired verifica si la sesión ha expirado
func (s *Session) IsExpired() bool {
	return time.Now().After(s.ExpiresAt)
}

// UpdateActivity actualiza la última actividad
func (s *Session) UpdateActivity() {
	s.LastActivityAt = time.Now()
}

// AddMessage añade un mensaje al historial
func (s *Session) AddMessage(messageID kernel.MessageID, role string) {
	s.History = append(s.History, MessageRef{
		MessageID: messageID,
		Role:      role,
		Timestamp: time.Now(),
	})
	s.UpdateActivity()
}

// SetContext establece contexto
func (s *Session) SetContext(key string, value any) {
	if s.Context == nil {
		s.Context = make(map[string]any)
	}
	s.Context[key] = value
	s.UpdateActivity()
}

// GetContext obtiene un valor del contexto
func (s *Session) GetContext(key string) (any, bool) {
	if s.Context == nil {
		return nil, false
	}
	val, ok := s.Context[key]
	return val, ok
}

// UpdateState actualiza el estado actual
func (s *Session) UpdateState(state string) {
	s.CurrentState = state
	s.UpdateActivity()
}

// ExtendExpiration extiende la expiración de la sesión
func (s *Session) ExtendExpiration(duration time.Duration) {
	s.ExpiresAt = time.Now().Add(duration)
	s.UpdateActivity()
}

// GetHistoryCount retorna el número de mensajes en el historial
func (s *Session) GetHistoryCount() int {
	return len(s.History)
}
package engine

import (
	"context"

	"github.com/Abraxas-365/relay/pkg/kernel"
)

// ============================================================================
// Repository Interfaces
// ============================================================================

// MessageRepository persistencia de mensajes
type MessageRepository interface {
	// CRUD básico
	Save(ctx context.Context, msg Message) error
	FindByID(ctx context.Context, id kernel.MessageID) (*Message, error)
	Delete(ctx context.Context, id kernel.MessageID) error

	// Búsquedas
	FindByChannel(ctx context.Context, channelID kernel.ChannelID) ([]*Message, error)
	FindBySender(ctx context.Context, senderID string, tenantID kernel.TenantID) ([]*Message, error)
	FindByStatus(ctx context.Context, status MessageStatus, tenantID kernel.TenantID) ([]*Message, error)

	// List con paginación
	List(ctx context.Context, req MessageListRequest) (MessageListResponse, error)

	// Bulk operations
	BulkUpdateStatus(ctx context.Context, ids []kernel.MessageID, status MessageStatus) error

	// Stats
	CountByStatus(ctx context.Context, status MessageStatus, tenantID kernel.TenantID) (int, error)
	CountByChannel(ctx context.Context, channelID kernel.ChannelID) (int, error)
}

// WorkflowRepository persistencia de workflows
type WorkflowRepository interface {
	// CRUD básico
	Save(ctx context.Context, wf Workflow) error
	FindByID(ctx context.Context, id kernel.WorkflowID) (*Workflow, error)
	FindByName(ctx context.Context, name string, tenantID kernel.TenantID) (*Workflow, error)
	Delete(ctx context.Context, id kernel.WorkflowID, tenantID kernel.TenantID) error
	ExistsByName(ctx context.Context, name string, tenantID kernel.TenantID) (bool, error)

	// Búsquedas
	FindByTenant(ctx context.Context, tenantID kernel.TenantID) ([]*Workflow, error)
	FindActive(ctx context.Context, tenantID kernel.TenantID) ([]*Workflow, error)
	FindByTriggerType(ctx context.Context, triggerType TriggerType, tenantID kernel.TenantID) ([]*Workflow, error)
	FindActiveByTrigger(ctx context.Context, trigger WorkflowTrigger, tenantID kernel.TenantID) ([]*Workflow, error)

	// List con paginación
	List(ctx context.Context, req WorkflowListRequest) (WorkflowListResponse, error)

	// Bulk operations
	BulkUpdateStatus(ctx context.Context, ids []kernel.WorkflowID, tenantID kernel.TenantID, isActive bool) error
}

// SessionRepository persistencia de sesiones
type SessionRepository interface {
	// CRUD básico
	Save(ctx context.Context, session Session) error
	FindByID(ctx context.Context, id kernel.SessionID) (*Session, error)
	Delete(ctx context.Context, id kernel.SessionID) error

	// Búsquedas
	FindByChannelAndSender(ctx context.Context, channelID kernel.ChannelID, senderID string) (*Session, error)
	FindByChannel(ctx context.Context, channelID kernel.ChannelID) ([]*Session, error)
	FindActive(ctx context.Context, tenantID kernel.TenantID) ([]*Session, error)
	FindExpired(ctx context.Context) ([]*Session, error)

	// List con paginación
	List(ctx context.Context, req SessionListRequest) (SessionListResponse, error)

	// Mantenimiento
	CleanExpired(ctx context.Context) error
	ExtendExpiration(ctx context.Context, id kernel.SessionID, duration int64) error // duration en segundos

	// Stats
	CountActive(ctx context.Context, tenantID kernel.TenantID) (int, error)
}

// ============================================================================
// Manager Interfaces
// ============================================================================

// SessionManager manejo de sesiones con lógica de negocio
type SessionManager interface {
	// Obtener o crear sesión
	GetOrCreate(ctx context.Context, channelID kernel.ChannelID, senderID string, tenantID kernel.TenantID) (*Session, error)

	// Actualizar sesión
	Update(ctx context.Context, session Session) error
	UpdateContext(ctx context.Context, sessionID kernel.SessionID, key string, value any) error
	UpdateState(ctx context.Context, sessionID kernel.SessionID, state string) error

	// Eliminar sesión
	Delete(ctx context.Context, sessionID kernel.SessionID) error

	// Obtener sesión
	Get(ctx context.Context, sessionID kernel.SessionID) (*Session, error)

	// Extender expiración
	ExtendSession(ctx context.Context, sessionID kernel.SessionID) error

	// Limpiar sesiones expiradas
	CleanExpiredSessions(ctx context.Context) error
}

// ============================================================================
// Executor Interfaces
// ============================================================================

// WorkflowExecutor ejecuta workflows
type WorkflowExecutor interface {
	// Ejecutar workflow completo
	Execute(ctx context.Context, workflow Workflow, message Message, session *Session) (*ExecutionResult, error)

	// Ejecutar paso específico
	ExecuteStep(ctx context.Context, step WorkflowStep, message Message, session *Session, stepContext map[string]any) (*StepResult, error)

	// Validar workflow
	ValidateWorkflow(ctx context.Context, workflow Workflow) error
}

// StepExecutor ejecuta pasos específicos de workflow
type StepExecutor interface {
	// Ejecutar paso
	Execute(ctx context.Context, step WorkflowStep, input map[string]any) (*StepResult, error)

	// Soporta el tipo de paso
	SupportsType(stepType StepType) bool

	// Validar configuración del paso
	ValidateConfig(config map[string]any) error
}

// ============================================================================
// Processor Interface
// ============================================================================

// MessageProcessor procesa mensajes entrantes
type MessageProcessor interface {
	// Procesar mensaje
	ProcessMessage(ctx context.Context, msg Message) error

	// Procesar mensaje con workflow específico
	ProcessWithWorkflow(ctx context.Context, msg Message, workflowID kernel.WorkflowID) error

	// Procesar respuesta
	ProcessResponse(ctx context.Context, msg Message, response string) error
}
package sessmanager

import (
	"context"
	"time"

	"github.com/Abraxas-365/craftable/errx"
	"github.com/Abraxas-365/relay/engine"
	"github.com/Abraxas-365/relay/pkg/kernel"
	"github.com/google/uuid"
)

// SessionManager implements SessionManager interface
type SessionManager struct {
	repo                  engine.SessionRepository
	defaultExpirationTime time.Duration // Default session expiration (e.g., 24 hours)
	maxHistorySize        int           // Maximum number of messages in history
}

// SessionManagerConfig configuration for session manager
type SessionManagerConfig struct {
	DefaultExpirationTime time.Duration // Default: 24 hours
	MaxHistorySize        int           // Default: 100 messages
}

// NewSessionManager creates a new session manager
func NewSessionManager(repo engine.SessionRepository, config *SessionManagerConfig) *SessionManager {
	if config == nil {
		config = &SessionManagerConfig{
			DefaultExpirationTime: 24 * time.Hour,
			MaxHistorySize:        100,
		}
	}

	// Set defaults if not provided
	if config.DefaultExpirationTime == 0 {
		config.DefaultExpirationTime = 24 * time.Hour
	}
	if config.MaxHistorySize == 0 {
		config.MaxHistorySize = 100
	}

	return &SessionManager{
		repo:                  repo,
		defaultExpirationTime: config.DefaultExpirationTime,
		maxHistorySize:        config.MaxHistorySize,
	}
}

// GetOrCreate obtains an existing session or creates a new one
func (m *SessionManager) GetOrCreate(ctx context.Context, channelID kernel.ChannelID, senderID string, tenantID kernel.TenantID) (*engine.Session, error) {
	// Try to find existing session
	session, err := m.repo.FindByChannelAndSender(ctx, channelID, senderID)
	if err == nil {
		// Session found - check if expired
		if session.IsExpired() {
			// Session expired, create a new one
			return m.createNewSession(ctx, channelID, senderID, tenantID)
		}

		// Session is valid, extend its activity
		session.UpdateActivity()
		if err := m.repo.Save(ctx, *session); err != nil {
			return nil, errx.Wrap(err, "failed to update session activity", errx.TypeInternal).
				WithDetail("session_id", session.ID)
		}

		return session, nil
	}

	// Check if error is "not found"
	if errx.IsType(err, errx.TypeNotFound) {
		// Session doesn't exist, create new one
		return m.createNewSession(ctx, channelID, senderID, tenantID)
	}

	// Some other error occurred
	return nil, errx.Wrap(err, "failed to find session", errx.TypeInternal)
}

// createNewSession creates and saves a new session
func (m *SessionManager) createNewSession(ctx context.Context, channelID kernel.ChannelID, senderID string, tenantID kernel.TenantID) (*engine.Session, error) {
	now := time.Now()

	session := &engine.Session{
		ID:             kernel.NewSessionID(uuid.New().String()),
		TenantID:       tenantID,
		ChannelID:      channelID,
		SenderID:       senderID,
		Context:        make(map[string]any),
		History:        []engine.MessageRef{},
		CurrentState:   "initial",
		ExpiresAt:      now.Add(m.defaultExpirationTime),
		CreatedAt:      now,
		LastActivityAt: now,
	}

	if err := m.repo.Save(ctx, *session); err != nil {
		return nil, errx.Wrap(err, "failed to create session", errx.TypeInternal).
			WithDetail("channel_id", channelID.String()).
			WithDetail("sender_id", senderID)
	}

	return session, nil
}

// Update updates the entire session
func (m *SessionManager) Update(ctx context.Context, session engine.Session) error {
	// Validate session
	if !session.IsValid() {
		return errx.New("invalid session", errx.TypeValidation).
			WithDetail("session_id", session.ID)
	}

	// Update activity timestamp
	session.UpdateActivity()

	// Trim history if too large
	if len(session.History) > m.maxHistorySize {
		session.History = session.History[len(session.History)-m.maxHistorySize:]
	}

	if err := m.repo.Save(ctx, session); err != nil {
		return errx.Wrap(err, "failed to update session", errx.TypeInternal).
			WithDetail("session_id", session.ID)
	}

	return nil
}

// UpdateContext updates a specific context key in the session
func (m *SessionManager) UpdateContext(ctx context.Context, sessionID kernel.SessionID, key string, value any) error {
	// Get current session
	session, err := m.repo.FindByID(ctx, sessionID)
	if err != nil {
		return errx.Wrap(err, "failed to find session", errx.TypeInternal).
			WithDetail("session_id", string(sessionID))
	}

	// Check if expired
	if session.IsExpired() {
		return errx.New("session expired", errx.TypeValidation).
			WithDetail("session_id", string(sessionID)).
			WithDetail("expires_at", session.ExpiresAt.String())
	}

	// Update context
	session.SetContext(key, value)

	// Save session
	if err := m.repo.Save(ctx, *session); err != nil {
		return errx.Wrap(err, "failed to update session context", errx.TypeInternal).
			WithDetail("session_id", string(sessionID)).
			WithDetail("context_key", key)
	}

	return nil
}

// UpdateState updates the current state of the session
func (m *SessionManager) UpdateState(ctx context.Context, sessionID kernel.SessionID, state string) error {
	// Get current session
	session, err := m.repo.FindByID(ctx, sessionID)
	if err != nil {
		return errx.Wrap(err, "failed to find session", errx.TypeInternal).
			WithDetail("session_id", string(sessionID))
	}

	// Check if expired
	if session.IsExpired() {
		return errx.New("session expired", errx.TypeValidation).
			WithDetail("session_id", string(sessionID)).
			WithDetail("expires_at", session.ExpiresAt.String())
	}

	// Update state
	session.UpdateState(state)

	// Save session
	if err := m.repo.Save(ctx, *session); err != nil {
		return errx.Wrap(err, "failed to update session state", errx.TypeInternal).
			WithDetail("session_id", string(sessionID)).
			WithDetail("state", state)
	}

	return nil
}

// Delete deletes a session
func (m *SessionManager) Delete(ctx context.Context, sessionID kernel.SessionID) error {
	if err := m.repo.Delete(ctx, sessionID); err != nil {
		return errx.Wrap(err, "failed to delete session", errx.TypeInternal).
			WithDetail("session_id", string(sessionID))
	}

	return nil
}

// Get retrieves a session by ID
func (m *SessionManager) Get(ctx context.Context, sessionID kernel.SessionID) (*engine.Session, error) {
	session, err := m.repo.FindByID(ctx, sessionID)
	if err != nil {
		return nil, errx.Wrap(err, "failed to get session", errx.TypeInternal).
			WithDetail("session_id", string(sessionID))
	}

	return session, nil
}

// ExtendSession extends the expiration time of a session
func (m *SessionManager) ExtendSession(ctx context.Context, sessionID kernel.SessionID) error {
	// Get current session
	session, err := m.repo.FindByID(ctx, sessionID)
	if err != nil {
		return errx.Wrap(err, "failed to find session", errx.TypeInternal).
			WithDetail("session_id", string(sessionID))
	}

	// Extend expiration
	session.ExtendExpiration(m.defaultExpirationTime)

	// Save session
	if err := m.repo.Save(ctx, *session); err != nil {
		return errx.Wrap(err, "failed to extend session", errx.TypeInternal).
			WithDetail("session_id", string(sessionID))
	}

	return nil
}

// CleanExpiredSessions removes all expired sessions
func (m *SessionManager) CleanExpiredSessions(ctx context.Context) error {
	if err := m.repo.CleanExpired(ctx); err != nil {
		return errx.Wrap(err, "failed to clean expired sessions", errx.TypeInternal)
	}

	return nil
}

// AddMessageToHistory adds a message reference to the session history
func (m *SessionManager) AddMessageToHistory(ctx context.Context, sessionID kernel.SessionID, messageID kernel.MessageID, role string) error {
	// Get current session
	session, err := m.repo.FindByID(ctx, sessionID)
	if err != nil {
		return errx.Wrap(err, "failed to find session", errx.TypeInternal).
			WithDetail("session_id", string(sessionID))
	}

	// Check if expired
	if session.IsExpired() {
		return errx.New("session expired", errx.TypeValidation).
			WithDetail("session_id", string(sessionID))
	}

	// Add message to history
	session.AddMessage(messageID, role)

	// Trim history if too large
	if len(session.History) > m.maxHistorySize {
		session.History = session.History[len(session.History)-m.maxHistorySize:]
	}

	// Save session
	if err := m.repo.Save(ctx, *session); err != nil {
		return errx.Wrap(err, "failed to add message to session history", errx.TypeInternal).
			WithDetail("session_id", string(sessionID)).
			WithDetail("message_id", messageID.String())
	}

	return nil
}

// GetContext retrieves a value from the session context
func (m *SessionManager) GetContext(ctx context.Context, sessionID kernel.SessionID, key string) (any, bool, error) {
	session, err := m.repo.FindByID(ctx, sessionID)
	if err != nil {
		return nil, false, errx.Wrap(err, "failed to find session", errx.TypeInternal).
			WithDetail("session_id", string(sessionID))
	}

	value, ok := session.GetContext(key)
	return value, ok, nil
}

// ClearContext clears all context variables from a session
func (m *SessionManager) ClearContext(ctx context.Context, sessionID kernel.SessionID) error {
	session, err := m.repo.FindByID(ctx, sessionID)
	if err != nil {
		return errx.Wrap(err, "failed to find session", errx.TypeInternal).
			WithDetail("session_id", string(sessionID))
	}

	// Clear context
	session.Context = make(map[string]any)
	session.UpdateActivity()

	// Save session
	if err := m.repo.Save(ctx, *session); err != nil {
		return errx.Wrap(err, "failed to clear session context", errx.TypeInternal).
			WithDetail("session_id", string(sessionID))
	}

	return nil
}

// ResetSession resets a session to its initial state while keeping the same ID
func (m *SessionManager) ResetSession(ctx context.Context, sessionID kernel.SessionID) error {
	session, err := m.repo.FindByID(ctx, sessionID)
	if err != nil {
		return errx.Wrap(err, "failed to find session", errx.TypeInternal).
			WithDetail("session_id", string(sessionID))
	}

	// Reset session
	now := time.Now()
	session.Context = make(map[string]any)
	session.History = []engine.MessageRef{}
	session.CurrentState = "initial"
	session.ExpiresAt = now.Add(m.defaultExpirationTime)
	session.LastActivityAt = now

	// Save session
	if err := m.repo.Save(ctx, *session); err != nil {
		return errx.Wrap(err, "failed to reset session", errx.TypeInternal).
			WithDetail("session_id", string(sessionID))
	}

	return nil
}

// GetHistoryCount returns the number of messages in the session history
func (m *SessionManager) GetHistoryCount(ctx context.Context, sessionID kernel.SessionID) (int, error) {
	session, err := m.repo.FindByID(ctx, sessionID)
	if err != nil {
		return 0, errx.Wrap(err, "failed to find session", errx.TypeInternal).
			WithDetail("session_id", string(sessionID))
	}

	return session.GetHistoryCount(), nil
}

// IsSessionActive checks if a session exists and is not expired
func (m *SessionManager) IsSessionActive(ctx context.Context, sessionID kernel.SessionID) (bool, error) {
	session, err := m.repo.FindByID(ctx, sessionID)
	if err != nil {
		if errx.IsType(err, errx.TypeNotFound) {
			return false, nil
		}
		return false, errx.Wrap(err, "failed to check session", errx.TypeInternal).
			WithDetail("session_id", string(sessionID))
	}

	return !session.IsExpired(), nil
}
package engine

import (
	"time"

	"github.com/Abraxas-365/craftable/storex"
	"github.com/Abraxas-365/relay/pkg/kernel"
)

// ============================================================================
// Message DTOs
// ============================================================================

// CreateMessageRequest request para crear un mensaje
type CreateMessageRequest struct {
	TenantID  kernel.TenantID  `json:"tenant_id" validate:"required"`
	ChannelID kernel.ChannelID `json:"channel_id" validate:"required"`
	SenderID  string           `json:"sender_id" validate:"required"`
	Content   MessageContent   `json:"content" validate:"required"`
	Context   map[string]any   `json:"context,omitempty"`
}

// MessageResponse respuesta con mensaje
type MessageResponse struct {
	Message Message `json:"message"`
}

// MessageListRequest request para listar mensajes
type MessageListRequest struct {
	storex.PaginationOptions

	TenantID  kernel.TenantID   `json:"tenant_id" validate:"required"`
	ChannelID *kernel.ChannelID `json:"channel_id,omitempty"`
	SenderID  *string           `json:"sender_id,omitempty"`
	Status    *MessageStatus    `json:"status,omitempty"`
	From      *string           `json:"from,omitempty"` // ISO 8601 date
	To        *string           `json:"to,omitempty"`   // ISO 8601 date
}

func (mlr MessageListRequest) GetOffset() int {
	page := mlr.Page
	size := mlr.PageSize
	return (page - 1) * size
}

// MessageListResponse lista paginada de mensajes
type MessageListResponse = storex.Paginated[Message]

// ============================================================================
// Workflow DTOs
// ============================================================================

// CreateWorkflowRequest request para crear un workflow
type CreateWorkflowRequest struct {
	TenantID kernel.TenantID `json:"tenant_id" validate:"required"`
	Name     string          `json:"name" validate:"required,min=2"`
	Trigger  WorkflowTrigger `json:"trigger" validate:"required"`
	Steps    []WorkflowStep  `json:"steps" validate:"required,min=1"`
}

// UpdateWorkflowRequest request para actualizar un workflow
type UpdateWorkflowRequest struct {
	Name     *string          `json:"name,omitempty"`
	Trigger  *WorkflowTrigger `json:"trigger,omitempty"`
	Steps    *[]WorkflowStep  `json:"steps,omitempty"`
	IsActive *bool            `json:"is_active,omitempty"`
}

// ExecuteWorkflowRequest request para ejecutar un workflow manualmente
type ExecuteWorkflowRequest struct {
	WorkflowID kernel.WorkflowID `json:"workflow_id" validate:"required"`
	MessageID  kernel.MessageID  `json:"message_id" validate:"required"`
	Context    map[string]any    `json:"context,omitempty"`
}

// WorkflowResponse respuesta con workflow
type WorkflowResponse struct {
	Workflow Workflow `json:"workflow"`
}

// WorkflowListRequest request para listar workflows
type WorkflowListRequest struct {
	storex.PaginationOptions

	TenantID kernel.TenantID `json:"tenant_id" validate:"required"`
	IsActive *bool           `json:"is_active,omitempty"`
	Search   string          `json:"search,omitempty"`
}

func (wlr WorkflowListRequest) GetOffset() int {
	page := wlr.Page
	size := wlr.PageSize
	return (page - 1) * size
}

// WorkflowListResponse lista paginada de workflows
type WorkflowListResponse = storex.Paginated[Workflow]

// WorkflowExecutionResponse respuesta de ejecución de workflow
type WorkflowExecutionResponse struct {
	WorkflowID    kernel.WorkflowID `json:"workflow_id"`
	MessageID     kernel.MessageID  `json:"message_id"`
	Success       bool              `json:"success"`
	Response      string            `json:"response,omitempty"`
	ShouldRespond bool              `json:"should_respond"`
	NextState     string            `json:"next_state,omitempty"`
	Context       map[string]any    `json:"context,omitempty"`
	Error         string            `json:"error,omitempty"`
}

// ============================================================================
// Session DTOs
// ============================================================================

// SessionResponse respuesta con sesión
type SessionResponse struct {
	Session Session `json:"session"`
}

// SessionListRequest request para listar sesiones
type SessionListRequest struct {
	storex.PaginationOptions

	IsActive     *bool             `json:"is_active,omitempty"`
	CurrentState *string           `json:"current_state,omitempty"`
	TenantID     kernel.TenantID   `json:"tenant_id" validate:"required"`
	ChannelID    *kernel.ChannelID `json:"channel_id,omitempty"`
	From         *time.Time        `json:"from,omitempty"`
	To           *time.Time        `json:"to,omitempty"`
	SenderID     *string           `json:"sender_id,omitempty"`
}

// SessionListResponse lista paginada de sesiones
type SessionListResponse = storex.Paginated[Session]

// UpdateSessionRequest request para actualizar sesión
type UpdateSessionRequest struct {
	Context      *map[string]any `json:"context,omitempty"`
	CurrentState *string         `json:"current_state,omitempty"`
}

// ============================================================================
// Stats DTOs
// ============================================================================

// MessageStatsResponse estadísticas de mensajes
type MessageStatsResponse struct {
	TenantID         kernel.TenantID         `json:"tenant_id"`
	Period           string                  `json:"period"` // day, week, month
	TotalMessages    int                     `json:"total_messages"`
	ProcessedCount   int                     `json:"processed_count"`
	FailedCount      int                     `json:"failed_count"`
	AvgProcessTime   float64                 `json:"avg_process_time_ms"`
	ChannelBreakdown []ChannelStatsBreakdown `json:"channel_breakdown"`
}

type ChannelStatsBreakdown struct {
	ChannelID      kernel.ChannelID `json:"channel_id"`
	ChannelName    string           `json:"channel_name"`
	MessageCount   int              `json:"message_count"`
	ProcessingRate float64          `json:"processing_rate"`
}

// WorkflowStatsResponse estadísticas de workflows
type WorkflowStatsResponse struct {
	WorkflowID       kernel.WorkflowID `json:"workflow_id"`
	WorkflowName     string            `json:"workflow_name"`
	TotalExecutions  int               `json:"total_executions"`
	SuccessCount     int               `json:"success_count"`
	FailureCount     int               `json:"failure_count"`
	AvgExecutionTime float64           `json:"avg_execution_time_ms"`
	LastExecutedAt   *string           `json:"last_executed_at,omitempty"`
}

// SessionStatsResponse estadísticas de sesiones
type SessionStatsResponse struct {
	TenantID       kernel.TenantID `json:"tenant_id"`
	ActiveSessions int             `json:"active_sessions"`
	TotalSessions  int             `json:"total_sessions"`
	AvgDuration    float64         `json:"avg_duration_minutes"`
}

// ============================================================================
// Bulk Operation DTOs
// ============================================================================

// BulkWorkflowOperationRequest request para operaciones masivas
type BulkWorkflowOperationRequest struct {
	TenantID    kernel.TenantID     `json:"tenant_id" validate:"required"`
	WorkflowIDs []kernel.WorkflowID `json:"workflow_ids" validate:"required,min=1"`
	Operation   string              `json:"operation" validate:"required,oneof=activate deactivate delete"`
}

// BulkWorkflowOperationResponse respuesta de operación masiva
type BulkWorkflowOperationResponse struct {
	Successful []kernel.WorkflowID          `json:"successful"`
	Failed     map[kernel.WorkflowID]string `json:"failed"`
	Total      int                          `json:"total"`
}

// ============================================================================
// Validation DTOs
// ============================================================================

// ValidateWorkflowRequest request para validar un workflow
type ValidateWorkflowRequest struct {
	Trigger WorkflowTrigger `json:"trigger" validate:"required"`
	Steps   []WorkflowStep  `json:"steps" validate:"required,min=1"`
}

// ValidateWorkflowResponse respuesta de validación
type ValidateWorkflowResponse struct {
	IsValid  bool     `json:"is_valid"`
	Errors   []string `json:"errors,omitempty"`
	Warnings []string `json:"warnings,omitempty"`
}

// ============================================================================
// Simple DTOs
// ============================================================================

// MessageDetailsDTO DTO simplificado de mensaje
type MessageDetailsDTO struct {
	ID        kernel.MessageID `json:"id"`
	ChannelID kernel.ChannelID `json:"channel_id"`
	SenderID  string           `json:"sender_id"`
	Content   MessageContent   `json:"content"`
	Status    MessageStatus    `json:"status"`
	CreatedAt string           `json:"created_at"`
}

// ToDTO convierte Message a MessageDetailsDTO
func (m *Message) ToDTO() MessageDetailsDTO {
	return MessageDetailsDTO{
		ID:        m.ID,
		ChannelID: m.ChannelID,
		SenderID:  m.SenderID,
		Content:   m.Content,
		Status:    m.Status,
		CreatedAt: m.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
	}
}

// WorkflowDetailsDTO DTO simplificado de workflow
type WorkflowDetailsDTO struct {
	ID        kernel.WorkflowID `json:"id"`
	Name      string            `json:"name"`
	IsActive  bool              `json:"is_active"`
	StepCount int               `json:"step_count"`
}

// ToDTO convierte Workflow a WorkflowDetailsDTO
func (w *Workflow) ToDTO() WorkflowDetailsDTO {
	return WorkflowDetailsDTO{
		ID:        w.ID,
		Name:      w.Name,
		IsActive:  w.IsActive,
		StepCount: len(w.Steps),
	}
}

// GetOffset returns the offset for pagination
func (r SessionListRequest) GetOffset() int {
	return (r.Page - 1) * r.PageSize
}
package stepexec

import (
	"context"
	"log"
	"time"

	"github.com/Abraxas-365/craftable/errx"
	"github.com/Abraxas-365/relay/engine"
)

// DelayExecutor ejecuta delays
type DelayExecutor struct{}

var _ engine.StepExecutor = (*DelayExecutor)(nil)

func NewDelayExecutor() *DelayExecutor {
	return &DelayExecutor{}
}

func (de *DelayExecutor) Execute(ctx context.Context, step engine.WorkflowStep, input map[string]any) (*engine.StepResult, error) {
	startTime := time.Now()

	result := &engine.StepResult{
		StepID:    step.ID,
		StepName:  step.Name,
		Timestamp: startTime,
		Output:    make(map[string]any),
	}

	durationMs, ok := step.Config["duration_ms"].(float64)
	if !ok {
		if durationInt, ok := step.Config["duration_ms"].(int); ok {
			durationMs = float64(durationInt)
		} else {
			result.Success = false
			result.Error = "missing or invalid duration_ms"
			result.Duration = time.Since(startTime).Milliseconds()
			return result, errx.New("missing duration_ms", errx.TypeValidation)
		}
	}

	duration := time.Duration(durationMs) * time.Millisecond
	log.Printf("⏱️  Delaying for %v", duration)

	select {
	case <-time.After(duration):
		result.Success = true
		result.Output["delayed_ms"] = durationMs
		result.Duration = time.Since(startTime).Milliseconds()
		return result, nil
	case <-ctx.Done():
		result.Success = false
		result.Error = "delay cancelled"
		result.Duration = time.Since(startTime).Milliseconds()
		return result, ctx.Err()
	}
}

func (de *DelayExecutor) SupportsType(stepType engine.StepType) bool {
	return stepType == engine.StepTypeDelay
}

func (de *DelayExecutor) ValidateConfig(config map[string]any) error {
	if _, ok := config["duration_ms"]; !ok {
		return errx.New("duration_ms is required for delay", errx.TypeValidation)
	}
	return nil
}
package stepexec

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/Abraxas-365/craftable/errx"
	"github.com/Abraxas-365/relay/engine"
)

// ResponseExecutor ejecuta pasos de respuesta
type ResponseExecutor struct{}

var _ engine.StepExecutor = (*ResponseExecutor)(nil)

func NewResponseExecutor() *ResponseExecutor {
	return &ResponseExecutor{}
}

func (re *ResponseExecutor) Execute(ctx context.Context, step engine.WorkflowStep, input map[string]any) (*engine.StepResult, error) {
	startTime := time.Now()

	result := &engine.StepResult{
		StepID:    step.ID,
		StepName:  step.Name,
		Timestamp: startTime,
		Output:    make(map[string]any),
	}

	responseText, ok := step.Config["text"].(string)
	if !ok {
		result.Success = false
		result.Error = "missing response text"
		result.Duration = time.Since(startTime).Milliseconds()
		return result, errx.New("missing text in response", errx.TypeValidation)
	}

	// Interpolar variables
	formattedResponse := re.interpolateVariables(responseText, input)

	result.Success = true
	result.Output["response"] = formattedResponse
	result.Output["should_respond"] = true
	result.Duration = time.Since(startTime).Milliseconds()

	return result, nil
}

func (re *ResponseExecutor) interpolateVariables(text string, variables map[string]any) string {
	result := text
	for key, value := range variables {
		placeholder := fmt.Sprintf("{{%s}}", key)
		result = strings.ReplaceAll(result, placeholder, fmt.Sprint(value))
	}
	return result
}

func (re *ResponseExecutor) SupportsType(stepType engine.StepType) bool {
	return stepType == engine.StepTypeResponse
}

func (re *ResponseExecutor) ValidateConfig(config map[string]any) error {
	if _, ok := config["text"].(string); !ok {
		return errx.New("text is required for response", errx.TypeValidation)
	}
	return nil
}
package stepexec

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/Abraxas-365/craftable/errx"
	"github.com/Abraxas-365/relay/engine"
)

// ConditionExecutor ejecuta condiciones
type ConditionExecutor struct{}

var _ engine.StepExecutor = (*ConditionExecutor)(nil)

func NewConditionExecutor() *ConditionExecutor {
	return &ConditionExecutor{}
}

func (ce *ConditionExecutor) Execute(ctx context.Context, step engine.WorkflowStep, input map[string]any) (*engine.StepResult, error) {
	startTime := time.Now()

	result := &engine.StepResult{
		StepID:    step.ID,
		StepName:  step.Name,
		Timestamp: startTime,
		Output:    make(map[string]any),
	}

	// Obtener configuración
	conditionType, ok := step.Config["condition_type"].(string)
	if !ok {
		result.Success = false
		result.Error = "missing condition_type"
		result.Duration = time.Since(startTime).Milliseconds()
		return result, errx.New("missing condition_type", errx.TypeValidation)
	}

	var conditionMet bool
	var err error

	switch conditionType {
	case "contains":
		conditionMet, err = ce.evaluateContains(step.Config, input)
	case "equals":
		conditionMet, err = ce.evaluateEquals(step.Config, input)
	case "exists":
		conditionMet, err = ce.evaluateExists(step.Config, input)
	case "regex":
		conditionMet, err = ce.evaluateRegex(step.Config, input)
	default:
		result.Success = false
		result.Error = fmt.Sprintf("unknown condition type: %s", conditionType)
		result.Duration = time.Since(startTime).Milliseconds()
		return result, errx.New("unknown condition type", errx.TypeValidation)
	}

	if err != nil {
		result.Success = false
		result.Error = err.Error()
		result.Duration = time.Since(startTime).Milliseconds()
		return result, err
	}

	result.Success = true
	result.Output["condition_met"] = conditionMet
	result.Duration = time.Since(startTime).Milliseconds()

	return result, nil
}

func (ce *ConditionExecutor) evaluateContains(config map[string]any, input map[string]any) (bool, error) {
	field, ok := config["field"].(string)
	if !ok {
		return false, errx.New("missing field", errx.TypeValidation)
	}

	value, ok := config["value"].(string)
	if !ok {
		return false, errx.New("missing value", errx.TypeValidation)
	}

	fieldValue, ok := input[field].(string)
	if !ok {
		return false, nil
	}

	caseInsensitive := config["case_insensitive"] == true
	if caseInsensitive {
		return strings.Contains(strings.ToLower(fieldValue), strings.ToLower(value)), nil
	}

	return strings.Contains(fieldValue, value), nil
}

func (ce *ConditionExecutor) evaluateEquals(config map[string]any, input map[string]any) (bool, error) {
	field, ok := config["field"].(string)
	if !ok {
		return false, errx.New("missing field", errx.TypeValidation)
	}

	expectedValue := config["value"]
	actualValue, exists := input[field]

	if !exists {
		return false, nil
	}

	return fmt.Sprint(actualValue) == fmt.Sprint(expectedValue), nil
}

func (ce *ConditionExecutor) evaluateExists(config map[string]any, input map[string]any) (bool, error) {
	field, ok := config["field"].(string)
	if !ok {
		return false, errx.New("missing field", errx.TypeValidation)
	}

	_, exists := input[field]
	return exists, nil
}

func (ce *ConditionExecutor) evaluateRegex(config map[string]any, input map[string]any) (bool, error) {
	// TODO: Implementar evaluación de regex
	return false, errx.New("regex evaluation not implemented", errx.TypeInternal)
}

func (ce *ConditionExecutor) SupportsType(stepType engine.StepType) bool {
	return stepType == engine.StepTypeCondition
}

func (ce *ConditionExecutor) ValidateConfig(config map[string]any) error {
	conditionType, ok := config["condition_type"].(string)
	if !ok {
		return errx.New("condition_type is required", errx.TypeValidation)
	}

	switch conditionType {
	case "contains", "equals", "exists":
		if _, ok := config["field"].(string); !ok {
			return errx.New("field is required", errx.TypeValidation)
		}
	case "regex":
		if _, ok := config["pattern"].(string); !ok {
			return errx.New("pattern is required for regex", errx.TypeValidation)
		}
	default:
		return errx.New("unknown condition type", errx.TypeValidation)
	}

	return nil
}
package stepexec

import (
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/Abraxas-365/craftable/errx"
	"github.com/Abraxas-365/relay/engine"
)

// ActionExecutor ejecuta acciones dentro de workflows
type ActionExecutor struct {
	// Puedes agregar dependencias aquí si necesitas
}

var _ engine.StepExecutor = (*ActionExecutor)(nil)

// NewActionExecutor crea una nueva instancia del ejecutor de acciones
func NewActionExecutor() *ActionExecutor {
	return &ActionExecutor{}
}

// Execute ejecuta una acción según su tipo
func (ae *ActionExecutor) Execute(ctx context.Context, step engine.WorkflowStep, input map[string]any) (*engine.StepResult, error) {
	startTime := time.Now()

	result := &engine.StepResult{
		StepID:    step.ID,
		StepName:  step.Name,
		Timestamp: startTime,
	}

	// Determinar tipo de acción desde config
	actionType, ok := step.Config["action_type"].(string)
	if !ok {
		result.Success = false
		result.Error = "missing action_type in config"
		result.Duration = time.Since(startTime).Milliseconds()
		return result, engine.ErrInvalidWorkflowStep().WithDetail("reason", "missing action_type")
	}

	// Ejecutar según tipo
	var err error
	switch actionType {
	case "console_log":
		err = ae.executeConsoleLog(ctx, step, input, result)
	case "set_context":
		err = ae.executeSetContext(ctx, step, input, result)
	case "delay":
		err = ae.executeDelay(ctx, step, input, result)
	case "response":
		err = ae.executeResponse(ctx, step, input, result)
	default:
		result.Success = false
		result.Error = fmt.Sprintf("unknown action type: %s", actionType)
		err = engine.ErrInvalidWorkflowStep().WithDetail("action_type", actionType)
	}

	result.Duration = time.Since(startTime).Milliseconds()
	return result, err
}

// executeConsoleLog imprime mensaje en consola
func (ae *ActionExecutor) executeConsoleLog(ctx context.Context, step engine.WorkflowStep, input map[string]any, result *engine.StepResult) error {
	message, ok := step.Config["message"].(string)
	if !ok {
		result.Success = false
		result.Error = "missing or invalid message"
		return errx.New("missing message in console_log action", errx.TypeValidation)
	}

	// Reemplazar variables del input en el mensaje
	formattedMessage := ae.interpolateVariables(message, input)

	// Imprimir en consola con formato
	log.Printf("🔹 [WORKFLOW ACTION] %s: %s", step.Name, formattedMessage)

	// También imprimir input si está configurado
	if printInput, ok := step.Config["print_input"].(bool); ok && printInput {
		log.Printf("   Input: %+v", input)
	}

	result.Success = true
	result.Output = map[string]any{
		"message":   formattedMessage,
		"logged_at": time.Now().Format(time.RFC3339),
	}
	return nil
}

// executeSetContext establece valores en el contexto
func (ae *ActionExecutor) executeSetContext(ctx context.Context, step engine.WorkflowStep, input map[string]any, result *engine.StepResult) error {
	contextData, ok := step.Config["context"].(map[string]any)
	if !ok {
		result.Success = false
		result.Error = "missing or invalid context data"
		return errx.New("missing context in set_context action", errx.TypeValidation)
	}

	// Interpolar variables
	interpolatedContext := make(map[string]any)
	for key, value := range contextData {
		if strVal, ok := value.(string); ok {
			interpolatedContext[key] = ae.interpolateVariables(strVal, input)
		} else {
			interpolatedContext[key] = value
		}
	}

	log.Printf("🔹 [WORKFLOW ACTION] %s: Setting context keys: %v", step.Name, getKeys(interpolatedContext))

	result.Success = true
	result.Output = map[string]any{
		"context": interpolatedContext,
	}
	return nil
}

// executeDelay espera un tiempo determinado
func (ae *ActionExecutor) executeDelay(ctx context.Context, step engine.WorkflowStep, input map[string]any, result *engine.StepResult) error {
	durationMs, ok := step.Config["duration_ms"].(float64)
	if !ok {
		// Intentar como int
		if durationInt, ok := step.Config["duration_ms"].(int); ok {
			durationMs = float64(durationInt)
		} else {
			result.Success = false
			result.Error = "missing or invalid duration_ms"
			return errx.New("missing duration_ms in delay action", errx.TypeValidation)
		}
	}

	duration := time.Duration(durationMs) * time.Millisecond
	log.Printf("🔹 [WORKFLOW ACTION] %s: Delaying for %v", step.Name, duration)

	select {
	case <-time.After(duration):
		log.Printf("   Delay completed")
	case <-ctx.Done():
		result.Success = false
		result.Error = "delay cancelled"
		return ctx.Err()
	}

	result.Success = true
	result.Output = map[string]any{
		"delayed_ms": durationMs,
	}
	return nil
}

// executeResponse genera una respuesta
func (ae *ActionExecutor) executeResponse(ctx context.Context, step engine.WorkflowStep, input map[string]any, result *engine.StepResult) error {
	responseText, ok := step.Config["text"].(string)
	if !ok {
		result.Success = false
		result.Error = "missing or invalid response text"
		return errx.New("missing text in response action", errx.TypeValidation)
	}

	// Interpolar variables
	formattedResponse := ae.interpolateVariables(responseText, input)

	log.Printf("🔹 [WORKFLOW ACTION] %s: Response prepared: %s", step.Name, formattedResponse)

	result.Success = true
	result.Output = map[string]any{
		"response":       formattedResponse,
		"should_respond": true,
	}
	return nil
}

// interpolateVariables reemplaza variables tipo {{variable}} en el texto
func (ae *ActionExecutor) interpolateVariables(text string, variables map[string]any) string {
	result := text
	for key, value := range variables {
		placeholder := fmt.Sprintf("{{%s}}", key)
		result = strings.ReplaceAll(result, placeholder, fmt.Sprint(value))
	}
	return result
}

// getKeys obtiene las llaves de un map
func getKeys(m map[string]any) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	return keys
}

// SupportsType verifica si soporta un tipo de paso
func (ae *ActionExecutor) SupportsType(stepType engine.StepType) bool {
	return stepType == engine.StepTypeAction
}

// ValidateConfig valida la configuración de una acción
func (ae *ActionExecutor) ValidateConfig(config map[string]any) error {
	actionType, ok := config["action_type"].(string)
	if !ok {
		return errx.New("action_type is required", errx.TypeValidation)
	}

	switch actionType {
	case "console_log":
		if _, ok := config["message"].(string); !ok {
			return errx.New("message is required for console_log", errx.TypeValidation)
		}
	case "set_context":
		if _, ok := config["context"].(map[string]any); !ok {
			return errx.New("context is required for set_context", errx.TypeValidation)
		}
	case "delay":
		if _, ok := config["duration_ms"]; !ok {
			return errx.New("duration_ms is required for delay", errx.TypeValidation)
		}
	case "response":
		if _, ok := config["text"].(string); !ok {
			return errx.New("text is required for response", errx.TypeValidation)
		}
	default:
		return errx.New("unknown action type", errx.TypeValidation).
			WithDetail("action_type", actionType)
	}

	return nil
}
package msgprocessor

import (
	"context"
	"log"
	"time"

	"github.com/Abraxas-365/craftable/errx"
	"github.com/Abraxas-365/relay/channels"
	"github.com/Abraxas-365/relay/engine"
	"github.com/Abraxas-365/relay/parser"
	"github.com/Abraxas-365/relay/pkg/kernel"
)

// MessageProcessor procesa mensajes entrantes
type MessageProcessor struct {
	messageRepo    engine.MessageRepository
	workflowRepo   engine.WorkflowRepository
	sessionManager engine.SessionManager
	workflowExec   engine.WorkflowExecutor
	channelManager channels.ChannelManager
	parserSelector parser.ParserSelector
}

// NewMessageProcessor crea una nueva instancia del procesador de mensajes
func NewMessageProcessor(
	messageRepo engine.MessageRepository,
	workflowRepo engine.WorkflowRepository,
	sessionManager engine.SessionManager,
	workflowExec engine.WorkflowExecutor,
	channelManager channels.ChannelManager,
	parserSelector parser.ParserSelector,
) *MessageProcessor {
	return &MessageProcessor{
		messageRepo:    messageRepo,
		workflowRepo:   workflowRepo,
		sessionManager: sessionManager,
		workflowExec:   workflowExec,
		channelManager: channelManager,
		parserSelector: parserSelector,
	}
}

// ProcessMessage es el entry point principal para procesar mensajes
func (mp *MessageProcessor) ProcessMessage(ctx context.Context, msg engine.Message) error {
	log.Printf("🚀 Processing message ID: %s from Sender: %s on Channel: %s", msg.ID.String(), msg.SenderID, msg.ChannelID.String())
	// 1. Validar mensaje
	if !msg.IsValid() {
		return engine.ErrMessageProcessingFailed().WithDetail("reason", "invalid message")
	}

	// 2. Marcar mensaje como en procesamiento
	msg.MarkAsProcessing()
	if err := mp.messageRepo.Save(ctx, msg); err != nil {
		return errx.Wrap(err, "failed to save message", errx.TypeInternal)
	}

	// 3. Obtener o crear sesión
	session, err := mp.sessionManager.GetOrCreate(ctx, msg.ChannelID, msg.SenderID, msg.TenantID)
	if err != nil {
		msg.MarkAsFailed()
		mp.messageRepo.Save(ctx, msg)
		return errx.Wrap(err, "failed to get or create session", errx.TypeInternal)
	}

	// 4. Añadir mensaje al historial de la sesión
	session.AddMessage(msg.ID, "user")

	// 5. Buscar workflow apropiado
	log.Printf("🔍 Searching for matching workflows for message: %s", msg.ID.String())
	workflows, err := mp.findMatchingWorkflows(ctx, msg)
	if err != nil {
		log.Printf("❌ Error finding workflows: %v", err)
		msg.MarkAsFailed()
		mp.messageRepo.Save(ctx, msg)
		return errx.Wrap(err, "failed to find workflows", errx.TypeInternal)
	}
	for _, wf := range workflows {
		// Log workflow IDs found
		log.Printf("🔍 Found matching workflow: %s for message: %s", wf.ID.String(), msg.ID.String())

	}

	// 6. Si no hay workflows, manejar con lógica por defecto
	if len(workflows) == 0 {
		return mp.handleNoWorkflow(ctx, msg, session)
	}

	// 7. Ejecutar el primer workflow que coincida (por prioridad)
	result, err := mp.executeWorkflowWithTimeout(ctx, workflows[0], msg, session)
	if err != nil {
		msg.MarkAsFailed()
		mp.messageRepo.Save(ctx, msg)
		return errx.Wrap(err, "failed to execute workflow", errx.TypeInternal)
	}

	// // 8. Actualizar sesión con el resultado
	if err := mp.updateSessionFromResult(ctx, session, result); err != nil {
		// Log error pero no fallar
		// logger.Error("Failed to update session", err)
	}

	// // 9. Enviar respuesta si es necesario
	if result.ShouldRespond && result.Response != "" {
		if err := mp.sendResponse(ctx, msg, result.Response); err != nil {
			// Log error pero marcar mensaje como procesado
			// logger.Error("Failed to send response", err)
		}
	}

	// 10. Marcar mensaje como procesado
	msg.MarkAsProcessed()
	return mp.messageRepo.Save(ctx, msg)
}

// ProcessWithWorkflow procesa un mensaje con un workflow específico
func (mp *MessageProcessor) ProcessWithWorkflow(ctx context.Context, msg engine.Message, workflowID kernel.WorkflowID) error {
	// 1. Validar mensaje
	if !msg.IsValid() {
		return engine.ErrMessageProcessingFailed().WithDetail("reason", "invalid message")
	}

	// 2. Buscar workflow específico
	workflow, err := mp.workflowRepo.FindByID(ctx, workflowID)
	if err != nil {
		return engine.ErrWorkflowNotFound().WithDetail("workflow_id", workflowID.String())
	}

	// 3. Verificar que el workflow esté activo
	if !workflow.IsActive {
		return engine.ErrWorkflowInactive().WithDetail("workflow_id", workflowID.String())
	}

	// 4. Verificar que pertenezca al mismo tenant
	if workflow.TenantID != msg.TenantID {
		return errx.New("workflow does not belong to message tenant", errx.TypeBusiness).
			WithDetail("workflow_tenant", workflow.TenantID.String()).
			WithDetail("message_tenant", msg.TenantID.String())
	}

	// 5. Marcar mensaje como en procesamiento
	msg.MarkAsProcessing()
	if err := mp.messageRepo.Save(ctx, msg); err != nil {
		return errx.Wrap(err, "failed to save message", errx.TypeInternal)
	}

	// 6. Obtener sesión
	session, err := mp.sessionManager.GetOrCreate(ctx, msg.ChannelID, msg.SenderID, msg.TenantID)
	if err != nil {
		msg.MarkAsFailed()
		mp.messageRepo.Save(ctx, msg)
		return errx.Wrap(err, "failed to get session", errx.TypeInternal)
	}

	// 7. Añadir mensaje al historial
	session.AddMessage(msg.ID, "user")

	// 8. Ejecutar workflow
	result, err := mp.executeWorkflowWithTimeout(ctx, workflow, msg, session)
	if err != nil {
		msg.MarkAsFailed()
		mp.messageRepo.Save(ctx, msg)
		return errx.Wrap(err, "failed to execute workflow", errx.TypeInternal)
	}

	// 9. Actualizar sesión
	if err := mp.updateSessionFromResult(ctx, session, result); err != nil {
		// Log error pero continuar
	}

	// 10. Enviar respuesta
	if result.ShouldRespond && result.Response != "" {
		if err := mp.sendResponse(ctx, msg, result.Response); err != nil {
			// Log error pero continuar
		}
	}

	// 11. Marcar como procesado
	msg.MarkAsProcessed()
	return mp.messageRepo.Save(ctx, msg)
}

// ProcessResponse procesa una respuesta y la envía
func (mp *MessageProcessor) ProcessResponse(ctx context.Context, msg engine.Message, response string) error {
	if response == "" {
		return nil
	}

	// Enviar respuesta
	return mp.sendResponse(ctx, msg, response)
}

// ============================================================================
// Helper Methods
// ============================================================================

// findMatchingWorkflows encuentra workflows que coincidan con el mensaje
func (mp *MessageProcessor) findMatchingWorkflows(ctx context.Context, msg engine.Message) ([]*engine.Workflow, error) {
	// Buscar workflows activos con trigger de mensaje recibido
	trigger := engine.WorkflowTrigger{
		Type:       engine.TriggerTypeMessageReceived,
		ChannelIDs: []string{msg.ChannelID.String()},
	}

	workflows, err := mp.workflowRepo.FindActiveByTrigger(ctx, trigger, msg.TenantID)
	if err != nil {
		log.Printf("❌ Error retrieving workflows from repository: %v", err)
		return nil, err
	}
	log.Printf("🔍 Retrieved %d workflows from repository for tenant: %s", len(workflows), msg.TenantID.String())

	// Filtrar workflows que realmente coincidan
	var matching []*engine.Workflow
	for _, wf := range workflows {
		log.Printf("🔍 Evaluating workflow: %s for message: %s", wf.ID.String(), msg.ID.String())
		if wf.MatchesTrigger(trigger) {
			matching = append(matching, wf)
		}
	}

	return matching, nil
}

// executeWorkflowWithTimeout ejecuta un workflow con timeout
func (mp *MessageProcessor) executeWorkflowWithTimeout(
	ctx context.Context,
	workflow *engine.Workflow,
	msg engine.Message,
	session *engine.Session,
) (*engine.ExecutionResult, error) {
	// Crear contexto con timeout (default 30 segundos)
	timeout := 30 * time.Second
	ctxWithTimeout, cancel := context.WithTimeout(ctx, timeout)
	defer cancel()

	// Canal para resultado
	resultChan := make(chan *engine.ExecutionResult, 1)
	errorChan := make(chan error, 1)

	// Ejecutar en goroutine
	go func() {
		result, err := mp.workflowExec.Execute(ctxWithTimeout, *workflow, msg, session)
		if err != nil {
			errorChan <- err
		} else {
			resultChan <- result
		}
	}()

	// Esperar resultado o timeout
	select {
	case result := <-resultChan:
		return result, nil
	case err := <-errorChan:
		return nil, err
	case <-ctxWithTimeout.Done():
		return nil, engine.ErrExecutionTimeout().
			WithDetail("workflow_id", workflow.ID.String()).
			WithDetail("timeout", timeout.String())
	}
}

// updateSessionFromResult actualiza la sesión con el resultado de la ejecución
func (mp *MessageProcessor) updateSessionFromResult(
	ctx context.Context,
	session *engine.Session,
	result *engine.ExecutionResult,
) error {
	// Actualizar contexto
	if result.Context != nil {
		for key, value := range result.Context {
			session.SetContext(key, value)
		}
	}

	// Actualizar estado
	if result.NextState != "" {
		session.UpdateState(result.NextState)
	}

	// Extender expiración de la sesión
	session.ExtendExpiration(30 * time.Minute)

	// Guardar sesión
	return mp.sessionManager.Update(ctx, *session)
}

// sendResponse envía una respuesta al canal
func (mp *MessageProcessor) sendResponse(ctx context.Context, msg engine.Message, response string) error {
	outgoingMsg := channels.OutgoingMessage{
		RecipientID: msg.SenderID,
		Content: channels.MessageContent{
			Type: "text",
			Text: response,
		},
		Metadata: map[string]any{
			"in_reply_to": msg.ID.String(),
			"timestamp":   time.Now().Unix(),
		},
	}

	return mp.channelManager.SendMessage(ctx, msg.ChannelID, outgoingMsg)
}

// handleNoWorkflow maneja mensajes cuando no hay workflow disponible
func (mp *MessageProcessor) handleNoWorkflow(ctx context.Context, msg engine.Message, session *engine.Session) error {
	// Intentar usar parser por defecto si está disponible
	if mp.parserSelector != nil {
		// Buscar parsers disponibles para el tenant
		// parsers, err := mp.parserRepo.FindByTenant(ctx, msg.TenantID)
		// if err == nil && len(parsers) > 0 {
		//     parser, err := mp.parserSelector.SelectParser(ctx, msg, parsers)
		//     if err == nil && parser != nil {
		//         // Ejecutar parser y responder
		//     }
		// }
	}

	// Respuesta por defecto
	defaultResponse := "Gracias por tu mensaje. En este momento no hay workflows configurados para procesarlo."

	if err := mp.sendResponse(ctx, msg, defaultResponse); err != nil {
		// Log error pero no fallar
		// logger.Error("Failed to send default response", err)
	}

	// Marcar mensaje como procesado
	msg.MarkAsProcessed()
	return mp.messageRepo.Save(ctx, msg)
}

// ============================================================================
// Additional Utility Methods
// ============================================================================

// GetMessageStatus obtiene el estado de un mensaje
func (mp *MessageProcessor) GetMessageStatus(ctx context.Context, messageID kernel.MessageID) (engine.MessageStatus, error) {
	msg, err := mp.messageRepo.FindByID(ctx, messageID)
	if err != nil {
		return "", engine.ErrMessageNotFound().WithDetail("message_id", messageID.String())
	}
	return msg.Status, nil
}

// RetryFailedMessage reintenta procesar un mensaje fallido
func (mp *MessageProcessor) RetryFailedMessage(ctx context.Context, messageID kernel.MessageID) error {
	msg, err := mp.messageRepo.FindByID(ctx, messageID)
	if err != nil {
		return engine.ErrMessageNotFound().WithDetail("message_id", messageID.String())
	}

	if msg.Status != engine.MessageStatusFailed {
		return errx.New("message is not in failed state", errx.TypeBusiness).
			WithDetail("current_status", string(msg.Status))
	}

	// Resetear estado y procesar de nuevo
	msg.Status = engine.MessageStatusPending
	return mp.ProcessMessage(ctx, *msg)
}

// GetProcessingStats obtiene estadísticas de procesamiento
func (mp *MessageProcessor) GetProcessingStats(ctx context.Context, tenantID kernel.TenantID) (*ProcessingStats, error) {
	pendingCount, _ := mp.messageRepo.CountByStatus(ctx, engine.MessageStatusPending, tenantID)
	processingCount, _ := mp.messageRepo.CountByStatus(ctx, engine.MessageStatusProcessing, tenantID)
	processedCount, _ := mp.messageRepo.CountByStatus(ctx, engine.MessageStatusProcessed, tenantID)
	failedCount, _ := mp.messageRepo.CountByStatus(ctx, engine.MessageStatusFailed, tenantID)

	return &ProcessingStats{
		TenantID:           tenantID,
		PendingMessages:    pendingCount,
		ProcessingMessages: processingCount,
		ProcessedMessages:  processedCount,
		FailedMessages:     failedCount,
		Timestamp:          time.Now(),
	}, nil
}

// ProcessingStats estadísticas de procesamiento
type ProcessingStats struct {
	TenantID           kernel.TenantID `json:"tenant_id"`
	PendingMessages    int             `json:"pending_messages"`
	ProcessingMessages int             `json:"processing_messages"`
	ProcessedMessages  int             `json:"processed_messages"`
	FailedMessages     int             `json:"failed_messages"`
	ActiveSessions     int             `json:"active_sessions"`
	Timestamp          time.Time       `json:"timestamp"`
}

// CleanupSessions limpia sesiones expiradas
func (mp *MessageProcessor) CleanupSessions(ctx context.Context) error {
	return mp.sessionManager.CleanExpiredSessions(ctx)
}

// BulkRetryFailedMessages reintenta procesar múltiples mensajes fallidos
func (mp *MessageProcessor) BulkRetryFailedMessages(ctx context.Context, tenantID kernel.TenantID, limit int) (*BulkRetryResult, error) {
	// Buscar mensajes fallidos
	failedMessages, err := mp.messageRepo.FindByStatus(ctx, engine.MessageStatusFailed, tenantID)
	if err != nil {
		return nil, err
	}

	// Limitar cantidad
	if limit > 0 && len(failedMessages) > limit {
		failedMessages = failedMessages[:limit]
	}

	result := &BulkRetryResult{
		Total:      len(failedMessages),
		Successful: []kernel.MessageID{},
		Failed:     make(map[kernel.MessageID]string),
	}

	// Reintentar cada mensaje
	for _, msg := range failedMessages {
		if err := mp.RetryFailedMessage(ctx, msg.ID); err != nil {
			result.Failed[msg.ID] = err.Error()
		} else {
			result.Successful = append(result.Successful, msg.ID)
		}
	}

	return result, nil
}

// BulkRetryResult resultado de reintento masivo
type BulkRetryResult struct {
	Total      int                         `json:"total"`
	Successful []kernel.MessageID          `json:"successful"`
	Failed     map[kernel.MessageID]string `json:"failed"`
}
package engine

import (
	"net/http"

	"github.com/Abraxas-365/craftable/errx"
)

// ============================================================================
// Error Registry
// ============================================================================

var ErrRegistry = errx.NewRegistry("ENGINE")

// ============================================================================
// Error Codes
// ============================================================================

var (
	// Message errors
	CodeMessageNotFound         = ErrRegistry.Register("MESSAGE_NOT_FOUND", errx.TypeNotFound, http.StatusNotFound, "Mensaje no encontrado")
	CodeMessageAlreadyExists    = ErrRegistry.Register("MESSAGE_ALREADY_EXISTS", errx.TypeConflict, http.StatusConflict, "Mensaje ya existe")
	CodeInvalidMessageStatus    = ErrRegistry.Register("INVALID_MESSAGE_STATUS", errx.TypeValidation, http.StatusBadRequest, "Estado de mensaje inválido")
	CodeMessageProcessingFailed = ErrRegistry.Register("MESSAGE_PROCESSING_FAILED", errx.TypeInternal, http.StatusInternalServerError, "Fallo al procesar mensaje")

	// Workflow errors
	CodeWorkflowNotFound        = ErrRegistry.Register("WORKFLOW_NOT_FOUND", errx.TypeNotFound, http.StatusNotFound, "Workflow no encontrado")
	CodeWorkflowAlreadyExists   = ErrRegistry.Register("WORKFLOW_ALREADY_EXISTS", errx.TypeConflict, http.StatusConflict, "Workflow ya existe")
	CodeInvalidWorkflowConfig   = ErrRegistry.Register("INVALID_WORKFLOW_CONFIG", errx.TypeValidation, http.StatusBadRequest, "Configuración de workflow inválida")
	CodeWorkflowInactive        = ErrRegistry.Register("WORKFLOW_INACTIVE", errx.TypeBusiness, http.StatusForbidden, "Workflow está inactivo")
	CodeWorkflowExecutionFailed = ErrRegistry.Register("WORKFLOW_EXECUTION_FAILED", errx.TypeInternal, http.StatusInternalServerError, "Ejecución de workflow falló")
	CodeInvalidWorkflowStep     = ErrRegistry.Register("INVALID_WORKFLOW_STEP", errx.TypeValidation, http.StatusBadRequest, "Paso de workflow inválido")
	CodeStepNotFound            = ErrRegistry.Register("STEP_NOT_FOUND", errx.TypeNotFound, http.StatusNotFound, "Paso no encontrado")
	CodeCyclicWorkflow          = ErrRegistry.Register("CYCLIC_WORKFLOW", errx.TypeValidation, http.StatusBadRequest, "Workflow tiene ciclos")

	// Session errors
	CodeSessionNotFound     = ErrRegistry.Register("SESSION_NOT_FOUND", errx.TypeNotFound, http.StatusNotFound, "Sesión no encontrada")
	CodeSessionExpired      = ErrRegistry.Register("SESSION_EXPIRED", errx.TypeBusiness, http.StatusGone, "Sesión expirada")
	CodeInvalidSessionState = ErrRegistry.Register("INVALID_SESSION_STATE", errx.TypeValidation, http.StatusBadRequest, "Estado de sesión inválido")

	// Trigger errors
	CodeInvalidTrigger     = ErrRegistry.Register("INVALID_TRIGGER", errx.TypeValidation, http.StatusBadRequest, "Trigger inválido")
	CodeNoMatchingWorkflow = ErrRegistry.Register("NO_MATCHING_WORKFLOW", errx.TypeBusiness, http.StatusNotFound, "No hay workflow que coincida con el trigger")

	// Execution errors
	CodeExecutionTimeout    = ErrRegistry.Register("EXECUTION_TIMEOUT", errx.TypeInternal, http.StatusRequestTimeout, "Ejecución excedió timeout")
	CodeStepExecutionFailed = ErrRegistry.Register("STEP_EXECUTION_FAILED", errx.TypeInternal, http.StatusInternalServerError, "Ejecución de paso falló")
)

// ============================================================================
// Error Constructor Functions
// ============================================================================

// Message errors
func ErrMessageNotFound() *errx.Error {
	return ErrRegistry.New(CodeMessageNotFound)
}

func ErrMessageAlreadyExists() *errx.Error {
	return ErrRegistry.New(CodeMessageAlreadyExists)
}

func ErrInvalidMessageStatus() *errx.Error {
	return ErrRegistry.New(CodeInvalidMessageStatus)
}

func ErrMessageProcessingFailed() *errx.Error {
	return ErrRegistry.New(CodeMessageProcessingFailed)
}

// Workflow errors
func ErrWorkflowNotFound() *errx.Error {
	return ErrRegistry.New(CodeWorkflowNotFound)
}

func ErrWorkflowAlreadyExists() *errx.Error {
	return ErrRegistry.New(CodeWorkflowAlreadyExists)
}

func ErrInvalidWorkflowConfig() *errx.Error {
	return ErrRegistry.New(CodeInvalidWorkflowConfig)
}

func ErrWorkflowInactive() *errx.Error {
	return ErrRegistry.New(CodeWorkflowInactive)
}

func ErrWorkflowExecutionFailed() *errx.Error {
	return ErrRegistry.New(CodeWorkflowExecutionFailed)
}

func ErrInvalidWorkflowStep() *errx.Error {
	return ErrRegistry.New(CodeInvalidWorkflowStep)
}

func ErrStepNotFound() *errx.Error {
	return ErrRegistry.New(CodeStepNotFound)
}

func ErrCyclicWorkflow() *errx.Error {
	return ErrRegistry.New(CodeCyclicWorkflow)
}

// Session errors
func ErrSessionNotFound() *errx.Error {
	return ErrRegistry.New(CodeSessionNotFound)
}

func ErrSessionExpired() *errx.Error {
	return ErrRegistry.New(CodeSessionExpired)
}

func ErrInvalidSessionState() *errx.Error {
	return ErrRegistry.New(CodeInvalidSessionState)
}

// Trigger errors
func ErrInvalidTrigger() *errx.Error {
	return ErrRegistry.New(CodeInvalidTrigger)
}

func ErrNoMatchingWorkflow() *errx.Error {
	return ErrRegistry.New(CodeNoMatchingWorkflow)
}

// Execution errors
func ErrExecutionTimeout() *errx.Error {
	return ErrRegistry.New(CodeExecutionTimeout)
}

func ErrStepExecutionFailed() *errx.Error {
	return ErrRegistry.New(CodeStepExecutionFailed)
}
package workflowexec

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/Abraxas-365/craftable/errx"
	"github.com/Abraxas-365/relay/engine"
)

// DefaultWorkflowExecutor implementa engine.WorkflowExecutor
type DefaultWorkflowExecutor struct {
	stepExecutors map[engine.StepType]engine.StepExecutor
}

var _ engine.WorkflowExecutor = (*DefaultWorkflowExecutor)(nil)

// NewDefaultWorkflowExecutor crea una nueva instancia del ejecutor de workflows
func NewDefaultWorkflowExecutor(stepExecutors ...engine.StepExecutor) *DefaultWorkflowExecutor {
	executor := &DefaultWorkflowExecutor{
		stepExecutors: make(map[engine.StepType]engine.StepExecutor),
	}

	// Registrar todos los ejecutores proporcionados
	for _, stepExec := range stepExecutors {
		executor.RegisterStepExecutor(stepExec)
	}

	return executor
}

// RegisterStepExecutor registra un ejecutor de paso
func (e *DefaultWorkflowExecutor) RegisterStepExecutor(executor engine.StepExecutor) {
	// Registrar para todos los tipos que soporte
	for _, stepType := range []engine.StepType{
		engine.StepTypeCondition,
		engine.StepTypeParser,
		engine.StepTypeTool,
		engine.StepTypeAction,
		engine.StepTypeDelay,
		engine.StepTypeResponse,
	} {
		if executor.SupportsType(stepType) {
			e.stepExecutors[stepType] = executor
			log.Printf("✓ Registered executor for step type: %s", stepType)
		}
	}
}

// Execute ejecuta un workflow completo
func (e *DefaultWorkflowExecutor) Execute(
	ctx context.Context,
	workflow engine.Workflow,
	message engine.Message,
	session *engine.Session,
) (*engine.ExecutionResult, error) {
	log.Printf("🔄 Starting workflow execution: %s for message: %s", workflow.Name, message.ID.String())

	startTime := time.Now()
	result := &engine.ExecutionResult{
		Success:       true,
		ShouldRespond: false,
		Context:       make(map[string]any),
		ExecutedSteps: []engine.StepResult{},
	}

	// Validar workflow
	if err := e.ValidateWorkflow(ctx, workflow); err != nil {
		return nil, errx.Wrap(err, "workflow validation failed", errx.TypeValidation)
	}

	// Preparar contexto inicial
	stepContext := e.prepareInitialContext(message, session)

	// Ejecutar pasos secuencialmente
	currentStepID := ""
	if len(workflow.Steps) > 0 {
		currentStepID = workflow.Steps[0].ID
	}

	visitedSteps := make(map[string]bool)
	maxSteps := len(workflow.Steps) * 2 // Prevenir ciclos infinitos

	for currentStepID != "" && len(result.ExecutedSteps) < maxSteps {
		// Prevenir ciclos
		if visitedSteps[currentStepID] {
			return nil, engine.ErrCyclicWorkflow().
				WithDetail("step_id", currentStepID).
				WithDetail("workflow_id", workflow.ID.String())
		}
		visitedSteps[currentStepID] = true

		// Buscar el paso actual
		step := workflow.GetStepByID(currentStepID)
		if step == nil {
			return nil, engine.ErrStepNotFound().WithDetail("step_id", currentStepID)
		}

		// Ejecutar paso
		stepResult, err := e.ExecuteStep(ctx, *step, message, session, stepContext)
		if err != nil {
			log.Printf("❌ Step execution failed: %s - %v", step.Name, err)
			stepResult.Success = false
			stepResult.Error = err.Error()
		}

		result.ExecutedSteps = append(result.ExecutedSteps, *stepResult)

		// Si el paso falló
		if !stepResult.Success {
			result.Success = false
			result.Error = fmt.Errorf("step %s failed: %s", step.Name, stepResult.Error)
			result.ErrorMessage = stepResult.Error

			// Ir al paso de fallo si existe
			if step.OnFailure != "" {
				currentStepID = step.OnFailure
				continue
			}
			break
		}

		// Actualizar contexto con el output del paso
		if stepResult.Output != nil {
			for key, value := range stepResult.Output {
				stepContext[key] = value
				result.Context[key] = value
			}
		}

		// Manejar respuestas
		if responseText, ok := stepResult.Output["response"].(string); ok && responseText != "" {
			result.Response = responseText
			result.ShouldRespond = true
		}
		if shouldRespond, ok := stepResult.Output["should_respond"].(bool); ok {
			result.ShouldRespond = shouldRespond
		}

		// Siguiente paso
		if step.OnSuccess != "" {
			currentStepID = step.OnSuccess
		} else {
			// No hay siguiente paso, terminar
			currentStepID = ""
		}
	}

	duration := time.Since(startTime)
	log.Printf("✅ Workflow execution completed: %s in %v", workflow.Name, duration)

	return result, nil
}

// ExecuteStep ejecuta un paso específico
func (e *DefaultWorkflowExecutor) ExecuteStep(
	ctx context.Context,
	step engine.WorkflowStep,
	message engine.Message,
	session *engine.Session,
	stepContext map[string]any,
) (*engine.StepResult, error) {
	log.Printf("⚡ Executing step: %s (type: %s)", step.Name, step.Type)

	// Aplicar timeout si está configurado
	if step.Timeout != nil && *step.Timeout > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, time.Duration(*step.Timeout)*time.Second)
		defer cancel()
	}

	// Buscar ejecutor para este tipo de paso
	executor, ok := e.stepExecutors[step.Type]
	if !ok {
		return nil, engine.ErrInvalidWorkflowStep().
			WithDetail("step_type", string(step.Type)).
			WithDetail("reason", "no executor found for step type")
	}

	// Preparar input con contexto actual
	input := e.prepareStepInput(message, session, stepContext)

	// Ejecutar paso
	startTime := time.Now()
	result, err := executor.Execute(ctx, step, input)
	if err != nil {
		result = &engine.StepResult{
			StepID:    step.ID,
			StepName:  step.Name,
			Success:   false,
			Error:     err.Error(),
			Duration:  time.Since(startTime).Milliseconds(),
			Timestamp: startTime,
		}
		return result, err
	}

	return result, nil
}

// ValidateWorkflow valida un workflow
func (e *DefaultWorkflowExecutor) ValidateWorkflow(ctx context.Context, workflow engine.Workflow) error {
	if !workflow.IsValid() {
		return engine.ErrInvalidWorkflowConfig().WithDetail("reason", "workflow is not valid")
	}

	if len(workflow.Steps) == 0 {
		return engine.ErrInvalidWorkflowConfig().WithDetail("reason", "workflow has no steps")
	}

	// Validar que todos los steps tengan IDs únicos
	stepIDs := make(map[string]bool)
	for _, step := range workflow.Steps {
		if step.ID == "" {
			return engine.ErrInvalidWorkflowStep().WithDetail("reason", "step has no ID")
		}
		if stepIDs[step.ID] {
			return engine.ErrInvalidWorkflowStep().
				WithDetail("step_id", step.ID).
				WithDetail("reason", "duplicate step ID")
		}
		stepIDs[step.ID] = true

		// Validar configuración del paso
		if executor, ok := e.stepExecutors[step.Type]; ok {
			if err := executor.ValidateConfig(step.Config); err != nil {
				return errx.Wrap(err, "step config validation failed", errx.TypeValidation).
					WithDetail("step_id", step.ID).
					WithDetail("step_name", step.Name)
			}
		}
	}

	// Validar referencias de OnSuccess y OnFailure
	for _, step := range workflow.Steps {
		if step.OnSuccess != "" && !stepIDs[step.OnSuccess] {
			return engine.ErrInvalidWorkflowStep().
				WithDetail("step_id", step.ID).
				WithDetail("on_success", step.OnSuccess).
				WithDetail("reason", "on_success references non-existent step")
		}
		if step.OnFailure != "" && !stepIDs[step.OnFailure] {
			return engine.ErrInvalidWorkflowStep().
				WithDetail("step_id", step.ID).
				WithDetail("on_failure", step.OnFailure).
				WithDetail("reason", "on_failure references non-existent step")
		}
	}

	return nil
}

// prepareInitialContext prepara el contexto inicial para la ejecución
func (e *DefaultWorkflowExecutor) prepareInitialContext(message engine.Message, session *engine.Session) map[string]any {
	context := make(map[string]any)

	// Agregar información del mensaje
	context["message_id"] = message.ID.String()
	context["message_text"] = message.Content.Text
	context["message_type"] = message.Content.Type
	context["sender_id"] = message.SenderID
	context["channel_id"] = message.ChannelID.String()

	// Agregar contexto del mensaje si existe
	if message.Context != nil {
		for key, value := range message.Context {
			context["msg_"+key] = value
		}
	}

	// Agregar información de la sesión si existe
	if session != nil {
		context["session_id"] = session.ID
		context["session_state"] = session.CurrentState

		// Agregar contexto de la sesión
		if session.Context != nil {
			for key, value := range session.Context {
				context["session_"+key] = value
			}
		}
	}

	return context
}

// prepareStepInput prepara el input para un paso
func (e *DefaultWorkflowExecutor) prepareStepInput(
	message engine.Message,
	session *engine.Session,
	stepContext map[string]any,
) map[string]any {
	input := make(map[string]any)

	// Copiar contexto del paso
	for key, value := range stepContext {
		input[key] = value
	}

	return input
}
