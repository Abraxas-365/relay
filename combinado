package main

import (
	"context"
	"log"
	"os"

	"github.com/Abraxas-365/craftable/ai/llm"
	"github.com/Abraxas-365/craftable/ai/providers/aiopenai"
	"github.com/Abraxas-365/craftable/eventx"
	"github.com/Abraxas-365/craftable/eventx/providers/eventxmemory"
	"github.com/Abraxas-365/relay/iam"
	"github.com/Abraxas-365/relay/iam/auth"
	"github.com/Abraxas-365/relay/iam/auth/authinfra"
	"github.com/Abraxas-365/relay/iam/role"
	"github.com/Abraxas-365/relay/iam/role/roleinfra"
	"github.com/Abraxas-365/relay/iam/role/rolesrv"
	"github.com/Abraxas-365/relay/iam/tenant"
	"github.com/Abraxas-365/relay/iam/tenant/tenantinfra"
	"github.com/Abraxas-365/relay/iam/tenant/tenantsrv"
	"github.com/Abraxas-365/relay/iam/user"
	"github.com/Abraxas-365/relay/iam/user/userinfra"
	"github.com/Abraxas-365/relay/iam/user/usersrv"
	"github.com/Abraxas-365/relay/pkg/config"

	"github.com/go-redis/redis/v8"
	"github.com/jmoiron/sqlx"
)

// Container contiene todas las dependencias de la aplicaci√≥n
type Container struct {
	// =================================================================
	// CONFIGURATION & INFRASTRUCTURE
	// =================================================================
	Config      *config.Config
	DB          *sqlx.DB
	RedisClient *redis.Client

	// =================================================================
	// EVENT BUS ‚úÖ
	// =================================================================
	EventBus eventx.EventBus

	// =================================================================
	// IAM - REPOSITORIES
	// =================================================================
	UserRepo         user.UserRepository
	UserRoleRepo     user.UserRoleRepository
	TenantRepo       tenant.TenantRepository
	TenantConfigRepo tenant.TenantConfigRepository
	RoleRepo         role.RoleRepository
	RolePermRepo     role.RolePermissionRepository

	// =================================================================
	// IAM - SERVICES
	// =================================================================
	PasswordService user.PasswordService
	UserService     *usersrv.UserService
	TenantService   *tenantsrv.TenantService
	RoleService     *rolesrv.RoleService

	// =================================================================
	// AUTH
	// =================================================================
	TokenRepo         auth.TokenRepository
	SessionRepo       auth.SessionRepository
	PasswordResetRepo auth.PasswordResetRepository
	StateManager      auth.StateManager
	TokenService      auth.TokenService
	OAuthServices     map[iam.OAuthProvider]auth.OAuthService
	AuthHandlers      *auth.AuthHandlers
	AuthMiddleware    *auth.AuthMiddleware

	LLMClient *llm.Client
}

// NewContainer crea un nuevo contenedor de dependencias
func NewContainer(cfg *config.Config, db *sqlx.DB, redisClient *redis.Client) *Container {
	c := &Container{
		Config:      cfg,
		DB:          db,
		RedisClient: redisClient,
	}

	// Inicializar dependencias en orden correcto
	log.Println("üì¶ Initializing dependency container...")

	c.initEventBus() // ‚úÖ Initialize EventBus first
	c.initIAMRepositories()
	c.initIAMServices()
	c.initAuthServices()

	log.Println("‚úÖ Dependency container initialized successfully")

	return c
}

// =================================================================
// EVENT BUS INITIALIZATION ‚úÖ
// =================================================================

func (c *Container) initEventBus() {
	log.Println("  üì° Initializing event bus...")

	// Create EventBus configuration
	busConfig := eventx.BusConfig{
		ConnectionName:    "invoice-event-bus",
		EnableLogging:     true,
		EnableMetrics:     true,
		EnablePersistence: false,
		AutoAck:           true,
		MaxRetries:        3,
	}

	// Create in-memory event bus
	c.EventBus = eventxmemory.New(busConfig)

	// Connect the bus
	ctx := context.Background()
	if err := c.EventBus.Connect(ctx); err != nil {
		log.Fatalf("‚ùå Failed to connect event bus: %v", err)
	}

	log.Println("  ‚úÖ Event bus initialized and connected")
}

// =================================================================
// IAM INITIALIZATION
// =================================================================

func (c *Container) initIAMRepositories() {
	log.Println("  üë• Initializing IAM repositories...")
	c.UserRepo = userinfra.NewPostgresUserRepository(c.DB)
	c.UserRoleRepo = userinfra.NewPostgresUserRoleRepository(c.DB)
	c.TenantRepo = tenantinfra.NewPostgresTenantRepository(c.DB)
	c.TenantConfigRepo = tenantinfra.NewPostgresTenantConfigRepository(c.DB)
	c.RoleRepo = roleinfra.NewPostgresRoleRepository(c.DB)
	c.RolePermRepo = roleinfra.NewPostgresRolePermissionRepository(c.DB)
}

func (c *Container) initIAMServices() {
	log.Println("  üë• Initializing IAM services...")
	c.PasswordService = authinfra.NewBcryptPasswordService()

	c.UserService = usersrv.NewUserService(
		c.UserRepo,
		c.UserRoleRepo,
		c.TenantRepo,
		c.RoleRepo,
		c.PasswordService,
	)

	c.TenantService = tenantsrv.NewTenantService(
		c.TenantRepo,
		c.TenantConfigRepo,
		c.UserRepo,
	)

	c.RoleService = rolesrv.NewRoleService(
		c.RoleRepo,
		c.RolePermRepo,
		c.TenantRepo,
	)
}

func (c *Container) initAuthServices() {
	log.Println("  üîê Initializing auth services...")

	c.TokenRepo = authinfra.NewPostgresTokenRepository(c.DB)
	c.SessionRepo = authinfra.NewPostgresSessionRepository(c.DB)
	c.PasswordResetRepo = authinfra.NewPostgresPasswordResetRepository(c.DB)
	c.StateManager = authinfra.NewRedisStateManager(c.RedisClient)

	c.TokenService = auth.NewJWTService(
		c.Config.Auth.JWT.SecretKey,
		c.Config.Auth.JWT.AccessTokenTTL,
		c.Config.Auth.JWT.RefreshTokenTTL,
		c.Config.Auth.JWT.Issuer,
	)

	c.OAuthServices = make(map[iam.OAuthProvider]auth.OAuthService)

	if c.Config.Auth.OAuth.Google.IsEnabled() {
		c.OAuthServices[iam.OAuthProviderGoogle] = auth.NewGoogleOAuthService(
			c.Config.Auth.OAuth.Google,
			c.StateManager,
		)
	}

	if c.Config.Auth.OAuth.Microsoft.IsEnabled() {
		c.OAuthServices[iam.OAuthProviderMicrosoft] = auth.NewMicrosoftOAuthService(
			c.Config.Auth.OAuth.Microsoft,
			c.StateManager,
		)
	}

	c.AuthHandlers = auth.NewAuthHandlers(
		c.OAuthServices,
		c.TokenService,
		c.UserRepo,
		c.TenantRepo,
		c.TokenRepo,
		c.SessionRepo,
		c.StateManager,
	)

	c.AuthMiddleware = auth.NewAuthMiddleware(c.TokenService)
}

// =================================================================
// LLM INITIALIZATION ‚úÖ
// =================================================================

func (c *Container) initLLMComponents() {
	log.Println("  ü§ñ Initializing LLM components...")

	// Initialize LLM client
	apiKey := os.Getenv("OPENAI_API_KEY")
	if apiKey == "" {
		log.Println("  ‚ö†Ô∏è  OPENAI_API_KEY not set, LLM features will be disabled")
		return
	}

	client := aiopenai.NewOpenAIProvider("")
	c.LLMClient = llm.NewClient(
		client,
	)

	log.Println("  ‚úÖ LLM components initialized with analytics tools")
}

// =================================================================
// UTILITY METHODS
// =================================================================

func (c *Container) GetAllRoutes() []RouteGroup {
	routes := []RouteGroup{
		{Name: "auth", Handler: c.AuthHandlers},
	}

	return routes
}

type RouteGroup struct {
	Name    string
	Handler any
}

func (c *Container) Cleanup() {
	log.Println("üßπ Cleaning up container resources...")

	// ‚úÖ Disconnect EventBus
	if c.EventBus != nil {
		log.Println("  üì° Disconnecting event bus...")
		ctx := context.Background()
		if err := c.EventBus.Disconnect(ctx); err != nil {
			log.Printf("  ‚ö†Ô∏è  Failed to disconnect event bus: %v", err)
		}
	}

	// Close database
	if c.DB != nil {
		log.Println("  üóÑÔ∏è  Closing database connections...")
		c.DB.Close()
	}

	// Close Redis
	if c.RedisClient != nil {
		log.Println("  üî¥ Closing Redis connections...")
		c.RedisClient.Close()
	}

	log.Println("‚úÖ Container cleanup complete")
}

func (c *Container) HealthCheck() map[string]bool {
	health := make(map[string]bool)

	// Check database
	if c.DB != nil {
		err := c.DB.Ping()
		health["database"] = err == nil
	} else {
		health["database"] = false
	}

	// Check Redis
	if c.RedisClient != nil {
		err := c.RedisClient.Ping(c.RedisClient.Context()).Err()
		health["redis"] = err == nil
	} else {
		health["redis"] = false
	}

	// ‚úÖ Check EventBus
	if c.EventBus != nil {
		health["event_bus"] = c.EventBus.IsConnected()
	} else {
		health["event_bus"] = false
	}

	return health
}

// ‚úÖ GetEventBusMetrics returns event bus metrics
func (c *Container) GetEventBusMetrics() eventx.BusMetrics {
	if metricsbus, ok := c.EventBus.(eventx.MetricsEventBus); ok {
		return metricsbus.GetMetrics()
	}
	return eventx.BusMetrics{}
}

func (c *Container) GetServiceNames() []string {
	services := []string{
		"UserService",
		"TenantService",
		"RoleService",
		"EventBus",
	}

	return services
}

func (c *Container) GetRepositoryNames() []string {
	repos := []string{
		"UserRepo",
		"TenantRepo",
		"RoleRepo",
	}

	return repos
}
package main

import (
	"context"
	"fmt"
	"log"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/Abraxas-365/craftable/errx/errxfiber"
	"github.com/Abraxas-365/relay/pkg/config"
	"github.com/Abraxas-365/relay/pkg/database"
	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/compress"
	"github.com/gofiber/fiber/v2/middleware/cors"
	"github.com/gofiber/fiber/v2/middleware/logger"
	"github.com/gofiber/fiber/v2/middleware/recover"
	"github.com/gofiber/fiber/v2/middleware/requestid"
)

var startTime = time.Now()

func main() {
	// Cargar configuraci√≥n
	cfg, err := config.Load()
	if err != nil {
		log.Fatalf("Failed to load configuration: %v", err)
	}

	// Configurar logger
	setupLogger(cfg)

	log.Println("üöÄ Starting Facturamelo API...")
	log.Printf("üìç Environment: %s", cfg.Server.Environment)

	// Conectar a PostgreSQL
	log.Println("üîå Connecting to PostgreSQL...")
	db, err := database.NewPostgresDB(cfg.Database)
	if err != nil {
		log.Fatalf("Failed to connect to database: %v", err)
	}
	defer database.CloseDB(db)
	log.Println("‚úÖ Connected to PostgreSQL")

	// Conectar a Redis
	log.Println("üîå Connecting to Redis...")
	redisClient, err := database.NewRedisClient(cfg.Redis)
	if err != nil {
		log.Fatalf("Failed to connect to Redis: %v", err)
	}
	defer database.CloseRedis(redisClient)
	log.Println("‚úÖ Connected to Redis")

	// Inicializar contenedor de dependencias
	log.Println("üì¶ Initializing dependency container...")
	container := NewContainer(cfg, db, redisClient)
	defer container.Cleanup() // Cleanup on exit
	log.Println("‚úÖ Dependencies initialized")

	// Verificar health de los servicios
	health := container.HealthCheck()
	log.Printf("üè• Health check: Database=%v, Redis=%v, Scheduler=%v",
		health["database"], health["redis"], health["scheduler"])

	// =================================================================
	// INICIAR SCHEDULER
	// =================================================================
	log.Println("‚úÖ Scheduler started")
	// =================================================================

	// Crear aplicaci√≥n Fiber
	app := fiber.New(fiber.Config{
		AppName:      "Facturamelo API",
		ServerHeader: "Facturamelo",
		ReadTimeout:  cfg.Server.ReadTimeout,
		WriteTimeout: cfg.Server.WriteTimeout,
		ErrorHandler: errxfiber.FiberErrorHandler(),
	})

	// Configurar middleware global
	setupMiddleware(app, cfg)

	// Registrar rutas
	log.Println("üõ£Ô∏è  Setting up routes...")
	setupRoutes(app, container)
	log.Println("‚úÖ Routes configured")

	// Log de servicios registrados
	log.Printf("üìã Registered services: %v", container.GetServiceNames())
	log.Printf("üìã Registered repositories: %v", container.GetRepositoryNames())

	// Iniciar servidor en goroutine
	go func() {
		addr := fmt.Sprintf(":%s", cfg.Server.Port)
		log.Printf("üöÄ Server listening on %s", addr)
		log.Printf("üåç Local: http://localhost%s", addr)
		if err := app.Listen(addr); err != nil {
			log.Fatalf("Failed to start server: %v", err)
		}
	}()

	// Graceful shutdown
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, os.Interrupt, syscall.SIGTERM)
	<-quit

	log.Println("‚è∏Ô∏è  Shutting down server...")

	// Apagado graceful del servidor Fiber
	ctx, cancel := context.WithTimeout(context.Background(), cfg.Server.ShutdownTimeout)
	defer cancel()

	if err := app.ShutdownWithContext(ctx); err != nil {
		log.Printf("‚ùå Error during server shutdown: %v", err)
	}

	log.Println("üëã Server stopped gracefully")
}

// setupLogger configura el logger
func setupLogger(cfg *config.Config) {
	log.SetFlags(log.LstdFlags | log.Lshortfile)
	if cfg.Server.Environment == "production" {
		// En producci√≥n podr√≠as usar un logger m√°s sofisticado
		log.SetFlags(log.LstdFlags)
	}
}

// setupMiddleware configura los middleware globales
func setupMiddleware(app *fiber.App, cfg *config.Config) {
	// Request ID
	app.Use(requestid.New())

	// Logger
	if cfg.Server.Environment != "test" {
		app.Use(logger.New(logger.Config{
			Format: "[${time}] ${status} - ${method} ${path} - ${latency}\n",
		}))
	}

	// Recover de panics
	app.Use(recover.New())

	// CORS
	app.Use(cors.New(cors.Config{
		AllowOrigins:     getCorsOrigins(cfg),
		AllowMethods:     "GET,POST,PUT,DELETE,OPTIONS,PATCH",
		AllowHeaders:     "Origin,Content-Type,Accept,Authorization",
		AllowCredentials: true,
	}))

	// Compression
	app.Use(compress.New(compress.Config{
		Level: compress.LevelBestSpeed,
	}))
}

// setupRoutes configura todas las rutas de la aplicaci√≥n
func setupRoutes(app *fiber.App, c *Container) {

	log.Println("  ‚úì Invoice routes registered")
	// Health check (enhanced)
	app.Get("/health", healthCheckHandler(c))

	// Root endpoint
	app.Get("/", func(ctx *fiber.Ctx) error {
		return ctx.JSON(fiber.Map{
			"message":  "Facturamelo API",
			"version":  "1.0.0",
			"status":   "running",
			"uptime":   time.Since(startTime).String(),
			"services": c.GetServiceNames(),
		})
	})

	// =================================================================
	// AUTH ROUTES
	// =================================================================
	c.AuthHandlers.RegisterRoutes(app)

	// =================================================================
	// BUSINESS ROUTES
	// =================================================================

	// Areas routes

	// =================================================================
	// DEBUG ROUTES (only in development)
	// =================================================================
	if c.Config.Server.Environment == "development" {
		app.Get("/debug/container", func(ctx *fiber.Ctx) error {
			return ctx.JSON(fiber.Map{
				"services":     c.GetServiceNames(),
				"repositories": c.GetRepositoryNames(),
				"health":       c.HealthCheck(),
			})
		})
	}

	// =================================================================
	// 404 HANDLER
	// =================================================================
	app.Use(func(ctx *fiber.Ctx) error {
		return ctx.Status(fiber.StatusNotFound).JSON(fiber.Map{
			"error": "Route not found",
			"path":  ctx.Path(),
		})
	})
}

// healthCheckHandler handler de health check mejorado
func healthCheckHandler(c *Container) fiber.Handler {
	return func(ctx *fiber.Ctx) error {
		// Usar el m√©todo HealthCheck del container
		health := c.HealthCheck()

		// Determinar si todos los servicios est√°n saludables
		allHealthy := true
		for _, healthy := range health {
			if !healthy {
				allHealthy = false
				break
			}
		}

		status := "healthy"
		statusCode := fiber.StatusOK

		if !allHealthy {
			status = "degraded"
			statusCode = fiber.StatusServiceUnavailable
		}

		return ctx.Status(statusCode).JSON(fiber.Map{
			"status":    status,
			"timestamp": time.Now(),
			"uptime":    time.Since(startTime).String(),
			"services":  health,
			"version":   "1.0.0",
		})
	}
}

// getCorsOrigins retorna los or√≠genes permitidos para CORS
func getCorsOrigins(cfg *config.Config) string {
	// Permite override via variable de entorno (lista separada por comas)
	if origins := os.Getenv("CORS_ALLOWED_ORIGINS"); origins != "" {
		return origins
	}

	if cfg.Server.Environment == "production" {
		return "https://yourdomain.com"
	}

	// Evitar wildcard cuando AllowCredentials=true; usar or√≠genes comunes de desarrollo
	return "http://localhost:3000,http://127.0.0.1:3000,http://localhost:5173,http://127.0.0.1:5173"
}
package auth

import (
	"context"
	"strings"
	"time"

	"github.com/Abraxas-365/craftable/ptrx"
	"github.com/Abraxas-365/relay/iam"
	"github.com/Abraxas-365/relay/iam/tenant"
	"github.com/Abraxas-365/relay/iam/user"
	"github.com/Abraxas-365/relay/pkg/kernel"
	"github.com/gofiber/fiber/v2"
	"github.com/google/uuid"
)

// AuthHandlers maneja las rutas de autenticaci√≥n con Fiber
type AuthHandlers struct {
	oauthServices map[iam.OAuthProvider]OAuthService
	tokenService  TokenService
	userRepo      user.UserRepository
	tenantRepo    tenant.TenantRepository
	tokenRepo     TokenRepository
	sessionRepo   SessionRepository
	stateManager  StateManager
}

// NewAuthHandlers crea un nuevo handler de autenticaci√≥n
func NewAuthHandlers(
	oauthServices map[iam.OAuthProvider]OAuthService,
	tokenService TokenService,
	userRepo user.UserRepository,
	tenantRepo tenant.TenantRepository,
	tokenRepo TokenRepository,
	sessionRepo SessionRepository,
	stateManager StateManager,
) *AuthHandlers {
	return &AuthHandlers{
		oauthServices: oauthServices,
		tokenService:  tokenService,
		userRepo:      userRepo,
		tenantRepo:    tenantRepo,
		tokenRepo:     tokenRepo,
		sessionRepo:   sessionRepo,
		stateManager:  stateManager,
	}
}

// LoginRequest estructura para iniciar login OAuth
type LoginRequest struct {
	Provider  iam.OAuthProvider `json:"provider"`
	TenantRUC string            `json:"tenant_ruc,omitempty"`
}

// LoginResponse respuesta del endpoint de login
type LoginResponse struct {
	AuthURL string `json:"auth_url"`
	State   string `json:"state"`
}

// TokenResponse respuesta con tokens de autenticaci√≥n
type TokenResponse struct {
	AccessToken  string                  `json:"access_token"`
	RefreshToken string                  `json:"refresh_token"`
	TokenType    string                  `json:"token_type"`
	ExpiresIn    int                     `json:"expires_in"`
	User         user.UserDetailsDTO     `json:"user"`
	Tenant       tenant.TenantDetailsDTO `json:"tenant"`
}

// RefreshTokenRequest estructura para renovar token
type RefreshTokenRequest struct {
	RefreshToken string `json:"refresh_token"`
}

// RegisterRoutes registra las rutas de autenticaci√≥n en Fiber
func (ah *AuthHandlers) RegisterRoutes(app *fiber.App) {
	auth := app.Group("/auth")

	auth.Post("/login", ah.InitiateLogin)
	auth.Get("/callback/:provider", ah.HandleCallback)
	auth.Post("/refresh", ah.RefreshToken)
	auth.Post("/logout", ah.Logout)
	auth.Get("/me", ah.GetCurrentUser) // Nueva ruta para obtener usuario actual
}

// InitiateLogin inicia el proceso de login OAuth
func (ah *AuthHandlers) InitiateLogin(c *fiber.Ctx) error {
	var req LoginRequest
	if err := c.BodyParser(&req); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Invalid request body",
		})
	}

	// Normalizar el proveedor a may√∫sculas y verificar que est√© soportado
	normalizedProvider := iam.OAuthProvider(strings.ToUpper(string(req.Provider)))
	oauthService, exists := ah.oauthServices[normalizedProvider]
	if !exists {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": ErrInvalidOAuthProvider().Error(),
		})
	}

	// Generar estado OAuth
	state := ah.stateManager.GenerateState()

	// Almacenar informaci√≥n del estado
	stateData := map[string]interface{}{
		"provider": normalizedProvider,
	}
	if req.TenantRUC != "" {
		stateData["tenant_ruc"] = req.TenantRUC
	}

	if err := ah.stateManager.StoreState(c.Context(), state, stateData); err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to store OAuth state",
		})
	}

	// Generar URL de autorizaci√≥n
	authURL := oauthService.GetAuthURL(state)

	return c.JSON(LoginResponse{
		AuthURL: authURL,
		State:   state,
	})
}

// HandleCallback maneja el callback OAuth
func (ah *AuthHandlers) HandleCallback(c *fiber.Ctx) error {
	providerStr := c.Params("provider")

	// Convertir string a OAuthProvider
	var provider iam.OAuthProvider
	switch providerStr {
	case "google":
		provider = iam.OAuthProviderGoogle
	case "microsoft":
		provider = iam.OAuthProviderMicrosoft
	default:
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": ErrInvalidOAuthProvider().Error(),
		})
	}

	// Verificar que el servicio OAuth exista
	oauthService, exists := ah.oauthServices[provider]
	if !exists {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": ErrInvalidOAuthProvider().Error(),
		})
	}

	// Obtener par√°metros del callback
	code := c.Query("code")
	state := c.Query("state")
	errorParam := c.Query("error")

	// Verificar errores OAuth
	if errorParam != "" {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": ErrOAuthCallbackError().WithDetail("error", errorParam).Error(),
		})
	}

	if code == "" || state == "" {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Missing code or state parameter",
		})
	}

	// Validar estado
	stateData, err := ah.stateManager.GetStateData(c.Context(), state)
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": ErrInvalidState().Error(),
		})
	}

	// Intercambiar c√≥digo por token
	tokenResp, err := oauthService.ExchangeToken(c.Context(), code)
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	// Obtener informaci√≥n del usuario
	userInfo, err := oauthService.GetUserInfo(c.Context(), tokenResp.AccessToken)
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	// Buscar o crear usuario
	userEntity, tenantEntity, err := ah.findOrCreateUser(c.Context(), userInfo, provider, stateData)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	// Generar tokens de nuestra aplicaci√≥n
	accessToken, err := ah.tokenService.GenerateAccessToken(userEntity.ID, tenantEntity.ID, map[string]any{
		"email":    userEntity.Email,
		"name":     userEntity.Name,
		"is_admin": userEntity.IsAdmin,
	})
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	refreshTokenStr, err := ah.tokenService.GenerateRefreshToken(userEntity.ID)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	// Guardar refresh token en base de datos
	refreshToken := RefreshToken{
		ID:        generateID(),
		Token:     refreshTokenStr,
		UserID:    userEntity.ID,
		TenantID:  tenantEntity.ID,
		ExpiresAt: time.Now().Add(7 * 24 * time.Hour),
		CreatedAt: time.Now(),
		IsRevoked: false,
	}

	if err := ah.tokenRepo.SaveRefreshToken(c.Context(), refreshToken); err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to save refresh token",
		})
	}

	// Crear sesi√≥n de usuario
	session := UserSession{
		ID:           generateID(),
		UserID:       userEntity.ID,
		TenantID:     tenantEntity.ID,
		SessionToken: generateID(),
		IPAddress:    c.IP(),
		UserAgent:    c.Get("User-Agent"),
		ExpiresAt:    time.Now().Add(24 * time.Hour),
		CreatedAt:    time.Now(),
		LastActivity: time.Now(),
	}

	if err := ah.sessionRepo.SaveSession(c.Context(), session); err != nil {
		// Log error pero no fallar la autenticaci√≥n
		// logger.Error("Failed to save session", err)
	}

	// Actualizar √∫ltimo login del usuario
	userEntity.UpdateLastLogin()
	if err := ah.userRepo.Save(c.Context(), *userEntity); err != nil {
		// Log error pero no fallar
		// logger.Error("Failed to update user last login", err)
	}

	// En desarrollo, puedes devolver JSON directamente
	// En producci√≥n, probablemente quieras hacer redirect con los tokens en cookies o URL
	response := TokenResponse{
		AccessToken:  accessToken,
		RefreshToken: refreshTokenStr,
		TokenType:    "Bearer",
		ExpiresIn:    int(15 * time.Minute / time.Second),
		User:         userEntity.ToDTO(),
		Tenant:       tenantEntity.ToDTO(),
	}

	// Opcional: Set cookies for browser-based apps
	c.Cookie(&fiber.Cookie{
		Name:     "access_token",
		Value:    accessToken,
		Expires:  time.Now().Add(15 * time.Minute),
		HTTPOnly: true,
		Secure:   true, // Set to true in production with HTTPS
		SameSite: "Lax",
	})

	c.Cookie(&fiber.Cookie{
		Name:     "refresh_token",
		Value:    refreshTokenStr,
		Expires:  time.Now().Add(7 * 24 * time.Hour),
		HTTPOnly: true,
		Secure:   true, // Set to true in production with HTTPS
		SameSite: "Lax",
	})

	return c.JSON(response)
}

// RefreshToken renueva un access token usando refresh token
func (ah *AuthHandlers) RefreshToken(c *fiber.Ctx) error {
	var req RefreshTokenRequest

	if err := c.BodyParser(&req); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Invalid request body",
		})
	}

	// Alternativamente, obtener refresh token de cookie
	if req.RefreshToken == "" {
		req.RefreshToken = c.Cookies("refresh_token")
	}

	if req.RefreshToken == "" {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "refresh_token is required",
		})
	}

	// Buscar refresh token en base de datos
	refreshToken, err := ah.tokenRepo.FindRefreshToken(c.Context(), req.RefreshToken)
	if err != nil {
		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
			"error": ErrInvalidRefreshToken().Error(),
		})
	}

	// Verificar validez del refresh token
	if !refreshToken.IsValid() {
		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
			"error": ErrExpiredRefreshToken().Error(),
		})
	}

	// Buscar usuario y tenant
	userEntity, err := ah.userRepo.FindByID(c.Context(), refreshToken.UserID, refreshToken.TenantID)
	if err != nil {
		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
			"error": "User not found",
		})
	}

	tenantEntity, err := ah.tenantRepo.FindByID(c.Context(), refreshToken.TenantID)
	if err != nil {
		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
			"error": "Tenant not found",
		})
	}

	// Verificar que el usuario pueda hacer login
	if !userEntity.CanLogin() {
		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
			"error": "User cannot login",
		})
	}

	// Verificar que el tenant est√© activo
	if !tenantEntity.IsActive() {
		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
			"error": "Tenant is not active",
		})
	}

	// Generar nuevo access token
	accessToken, err := ah.tokenService.GenerateAccessToken(userEntity.ID, tenantEntity.ID, map[string]any{
		"email":    userEntity.Email,
		"name":     userEntity.Name,
		"is_admin": userEntity.IsAdmin,
	})
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	// Update access token cookie
	c.Cookie(&fiber.Cookie{
		Name:     "access_token",
		Value:    accessToken,
		Expires:  time.Now().Add(15 * time.Minute),
		HTTPOnly: true,
		Secure:   true, // Set to true in production with HTTPS
		SameSite: "Lax",
	})

	return c.JSON(fiber.Map{
		"access_token": accessToken,
		"token_type":   "Bearer",
		"expires_in":   int(15 * time.Minute / time.Second),
	})
}

// Logout invalida tokens y sesiones del usuario
func (ah *AuthHandlers) Logout(c *fiber.Ctx) error {
	// Intentar obtener contexto de auth del middleware
	authContext, ok := GetAuthContext(c)
	if !ok {
		// Fallback: intentar decodificar el token desde Authorization o cookie
		var token string
		authHeader := c.Get("Authorization")
		if authHeader != "" {
			parts := strings.SplitN(authHeader, " ", 2)
			if len(parts) == 2 && parts[0] == "Bearer" && parts[1] != "" {
				token = parts[1]
			}
		}
		if token == "" {
			token = c.Cookies("access_token")
		}
		if token == "" {
			return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
				"error": iam.ErrUnauthorized().Error(),
			})
		}
		claims, err := ah.tokenService.ValidateAccessToken(token)
		if err != nil {
			return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
				"error": iam.ErrUnauthorized().Error(),
			})
		}
		// Construir contexto de autenticaci√≥n a partir de los claims
		authContext = &kernel.AuthContext{
			UserID:   claims.UserID,
			TenantID: claims.TenantID,
			IsAdmin:  claims.IsAdmin,
			Email:    claims.Email,
			Name:     claims.Name,
		}
	}

	// Revocar todos los refresh tokens del usuario
	if err := ah.tokenRepo.RevokeAllUserTokens(c.Context(), authContext.UserID); err != nil {
		// Log error pero no fallar
		// logger.Error("Failed to revoke user tokens", err)
	}

	// Revocar todas las sesiones del usuario
	if err := ah.sessionRepo.RevokeAllUserSessions(c.Context(), authContext.UserID); err != nil {
		// Log error pero no fallar
		// logger.Error("Failed to revoke user sessions", err)
	}

	// Clear cookies
	c.Cookie(&fiber.Cookie{
		Name:     "access_token",
		Value:    "",
		Expires:  time.Now().Add(-time.Hour),
		HTTPOnly: true,
	})

	c.Cookie(&fiber.Cookie{
		Name:     "refresh_token",
		Value:    "",
		Expires:  time.Now().Add(-time.Hour),
		HTTPOnly: true,
	})

	return c.JSON(fiber.Map{
		"message": "Logged out successfully",
	})
}

// GetCurrentUser obtiene la informaci√≥n del usuario autenticado
func (ah *AuthHandlers) GetCurrentUser(c *fiber.Ctx) error {
	authContext, ok := GetAuthContext(c)
	if !ok {
		// Fallback: intentar decodificar el token desde Authorization o cookie
		var token string
		authHeader := c.Get("Authorization")
		if authHeader != "" {
			parts := strings.SplitN(authHeader, " ", 2)
			if len(parts) == 2 && parts[0] == "Bearer" && parts[1] != "" {
				token = parts[1]
			}
		}
		if token == "" {
			token = c.Cookies("access_token")
		}
		if token == "" {
			return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
				"error": iam.ErrUnauthorized().Error(),
			})
		}
		claims, err := ah.tokenService.ValidateAccessToken(token)
		if err != nil {
			return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
				"error": iam.ErrUnauthorized().Error(),
			})
		}
		authContext = &kernel.AuthContext{
			UserID:   claims.UserID,
			TenantID: claims.TenantID,
			IsAdmin:  claims.IsAdmin,
			Email:    claims.Email,
			Name:     claims.Name,
		}
	}

	// Buscar usuario completo
	userEntity, err := ah.userRepo.FindByID(c.Context(), authContext.UserID, authContext.TenantID)
	if err != nil {
		return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
			"error": "User not found",
		})
	}

	// Buscar tenant
	tenantEntity, err := ah.tenantRepo.FindByID(c.Context(), authContext.TenantID)
	if err != nil {
		return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
			"error": "Tenant not found",
		})
	}

	return c.JSON(fiber.Map{
		"user":   userEntity.ToDTO(),
		"tenant": tenantEntity.ToDTO(),
	})
}

// findOrCreateUser busca o crea un usuario basado en la informaci√≥n OAuth
// (Esta funci√≥n permanece igual que en la versi√≥n anterior)
func (ah *AuthHandlers) findOrCreateUser(ctx context.Context, userInfo *OAuthUserInfo, provider iam.OAuthProvider, stateData map[string]interface{}) (*user.User, *tenant.Tenant, error) {
	// Buscar tenant si se especific√≥ RUC
	var tenantEntity *tenant.Tenant
	var err error

	if tenantRUC, ok := stateData["tenant_ruc"].(string); ok && tenantRUC != "" {
		tenantEntity, err = ah.tenantRepo.FindByRUC(ctx, tenantRUC)
		if err != nil {
			return nil, nil, tenant.ErrTenantNotFound()
		}
	}

	// Si no hay tenant espec√≠fico, buscar por email del usuario
	if tenantEntity == nil {
		// Por ahora, crear un tenant autom√°tico o usar el primer tenant activo
		// En producci√≥n, esto deber√≠a manejarse diferente
		tenants, err := ah.tenantRepo.FindActive(ctx)
		if err != nil || len(tenants) == 0 {
			return nil, nil, tenant.ErrTenantNotFound()
		}
		tenantEntity = tenants[0] // Usar el primer tenant activo
	}

	// Buscar usuario existente
	existingUser, err := ah.userRepo.FindByEmail(ctx, userInfo.Email, tenantEntity.ID)
	if err == nil {
		// Usuario existe, actualizar informaci√≥n OAuth si es necesario
		if existingUser.OAuthProvider != provider || existingUser.OAuthProviderID != userInfo.ID {
			existingUser.OAuthProvider = provider
			existingUser.OAuthProviderID = userInfo.ID
			existingUser.UpdateProfile(userInfo.Name, userInfo.Picture)

			if err := ah.userRepo.Save(ctx, *existingUser); err != nil {
				return nil, nil, err
			}
		}
		return existingUser, tenantEntity, nil
	}

	// Verificar si el tenant puede agregar m√°s usuarios
	if !tenantEntity.CanAddUser() {
		return nil, nil, tenant.ErrMaxUsersReached()
	}

	// Crear nuevo usuario
	newUser := &user.User{
		ID:              kernel.NewUserID(generateID()),
		TenantID:        tenantEntity.ID,
		Email:           userInfo.Email,
		Name:            userInfo.Name,
		Picture:         ptrx.String(userInfo.Picture),
		Status:          user.UserStatusActive,
		IsAdmin:         false, // Por defecto no es admin
		OAuthProvider:   provider,
		OAuthProviderID: userInfo.ID,
		EmailVerified:   userInfo.EmailVerified,
		CreatedAt:       time.Now(),
		UpdatedAt:       time.Now(),
	}

	// Guardar usuario
	if err := ah.userRepo.Save(ctx, *newUser); err != nil {
		return nil, nil, err
	}

	// Incrementar contador de usuarios del tenant
	if err := tenantEntity.AddUser(); err != nil {
		// Intentar limpiar el usuario creado
		ah.userRepo.Delete(ctx, newUser.ID, tenantEntity.ID)
		return nil, nil, err
	}

	// Guardar tenant actualizado
	if err := ah.tenantRepo.Save(ctx, *tenantEntity); err != nil {
		// Log error pero no fallar
		// logger.Error("Failed to update tenant user count", err)
	}

	return newUser, tenantEntity, nil
}

// Helper functions
func generateID() string {
	// Implementar generaci√≥n de ID √∫nico (UUID, nanoid, etc.)
	return uuid.NewString()
}
package auth

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/Abraxas-365/craftable/errx"
	"github.com/Abraxas-365/relay/iam"
)

const (
	GoogleAuthURL     = "https://accounts.google.com/o/oauth2/auth"
	GoogleTokenURL    = "https://oauth2.googleapis.com/token"
	GoogleUserInfoURL = "https://www.googleapis.com/oauth2/v2/userinfo"
)

// GoogleOAuthService implementaci√≥n del servicio OAuth para Google
type GoogleOAuthService struct {
	config       OAuthConfig
	httpClient   *http.Client
	stateManager StateManager
}

// NewGoogleOAuthService crea una nueva instancia del servicio Google OAuth
func NewGoogleOAuthService(config OAuthConfig, stateManager StateManager) *GoogleOAuthService {
	if len(config.Scopes) == 0 {
		config.Scopes = []string{"openid", "email", "profile"}
	}

	return &GoogleOAuthService{
		config:       config,
		httpClient:   &http.Client{Timeout: 30 * time.Second},
		stateManager: stateManager,
	}
}

// GetProvider retorna el proveedor OAuth
func (g *GoogleOAuthService) GetProvider() iam.OAuthProvider {
	return iam.OAuthProviderGoogle
}

// GetAuthURL genera la URL de autorizaci√≥n de Google
func (g *GoogleOAuthService) GetAuthURL(state string) string {
	params := url.Values{
		"client_id":     {g.config.ClientID},
		"redirect_uri":  {g.config.RedirectURL},
		"scope":         {strings.Join(g.config.Scopes, " ")},
		"response_type": {"code"},
		"state":         {state},
		"access_type":   {"offline"}, // Para obtener refresh token
		"prompt":        {"consent"}, // Forzar consent para obtener refresh token
	}

	return fmt.Sprintf("%s?%s", GoogleAuthURL, params.Encode())
}

// ValidateState valida el estado OAuth
func (g *GoogleOAuthService) ValidateState(state string) bool {
	return g.stateManager.ValidateState(state)
}

// ExchangeToken intercambia el c√≥digo de autorizaci√≥n por tokens
func (g *GoogleOAuthService) ExchangeToken(ctx context.Context, code string) (*OAuthTokenResponse, error) {
	data := url.Values{
		"client_id":     {g.config.ClientID},
		"client_secret": {g.config.ClientSecret},
		"code":          {code},
		"grant_type":    {"authorization_code"},
		"redirect_uri":  {g.config.RedirectURL},
	}

	req, err := http.NewRequestWithContext(ctx, "POST", GoogleTokenURL, strings.NewReader(data.Encode()))
	if err != nil {
		return nil, errx.Wrap(err, "failed to create token request", errx.TypeInternal)
	}

	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	resp, err := g.httpClient.Do(req)
	if err != nil {
		return nil, errx.Wrap(err, "failed to exchange token", errx.TypeExternal)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, ErrOAuthAuthorizationFailed().
			WithDetail("status_code", resp.StatusCode).
			WithDetail("provider", "google")
	}

	var tokenResp OAuthTokenResponse
	if err := json.NewDecoder(resp.Body).Decode(&tokenResp); err != nil {
		return nil, errx.Wrap(err, "failed to decode token response", errx.TypeExternal)
	}

	return &tokenResp, nil
}

// GetUserInfo obtiene la informaci√≥n del usuario desde Google
func (g *GoogleOAuthService) GetUserInfo(ctx context.Context, accessToken string) (*OAuthUserInfo, error) {
	req, err := http.NewRequestWithContext(ctx, "GET", GoogleUserInfoURL, nil)
	if err != nil {
		return nil, errx.Wrap(err, "failed to create user info request", errx.TypeInternal)
	}

	req.Header.Set("Authorization", "Bearer "+accessToken)

	resp, err := g.httpClient.Do(req)
	if err != nil {
		return nil, errx.Wrap(err, "failed to get user info", errx.TypeExternal)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, ErrOAuthAuthorizationFailed().
			WithDetail("status_code", resp.StatusCode).
			WithDetail("provider", "google").
			WithDetail("endpoint", "userinfo")
	}

	var googleUser struct {
		ID            string `json:"id"`
		Email         string `json:"email"`
		Name          string `json:"name"`
		Picture       string `json:"picture"`
		EmailVerified bool   `json:"verified_email"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&googleUser); err != nil {
		return nil, errx.Wrap(err, "failed to decode user info", errx.TypeExternal)
	}

	return &OAuthUserInfo{
		ID:            googleUser.ID,
		Email:         googleUser.Email,
		Name:          googleUser.Name,
		Picture:       googleUser.Picture,
		EmailVerified: googleUser.EmailVerified,
	}, nil
}
package authinfra

import (
	"context"
	"database/sql"

	"github.com/Abraxas-365/craftable/errx"
	"github.com/Abraxas-365/relay/iam/auth"
	"github.com/jmoiron/sqlx"
)

// PostgresPasswordResetRepository implementaci√≥n de PostgreSQL para PasswordResetRepository
type PostgresPasswordResetRepository struct {
	db *sqlx.DB
}

// NewPostgresPasswordResetRepository crea una nueva instancia del repositorio de reset de contrase√±a
func NewPostgresPasswordResetRepository(db *sqlx.DB) auth.PasswordResetRepository {
	return &PostgresPasswordResetRepository{
		db: db,
	}
}

// SaveResetToken guarda un token de reset de contrase√±a
func (r *PostgresPasswordResetRepository) SaveResetToken(ctx context.Context, token auth.PasswordResetToken) error {
	query := `
		INSERT INTO password_reset_tokens (
			id, token, user_id, expires_at, created_at, is_used
		) VALUES (
			:id, :token, :user_id, :expires_at, :created_at, :is_used
		)`

	_, err := r.db.NamedExecContext(ctx, query, token)
	if err != nil {
		return errx.Wrap(err, "failed to save reset token", errx.TypeInternal).
			WithDetail("user_id", token.UserID.String())
	}

	return nil
}

// FindResetToken busca un token de reset por su valor
func (r *PostgresPasswordResetRepository) FindResetToken(ctx context.Context, tokenValue string) (*auth.PasswordResetToken, error) {
	query := `
		SELECT 
			id, token, user_id, expires_at, created_at, is_used
		FROM password_reset_tokens 
		WHERE token = $1 AND is_used = false AND expires_at > NOW()`

	var token auth.PasswordResetToken
	err := r.db.GetContext(ctx, &token, query, tokenValue)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, errx.New("reset token not found or invalid", errx.TypeNotFound)
		}
		return nil, errx.Wrap(err, "failed to find reset token", errx.TypeInternal)
	}

	return &token, nil
}

// ConsumeResetToken marca un token como usado
func (r *PostgresPasswordResetRepository) ConsumeResetToken(ctx context.Context, tokenValue string) error {
	query := `
		UPDATE password_reset_tokens 
		SET is_used = true 
		WHERE token = $1 AND is_used = false AND expires_at > NOW()`

	result, err := r.db.ExecContext(ctx, query, tokenValue)
	if err != nil {
		return errx.Wrap(err, "failed to consume reset token", errx.TypeInternal)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return errx.Wrap(err, "failed to get rows affected", errx.TypeInternal)
	}

	if rowsAffected == 0 {
		return errx.New("reset token not found or already used", errx.TypeNotFound)
	}

	return nil
}

// CleanExpiredResetTokens limpia tokens expirados o usados (para mantenimiento)
func (r *PostgresPasswordResetRepository) CleanExpiredResetTokens(ctx context.Context) error {
	query := `
		DELETE FROM password_reset_tokens 
		WHERE expires_at < NOW() OR is_used = true`

	_, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return errx.Wrap(err, "failed to clean expired reset tokens", errx.TypeInternal)
	}

	return nil
}

// RevokeAllUserResetTokens revoca todos los tokens de reset de un usuario
func (r *PostgresPasswordResetRepository) RevokeAllUserResetTokens(ctx context.Context, userID string) error {
	query := `
		UPDATE password_reset_tokens 
		SET is_used = true 
		WHERE user_id = $1 AND is_used = false`

	_, err := r.db.ExecContext(ctx, query, userID)
	if err != nil {
		return errx.Wrap(err, "failed to revoke all user reset tokens", errx.TypeInternal).
			WithDetail("user_id", userID)
	}

	return nil
}

// CountActiveResetTokens cuenta los tokens activos de reset de un usuario
func (r *PostgresPasswordResetRepository) CountActiveResetTokens(ctx context.Context, userID string) (int, error) {
	query := `
		SELECT COUNT(*) 
		FROM password_reset_tokens 
		WHERE user_id = $1 AND is_used = false AND expires_at > NOW()`

	var count int
	err := r.db.GetContext(ctx, &count, query, userID)
	if err != nil {
		return 0, errx.Wrap(err, "failed to count active reset tokens", errx.TypeInternal).
			WithDetail("user_id", userID)
	}

	return count, nil
}

// HasRecentResetToken verifica si un usuario tiene un token reciente (anti-spam)
func (r *PostgresPasswordResetRepository) HasRecentResetToken(ctx context.Context, userID string, withinMinutes int) (bool, error) {
	query := `
		SELECT EXISTS(
			SELECT 1 
			FROM password_reset_tokens 
			WHERE user_id = $1 
			AND created_at > NOW() - INTERVAL '%d minutes'
			AND is_used = false
		)`

	var exists bool
	err := r.db.GetContext(ctx, &exists, query, userID, withinMinutes)
	if err != nil {
		return false, errx.Wrap(err, "failed to check recent reset token", errx.TypeInternal).
			WithDetail("user_id", userID)
	}

	return exists, nil
}
package authinfra

import (
	"github.com/Abraxas-365/relay/iam/user"
	"golang.org/x/crypto/bcrypt"
)

// BcryptPasswordService implementaci√≥n del servicio de contrase√±as usando bcrypt
type BcryptPasswordService struct {
	cost int
}

// NewBcryptPasswordService crea una nueva instancia del servicio de contrase√±as
func NewBcryptPasswordService() user.PasswordService {
	return &BcryptPasswordService{
		cost: bcrypt.DefaultCost,
	}
}

// HashPassword hashea una contrase√±a
func (s *BcryptPasswordService) HashPassword(password string) (string, error) {
	hashedBytes, err := bcrypt.GenerateFromPassword([]byte(password), s.cost)
	if err != nil {
		return "", err
	}
	return string(hashedBytes), nil
}

// VerifyPassword verifica una contrase√±a contra su hash
func (s *BcryptPasswordService) VerifyPassword(hashedPassword, password string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
	return err == nil
}
package authinfra

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/Abraxas-365/relay/iam/auth"
	"github.com/go-redis/redis/v8"
	"github.com/google/uuid"
)

// RedisStateManager implementaci√≥n en Redis del StateManager
type RedisStateManager struct {
	client *redis.Client
	ttl    time.Duration
}

// NewRedisStateManager crea un nuevo state manager con Redis
func NewRedisStateManager(client *redis.Client) auth.StateManager {
	return &RedisStateManager{
		client: client,
		ttl:    10 * time.Minute, // Estados v√°lidos por 10 minutos
	}
}

// GenerateState genera un nuevo estado OAuth
func (sm *RedisStateManager) GenerateState() string {
	return uuid.NewString()
}

// StoreState almacena un estado con sus datos asociados
func (sm *RedisStateManager) StoreState(ctx context.Context, state string, data map[string]any) error {
	jsonData, err := json.Marshal(data)
	if err != nil {
		return fmt.Errorf("failed to marshal state data: %w", err)
	}

	key := fmt.Sprintf("oauth_state:%s", state)
	err = sm.client.Set(ctx, key, jsonData, sm.ttl).Err()
	if err != nil {
		return fmt.Errorf("failed to store state in Redis: %w", err)
	}

	return nil
}

// ValidateState valida si un estado es v√°lido
func (sm *RedisStateManager) ValidateState(state string) bool {
	ctx := context.Background()
	key := fmt.Sprintf("oauth_state:%s", state)

	exists, err := sm.client.Exists(ctx, key).Result()
	if err != nil {
		return false
	}

	return exists == 1
}

// GetStateData obtiene los datos asociados a un estado
func (sm *RedisStateManager) GetStateData(ctx context.Context, state string) (map[string]any, error) {
	key := fmt.Sprintf("oauth_state:%s", state)

	// Obtener y eliminar el estado (one-time use)
	jsonData, err := sm.client.GetDel(ctx, key).Result()
	if err != nil {
		if err == redis.Nil {
			return nil, auth.ErrInvalidState()
		}
		return nil, fmt.Errorf("failed to get state from Redis: %w", err)
	}

	var data map[string]any
	if err := json.Unmarshal([]byte(jsonData), &data); err != nil {
		return nil, fmt.Errorf("failed to unmarshal state data: %w", err)
	}

	return data, nil
}
package authinfra

import (
	"context"
	"database/sql"

	"github.com/Abraxas-365/craftable/errx"
	"github.com/Abraxas-365/relay/iam/auth"
	"github.com/Abraxas-365/relay/pkg/kernel"
	"github.com/jmoiron/sqlx"
)

// PostgresTokenRepository implementaci√≥n de PostgreSQL para TokenRepository
type PostgresTokenRepository struct {
	db *sqlx.DB
}

// NewPostgresTokenRepository crea una nueva instancia del repositorio de tokens
func NewPostgresTokenRepository(db *sqlx.DB) auth.TokenRepository {
	return &PostgresTokenRepository{
		db: db,
	}
}

// SaveRefreshToken guarda un nuevo refresh token
func (r *PostgresTokenRepository) SaveRefreshToken(ctx context.Context, token auth.RefreshToken) error {
	query := `
		INSERT INTO refresh_tokens (
			id, token, user_id, tenant_id, expires_at, created_at, is_revoked
		) VALUES (
			:id, :token, :user_id, :tenant_id, :expires_at, :created_at, :is_revoked
		)`

	_, err := r.db.NamedExecContext(ctx, query, token)
	if err != nil {
		return errx.Wrap(err, "failed to save refresh token", errx.TypeInternal).
			WithDetail("user_id", token.UserID.String())
	}

	return nil
}

// FindRefreshToken busca un refresh token por su valor
func (r *PostgresTokenRepository) FindRefreshToken(ctx context.Context, tokenValue string) (*auth.RefreshToken, error) {
	query := `
		SELECT 
			id, token, user_id, tenant_id, expires_at, created_at, is_revoked
		FROM refresh_tokens 
		WHERE token = $1 AND is_revoked = false`

	var token auth.RefreshToken
	err := r.db.GetContext(ctx, &token, query, tokenValue)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, auth.ErrInvalidRefreshToken()
		}
		return nil, errx.Wrap(err, "failed to find refresh token", errx.TypeInternal)
	}

	return &token, nil
}

// RevokeRefreshToken revoca un refresh token
func (r *PostgresTokenRepository) RevokeRefreshToken(ctx context.Context, tokenValue string) error {
	query := `
		UPDATE refresh_tokens 
		SET is_revoked = true 
		WHERE token = $1`

	result, err := r.db.ExecContext(ctx, query, tokenValue)
	if err != nil {
		return errx.Wrap(err, "failed to revoke refresh token", errx.TypeInternal)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return errx.Wrap(err, "failed to get rows affected", errx.TypeInternal)
	}

	if rowsAffected == 0 {
		return auth.ErrInvalidRefreshToken()
	}

	return nil
}

// RevokeAllUserTokens revoca todos los tokens de un usuario
func (r *PostgresTokenRepository) RevokeAllUserTokens(ctx context.Context, userID kernel.UserID) error {
	query := `
		UPDATE refresh_tokens 
		SET is_revoked = true 
		WHERE user_id = $1 AND is_revoked = false`

	_, err := r.db.ExecContext(ctx, query, userID.String())
	if err != nil {
		return errx.Wrap(err, "failed to revoke all user tokens", errx.TypeInternal).
			WithDetail("user_id", userID.String())
	}

	return nil
}

// CleanExpiredTokens elimina tokens expirados (para mantenimiento)
func (r *PostgresTokenRepository) CleanExpiredTokens(ctx context.Context) error {
	query := `
		DELETE FROM refresh_tokens 
		WHERE expires_at < NOW() OR is_revoked = true`

	_, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return errx.Wrap(err, "failed to clean expired tokens", errx.TypeInternal)
	}

	return nil
}

// CountActiveTokens cuenta tokens activos de un usuario (m√©todo adicional √∫til)
func (r *PostgresTokenRepository) CountActiveTokens(ctx context.Context, userID kernel.UserID) (int, error) {
	query := `
		SELECT COUNT(*) 
		FROM refresh_tokens 
		WHERE user_id = $1 AND is_revoked = false AND expires_at > NOW()`

	var count int
	err := r.db.GetContext(ctx, &count, query, userID.String())
	if err != nil {
		return 0, errx.Wrap(err, "failed to count active tokens", errx.TypeInternal).
			WithDetail("user_id", userID.String())
	}

	return count, nil
}

// GetActiveTokensByUser obtiene todos los tokens activos de un usuario
func (r *PostgresTokenRepository) GetActiveTokensByUser(ctx context.Context, userID kernel.UserID) ([]*auth.RefreshToken, error) {
	query := `
		SELECT 
			id, token, user_id, tenant_id, expires_at, created_at, is_revoked
		FROM refresh_tokens 
		WHERE user_id = $1 AND is_revoked = false AND expires_at > NOW()
		ORDER BY created_at DESC`

	var tokens []auth.RefreshToken
	err := r.db.SelectContext(ctx, &tokens, query, userID.String())
	if err != nil {
		return nil, errx.Wrap(err, "failed to get active tokens", errx.TypeInternal).
			WithDetail("user_id", userID.String())
	}

	// Convertir a slice de punteros
	result := make([]*auth.RefreshToken, len(tokens))
	for i := range tokens {
		result[i] = &tokens[i]
	}

	return result, nil
}
package authinfra

import (
	"context"
	"log"
	"time"

	"github.com/Abraxas-365/relay/iam/auth"
)

// CleanupService servicio de limpieza en background
type CleanupService struct {
	tokenRepo         auth.TokenRepository
	sessionRepo       auth.SessionRepository
	passwordResetRepo auth.PasswordResetRepository
	interval          time.Duration
}

// NewCleanupService crea un nuevo servicio de limpieza
func NewCleanupService(
	tokenRepo auth.TokenRepository,
	sessionRepo auth.SessionRepository,
	passwordResetRepo auth.PasswordResetRepository,
) *CleanupService {
	return &CleanupService{
		tokenRepo:         tokenRepo,
		sessionRepo:       sessionRepo,
		passwordResetRepo: passwordResetRepo,
		interval:          1 * time.Hour, // Ejecutar cada hora
	}
}

// Start inicia el servicio de limpieza
func (s *CleanupService) Start(ctx context.Context) {
	ticker := time.NewTicker(s.interval)
	defer ticker.Stop()

	// Ejecutar limpieza inicial
	s.runCleanup(ctx)

	for {
		select {
		case <-ctx.Done():
			log.Println("Cleanup service stopped")
			return
		case <-ticker.C:
			s.runCleanup(ctx)
		}
	}
}

// runCleanup ejecuta las tareas de limpieza
func (s *CleanupService) runCleanup(ctx context.Context) {
	log.Println("Running cleanup tasks...")

	// Limpiar refresh tokens expirados
	if err := s.tokenRepo.CleanExpiredTokens(ctx); err != nil {
		log.Printf("Error cleaning expired tokens: %v", err)
	}

	// Limpiar sesiones expiradas
	if err := s.sessionRepo.CleanExpiredSessions(ctx); err != nil {
		log.Printf("Error cleaning expired sessions: %v", err)
	}

	// Limpiar tokens de reset expirados
	if err := s.passwordResetRepo.CleanExpiredResetTokens(ctx); err != nil {
		log.Printf("Error cleaning expired reset tokens: %v", err)
	}

	log.Println("Cleanup tasks completed")
}
package authinfra

import (
	"context"
	"database/sql"
	"time"

	"github.com/Abraxas-365/craftable/errx"
	"github.com/Abraxas-365/relay/iam/auth"
	"github.com/Abraxas-365/relay/pkg/kernel"
	"github.com/jmoiron/sqlx"
)

// PostgresSessionRepository implementaci√≥n de PostgreSQL para SessionRepository
type PostgresSessionRepository struct {
	db *sqlx.DB
}

// NewPostgresSessionRepository crea una nueva instancia del repositorio de sesiones
func NewPostgresSessionRepository(db *sqlx.DB) auth.SessionRepository {
	return &PostgresSessionRepository{
		db: db,
	}
}

// SaveSession guarda una nueva sesi√≥n de usuario
func (r *PostgresSessionRepository) SaveSession(ctx context.Context, session auth.UserSession) error {
	query := `
		INSERT INTO user_sessions (
			id, user_id, tenant_id, session_token, ip_address, 
			user_agent, expires_at, created_at, last_activity
		) VALUES (
			:id, :user_id, :tenant_id, :session_token, :ip_address,
			:user_agent, :expires_at, :created_at, :last_activity
		)`

	_, err := r.db.NamedExecContext(ctx, query, session)
	if err != nil {
		return errx.Wrap(err, "failed to save session", errx.TypeInternal).
			WithDetail("user_id", session.UserID.String())
	}

	return nil
}

// FindSession busca una sesi√≥n por ID
func (r *PostgresSessionRepository) FindSession(ctx context.Context, sessionID string) (*auth.UserSession, error) {
	query := `
		SELECT 
			id, user_id, tenant_id, session_token, ip_address,
			user_agent, expires_at, created_at, last_activity
		FROM user_sessions 
		WHERE id = $1`

	var session auth.UserSession
	err := r.db.GetContext(ctx, &session, query, sessionID)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, errx.New("session not found", errx.TypeNotFound).
				WithDetail("session_id", sessionID)
		}
		return nil, errx.Wrap(err, "failed to find session", errx.TypeInternal).
			WithDetail("session_id", sessionID)
	}

	return &session, nil
}

// FindSessionByToken busca una sesi√≥n por token
func (r *PostgresSessionRepository) FindSessionByToken(ctx context.Context, sessionToken string) (*auth.UserSession, error) {
	query := `
		SELECT 
			id, user_id, tenant_id, session_token, ip_address,
			user_agent, expires_at, created_at, last_activity
		FROM user_sessions 
		WHERE session_token = $1 AND expires_at > NOW()`

	var session auth.UserSession
	err := r.db.GetContext(ctx, &session, query, sessionToken)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, errx.New("session not found", errx.TypeNotFound)
		}
		return nil, errx.Wrap(err, "failed to find session by token", errx.TypeInternal)
	}

	return &session, nil
}

// FindUserSessions busca todas las sesiones activas de un usuario
func (r *PostgresSessionRepository) FindUserSessions(ctx context.Context, userID kernel.UserID) ([]*auth.UserSession, error) {
	query := `
		SELECT 
			id, user_id, tenant_id, session_token, ip_address,
			user_agent, expires_at, created_at, last_activity
		FROM user_sessions 
		WHERE user_id = $1 AND expires_at > NOW()
		ORDER BY last_activity DESC`

	var sessions []auth.UserSession
	err := r.db.SelectContext(ctx, &sessions, query, userID.String())
	if err != nil {
		return nil, errx.Wrap(err, "failed to find user sessions", errx.TypeInternal).
			WithDetail("user_id", userID.String())
	}

	// Convertir a slice de punteros
	result := make([]*auth.UserSession, len(sessions))
	for i := range sessions {
		result[i] = &sessions[i]
	}

	return result, nil
}

// UpdateSessionActivity actualiza la √∫ltima actividad de una sesi√≥n
func (r *PostgresSessionRepository) UpdateSessionActivity(ctx context.Context, sessionID string) error {
	query := `
		UPDATE user_sessions 
		SET last_activity = NOW() 
		WHERE id = $1 AND expires_at > NOW()`

	result, err := r.db.ExecContext(ctx, query, sessionID)
	if err != nil {
		return errx.Wrap(err, "failed to update session activity", errx.TypeInternal).
			WithDetail("session_id", sessionID)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return errx.Wrap(err, "failed to get rows affected", errx.TypeInternal)
	}

	if rowsAffected == 0 {
		return errx.New("session not found or expired", errx.TypeNotFound).
			WithDetail("session_id", sessionID)
	}

	return nil
}

// RevokeSession revoca una sesi√≥n espec√≠fica
func (r *PostgresSessionRepository) RevokeSession(ctx context.Context, sessionID string) error {
	query := `DELETE FROM user_sessions WHERE id = $1`

	result, err := r.db.ExecContext(ctx, query, sessionID)
	if err != nil {
		return errx.Wrap(err, "failed to revoke session", errx.TypeInternal).
			WithDetail("session_id", sessionID)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return errx.Wrap(err, "failed to get rows affected", errx.TypeInternal)
	}

	if rowsAffected == 0 {
		return errx.New("session not found", errx.TypeNotFound).
			WithDetail("session_id", sessionID)
	}

	return nil
}

// RevokeAllUserSessions revoca todas las sesiones de un usuario
func (r *PostgresSessionRepository) RevokeAllUserSessions(ctx context.Context, userID kernel.UserID) error {
	query := `DELETE FROM user_sessions WHERE user_id = $1`

	_, err := r.db.ExecContext(ctx, query, userID.String())
	if err != nil {
		return errx.Wrap(err, "failed to revoke all user sessions", errx.TypeInternal).
			WithDetail("user_id", userID.String())
	}

	return nil
}

// CleanExpiredSessions elimina sesiones expiradas (para mantenimiento)
func (r *PostgresSessionRepository) CleanExpiredSessions(ctx context.Context) error {
	query := `DELETE FROM user_sessions WHERE expires_at < NOW()`

	_, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return errx.Wrap(err, "failed to clean expired sessions", errx.TypeInternal)
	}

	return nil
}

// ExtendSession extiende la expiraci√≥n de una sesi√≥n
func (r *PostgresSessionRepository) ExtendSession(ctx context.Context, sessionID string, duration time.Duration) error {
	query := `
		UPDATE user_sessions 
		SET expires_at = expires_at + $2::interval,
		    last_activity = NOW()
		WHERE id = $1 AND expires_at > NOW()`

	result, err := r.db.ExecContext(ctx, query, sessionID, duration)
	if err != nil {
		return errx.Wrap(err, "failed to extend session", errx.TypeInternal).
			WithDetail("session_id", sessionID).
			WithDetail("duration", duration.String())
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return errx.Wrap(err, "failed to get rows affected", errx.TypeInternal)
	}

	if rowsAffected == 0 {
		return errx.New("session not found or expired", errx.TypeNotFound).
			WithDetail("session_id", sessionID)
	}

	return nil
}

// CountActiveSessions cuenta las sesiones activas de un usuario
func (r *PostgresSessionRepository) CountActiveSessions(ctx context.Context, userID kernel.UserID) (int, error) {
	query := `
		SELECT COUNT(*) 
		FROM user_sessions 
		WHERE user_id = $1 AND expires_at > NOW()`

	var count int
	err := r.db.GetContext(ctx, &count, query, userID.String())
	if err != nil {
		return 0, errx.Wrap(err, "failed to count active sessions", errx.TypeInternal).
			WithDetail("user_id", userID.String())
	}

	return count, nil
}

// GetSessionsByIPAddress obtiene sesiones por direcci√≥n IP (para seguridad)
func (r *PostgresSessionRepository) GetSessionsByIPAddress(ctx context.Context, ipAddress string) ([]*auth.UserSession, error) {
	query := `
		SELECT 
			id, user_id, tenant_id, session_token, ip_address,
			user_agent, expires_at, created_at, last_activity
		FROM user_sessions 
		WHERE ip_address = $1 AND expires_at > NOW()
		ORDER BY created_at DESC`

	var sessions []auth.UserSession
	err := r.db.SelectContext(ctx, &sessions, query, ipAddress)
	if err != nil {
		return nil, errx.Wrap(err, "failed to get sessions by IP", errx.TypeInternal).
			WithDetail("ip_address", ipAddress)
	}

	// Convertir a slice de punteros
	result := make([]*auth.UserSession, len(sessions))
	for i := range sessions {
		result[i] = &sessions[i]
	}

	return result, nil
}
package auth

import (
	"fmt"
	"time"

	"github.com/Abraxas-365/relay/pkg/kernel"
	"github.com/golang-jwt/jwt/v5"
)

// JWTService implementaci√≥n del TokenService usando JWT
type JWTService struct {
	secretKey       []byte
	accessTokenTTL  time.Duration
	refreshTokenTTL time.Duration
	issuer          string
}

// NewJWTService crea una nueva instancia del servicio JWT
func NewJWTService(secretKey string, accessTokenTTL, refreshTokenTTL time.Duration, issuer string) *JWTService {
	if accessTokenTTL == 0 {
		accessTokenTTL = 15 * time.Minute // Por defecto 15 minutos
	}
	if refreshTokenTTL == 0 {
		refreshTokenTTL = 7 * 24 * time.Hour // Por defecto 7 d√≠as
	}
	if issuer == "" {
		issuer = "facturamelo"
	}

	return &JWTService{
		secretKey:       []byte(secretKey),
		accessTokenTTL:  accessTokenTTL,
		refreshTokenTTL: refreshTokenTTL,
		issuer:          issuer,
	}
}

// Claims personalizados para JWT
type JWTClaims struct {
	UserID   kernel.UserID   `json:"user_id"`
	TenantID kernel.TenantID `json:"tenant_id"`
	Email    string          `json:"email"`
	Name     string          `json:"name"`
	IsAdmin  bool            `json:"is_admin"`
	jwt.RegisteredClaims
}

// GenerateAccessToken genera un token de acceso JWT
func (j *JWTService) GenerateAccessToken(userID kernel.UserID, tenantID kernel.TenantID, claims map[string]any) (string, error) {
	now := time.Now()

	// Extraer claims adicionales
	email, _ := claims["email"].(string)
	name, _ := claims["name"].(string)
	isAdmin, _ := claims["is_admin"].(bool)

	jwtClaims := JWTClaims{
		UserID:   userID,
		TenantID: tenantID,
		Email:    email,
		Name:     name,
		IsAdmin:  isAdmin,
		RegisteredClaims: jwt.RegisteredClaims{
			Issuer:    j.issuer,
			Subject:   userID.String(),
			Audience:  []string{"facturamelo-api"},
			ExpiresAt: jwt.NewNumericDate(now.Add(j.accessTokenTTL)),
			NotBefore: jwt.NewNumericDate(now),
			IssuedAt:  jwt.NewNumericDate(now),
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwtClaims)

	tokenString, err := token.SignedString(j.secretKey)
	if err != nil {
		return "", ErrTokenGenerationFailed().WithDetail("error", err.Error())
	}

	return tokenString, nil
}

// ValidateAccessToken valida y decodifica un token de acceso
func (j *JWTService) ValidateAccessToken(tokenString string) (*TokenClaims, error) {
	token, err := jwt.ParseWithClaims(tokenString, &JWTClaims{}, func(token *jwt.Token) (any, error) {
		// Verificar el m√©todo de firma
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		return j.secretKey, nil
	})

	if err != nil {
		return nil, ErrTokenValidationFailed().WithDetail("error", err.Error())
	}

	if !token.Valid {
		return nil, ErrTokenValidationFailed().WithDetail("error", "token is invalid")
	}

	jwtClaims, ok := token.Claims.(*JWTClaims)
	if !ok {
		return nil, ErrTokenValidationFailed().WithDetail("error", "invalid claims type")
	}

	return &TokenClaims{
		UserID:    jwtClaims.UserID,
		TenantID:  jwtClaims.TenantID,
		Email:     jwtClaims.Email,
		Name:      jwtClaims.Name,
		IsAdmin:   jwtClaims.IsAdmin,
		IssuedAt:  jwtClaims.IssuedAt.Time,
		ExpiresAt: jwtClaims.ExpiresAt.Time,
	}, nil
}

// GenerateRefreshToken genera un token de refresh simple
func (j *JWTService) GenerateRefreshToken(userID kernel.UserID) (string, error) {
	now := time.Now()

	claims := jwt.RegisteredClaims{
		Issuer:    j.issuer,
		Subject:   userID.String(),
		Audience:  []string{"facturamelo-refresh"},
		ExpiresAt: jwt.NewNumericDate(now.Add(j.refreshTokenTTL)),
		NotBefore: jwt.NewNumericDate(now),
		IssuedAt:  jwt.NewNumericDate(now),
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	tokenString, err := token.SignedString(j.secretKey)
	if err != nil {
		return "", ErrTokenGenerationFailed().WithDetail("error", err.Error())
	}

	return tokenString, nil
}
// pkg/auth/config.go
package auth

import (
	"net/http"
	"time"

	"github.com/Abraxas-365/craftable/errx"
)

// Config configuraci√≥n completa del m√≥dulo de autenticaci√≥n
type Config struct {
	JWT   JWTConfig    `json:"jwt" yaml:"jwt"`
	OAuth OAuthConfigs `json:"oauth" yaml:"oauth"`
}

// JWTConfig configuraci√≥n para JWT
type JWTConfig struct {
	SecretKey       string        `json:"secret_key" yaml:"secret_key"`
	AccessTokenTTL  time.Duration `json:"access_token_ttl" yaml:"access_token_ttl"`
	RefreshTokenTTL time.Duration `json:"refresh_token_ttl" yaml:"refresh_token_ttl"`
	Issuer          string        `json:"issuer" yaml:"issuer"`
}

// OAuthConfig configuraci√≥n base para OAuth
type OAuthConfig struct {
	ClientID     string   `json:"client_id"`
	ClientSecret string   `json:"client_secret"`
	RedirectURL  string   `json:"redirect_url"`
	Scopes       []string `json:"scopes"`
}

// OAuthConfigs configuraciones para todos los proveedores OAuth
type OAuthConfigs struct {
	Google    OAuthConfig `json:"google" yaml:"google"`
	Microsoft OAuthConfig `json:"microsoft" yaml:"microsoft"`
}

// DefaultConfig retorna configuraci√≥n por defecto
func DefaultConfig() Config {
	return Config{
		JWT: JWTConfig{
			AccessTokenTTL:  15 * time.Minute,
			RefreshTokenTTL: 7 * 24 * time.Hour,
			Issuer:          "facturamelo",
		},
		OAuth: OAuthConfigs{
			Google: OAuthConfig{
				Scopes: []string{"openid", "email", "profile"},
			},
			Microsoft: OAuthConfig{
				Scopes: []string{"openid", "email", "profile", "User.Read"},
			},
		},
	}
}

// Validate valida la configuraci√≥n
func (c *Config) Validate() error {
	if c.JWT.SecretKey == "" {
		return ErrMissingJWTSecret()
	}

	if len(c.JWT.SecretKey) < 32 {
		return ErrWeakJWTSecret()
	}

	if c.JWT.AccessTokenTTL <= 0 {
		return ErrInvalidTokenTTL().WithDetail("token_type", "access")
	}

	if c.JWT.RefreshTokenTTL <= 0 {
		return ErrInvalidTokenTTL().WithDetail("token_type", "refresh")
	}

	// Validar configuraci√≥n OAuth si est√° presente
	if err := c.OAuth.Google.Validate("Google"); err != nil {
		return err
	}

	if err := c.OAuth.Microsoft.Validate("Microsoft"); err != nil {
		return err
	}

	return nil
}

// Validate valida la configuraci√≥n OAuth
func (oc *OAuthConfig) Validate(provider string) error {
	// Solo validar si hay configuraci√≥n (permite proveedores opcionales)
	if oc.ClientID == "" && oc.ClientSecret == "" {
		return nil // Proveedor no configurado, est√° bien
	}

	if oc.ClientID == "" {
		return ErrMissingOAuthClientID().WithDetail("provider", provider)
	}

	if oc.ClientSecret == "" {
		return ErrMissingOAuthClientSecret().WithDetail("provider", provider)
	}

	if oc.RedirectURL == "" {
		return ErrMissingOAuthRedirectURL().WithDetail("provider", provider)
	}

	if len(oc.Scopes) == 0 {
		return ErrMissingOAuthScopes().WithDetail("provider", provider)
	}

	return nil
}

// IsEnabled verifica si el proveedor OAuth est√° habilitado
func (oc *OAuthConfig) IsEnabled() bool {
	return oc.ClientID != "" && oc.ClientSecret != ""
}

// GetEnabledProviders retorna una lista de proveedores OAuth habilitados
func (oc *OAuthConfigs) GetEnabledProviders() []string {
	var enabled []string

	if oc.Google.IsEnabled() {
		enabled = append(enabled, "google")
	}

	if oc.Microsoft.IsEnabled() {
		enabled = append(enabled, "microsoft")
	}

	return enabled
}

// Config error codes
var (
	CodeMissingJWTSecret         = ErrRegistry.Register("MISSING_JWT_SECRET", errx.TypeValidation, http.StatusBadRequest, "JWT secret key is required")
	CodeWeakJWTSecret            = ErrRegistry.Register("WEAK_JWT_SECRET", errx.TypeValidation, http.StatusBadRequest, "JWT secret key must be at least 32 characters")
	CodeInvalidTokenTTL          = ErrRegistry.Register("INVALID_TOKEN_TTL", errx.TypeValidation, http.StatusBadRequest, "Invalid token TTL")
	CodeMissingOAuthClientID     = ErrRegistry.Register("MISSING_OAUTH_CLIENT_ID", errx.TypeValidation, http.StatusBadRequest, "OAuth client ID is required")
	CodeMissingOAuthClientSecret = ErrRegistry.Register("MISSING_OAUTH_CLIENT_SECRET", errx.TypeValidation, http.StatusBadRequest, "OAuth client secret is required")
	CodeMissingOAuthRedirectURL  = ErrRegistry.Register("MISSING_OAUTH_REDIRECT_URL", errx.TypeValidation, http.StatusBadRequest, "OAuth redirect URL is required")
	CodeMissingOAuthScopes       = ErrRegistry.Register("MISSING_OAUTH_SCOPES", errx.TypeValidation, http.StatusBadRequest, "OAuth scopes are required")
)

// Helper functions para crear errores de configuraci√≥n
func ErrMissingJWTSecret() *errx.Error {
	return ErrRegistry.New(CodeMissingJWTSecret)
}

func ErrWeakJWTSecret() *errx.Error {
	return ErrRegistry.New(CodeWeakJWTSecret)
}

func ErrInvalidTokenTTL() *errx.Error {
	return ErrRegistry.New(CodeInvalidTokenTTL)
}

func ErrMissingOAuthClientID() *errx.Error {
	return ErrRegistry.New(CodeMissingOAuthClientID)
}

func ErrMissingOAuthClientSecret() *errx.Error {
	return ErrRegistry.New(CodeMissingOAuthClientSecret)
}

func ErrMissingOAuthRedirectURL() *errx.Error {
	return ErrRegistry.New(CodeMissingOAuthRedirectURL)
}

func ErrMissingOAuthScopes() *errx.Error {
	return ErrRegistry.New(CodeMissingOAuthScopes)
}
package auth

import (
	"net/http"
	"time"

	"github.com/Abraxas-365/craftable/errx"
	"github.com/Abraxas-365/relay/pkg/kernel"
)

// ============================================================================
// Token Types
// ============================================================================

// RefreshToken representa un token de refresh
type RefreshToken struct {
	ID        string          `db:"id" json:"id"`
	Token     string          `db:"token" json:"token"`
	UserID    kernel.UserID   `db:"user_id" json:"user_id"`
	TenantID  kernel.TenantID `db:"tenant_id" json:"tenant_id"`
	ExpiresAt time.Time       `db:"expires_at" json:"expires_at"`
	CreatedAt time.Time       `db:"created_at" json:"created_at"`
	IsRevoked bool            `db:"is_revoked" json:"is_revoked"`
}

// UserSession representa una sesi√≥n de usuario
type UserSession struct {
	ID           string          `db:"id" json:"id"`
	UserID       kernel.UserID   `db:"user_id" json:"user_id"`
	TenantID     kernel.TenantID `db:"tenant_id" json:"tenant_id"`
	SessionToken string          `db:"session_token" json:"session_token"`
	IPAddress    string          `db:"ip_address" json:"ip_address"`
	UserAgent    string          `db:"user_agent" json:"user_agent"`
	ExpiresAt    time.Time       `db:"expires_at" json:"expires_at"`
	CreatedAt    time.Time       `db:"created_at" json:"created_at"`
	LastActivity time.Time       `db:"last_activity" json:"last_activity"`
}

// PasswordResetToken representa un token para resetear contrase√±a
type PasswordResetToken struct {
	ID        string        `db:"id" json:"id"`
	Token     string        `db:"token" json:"token"`
	UserID    kernel.UserID `db:"user_id" json:"user_id"`
	ExpiresAt time.Time     `db:"expires_at" json:"expires_at"`
	CreatedAt time.Time     `db:"created_at" json:"created_at"`
	IsUsed    bool          `db:"is_used" json:"is_used"`
}

// TokenClaims representa los claims de un JWT
type TokenClaims struct {
	UserID    kernel.UserID   `json:"user_id"`
	TenantID  kernel.TenantID `json:"tenant_id"`
	Email     string          `json:"email"`
	Name      string          `json:"name"`
	IsAdmin   bool            `json:"is_admin"`
	IssuedAt  time.Time       `json:"iat"`
	ExpiresAt time.Time       `json:"exp"`
}

// ============================================================================
// Domain Methods
// ============================================================================

// IsExpired verifica si el refresh token ha expirado
func (r *RefreshToken) IsExpired() bool {
	return time.Now().After(r.ExpiresAt)
}

// IsValid verifica si el refresh token es v√°lido
func (r *RefreshToken) IsValid() bool {
	return !r.IsRevoked && !r.IsExpired()
}

// IsExpired verifica si la sesi√≥n ha expirado
func (s *UserSession) IsExpired() bool {
	return time.Now().After(s.ExpiresAt)
}

// UpdateActivity actualiza la √∫ltima actividad de la sesi√≥n
func (s *UserSession) UpdateActivity() {
	s.LastActivity = time.Now()
}

// IsExpired verifica si el token de reset ha expirado
func (p *PasswordResetToken) IsExpired() bool {
	return time.Now().After(p.ExpiresAt)
}

// IsValid verifica si el token de reset es v√°lido
func (p *PasswordResetToken) IsValid() bool {
	return !p.IsUsed && !p.IsExpired()
}

// MarkAsUsed marca el token como usado
func (p *PasswordResetToken) MarkAsUsed() {
	p.IsUsed = true
}

// ============================================================================
// Error Registry - Errores espec√≠ficos de Auth
// ============================================================================

var ErrRegistry = errx.NewRegistry("AUTH")

// C√≥digos de error
var (
	CodeInvalidRefreshToken      = ErrRegistry.Register("INVALID_REFRESH_TOKEN", errx.TypeAuthorization, http.StatusUnauthorized, "Refresh token inv√°lido")
	CodeExpiredRefreshToken      = ErrRegistry.Register("EXPIRED_REFRESH_TOKEN", errx.TypeAuthorization, http.StatusUnauthorized, "Refresh token expirado")
	CodeInvalidOAuthProvider     = ErrRegistry.Register("INVALID_OAUTH_PROVIDER", errx.TypeValidation, http.StatusBadRequest, "Proveedor OAuth no v√°lido")
	CodeOAuthAuthorizationFailed = ErrRegistry.Register("OAUTH_AUTHORIZATION_FAILED", errx.TypeExternal, http.StatusBadRequest, "Fall√≥ la autorizaci√≥n OAuth")
	CodeInvalidState             = ErrRegistry.Register("INVALID_STATE", errx.TypeValidation, http.StatusBadRequest, "Estado OAuth inv√°lido")
	CodeTokenGenerationFailed    = ErrRegistry.Register("TOKEN_GENERATION_FAILED", errx.TypeInternal, http.StatusInternalServerError, "Error al generar token")
	CodeTokenValidationFailed    = ErrRegistry.Register("TOKEN_VALIDATION_FAILED", errx.TypeAuthorization, http.StatusUnauthorized, "Error al validar token")
	CodeOAuthCallbackError       = ErrRegistry.Register("OAUTH_CALLBACK_ERROR", errx.TypeExternal, http.StatusBadRequest, "Error en el callback OAuth")
)

// Helper functions para crear errores
func ErrInvalidRefreshToken() *errx.Error {
	return ErrRegistry.New(CodeInvalidRefreshToken)
}

func ErrExpiredRefreshToken() *errx.Error {
	return ErrRegistry.New(CodeExpiredRefreshToken)
}

func ErrInvalidOAuthProvider() *errx.Error {
	return ErrRegistry.New(CodeInvalidOAuthProvider)
}

func ErrOAuthAuthorizationFailed() *errx.Error {
	return ErrRegistry.New(CodeOAuthAuthorizationFailed)
}

func ErrInvalidState() *errx.Error {
	return ErrRegistry.New(CodeInvalidState)
}

func ErrTokenGenerationFailed() *errx.Error {
	return ErrRegistry.New(CodeTokenGenerationFailed)
}

func ErrTokenValidationFailed() *errx.Error {
	return ErrRegistry.New(CodeTokenValidationFailed)
}

func ErrOAuthCallbackError() *errx.Error {
	return ErrRegistry.New(CodeOAuthCallbackError)
}
package auth

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/Abraxas-365/craftable/errx"
	"github.com/Abraxas-365/relay/iam"
)

const (
	MicrosoftAuthURL     = "https://login.microsoftonline.com/common/oauth2/v2.0/authorize"
	MicrosoftTokenURL    = "https://login.microsoftonline.com/common/oauth2/v2.0/token"
	MicrosoftUserInfoURL = "https://graph.microsoft.com/v1.0/me"
)

// MicrosoftOAuthService implementaci√≥n del servicio OAuth para Microsoft
type MicrosoftOAuthService struct {
	config       OAuthConfig
	httpClient   *http.Client
	stateManager StateManager
}

// NewMicrosoftOAuthService crea una nueva instancia del servicio Microsoft OAuth
func NewMicrosoftOAuthService(config OAuthConfig, stateManager StateManager) *MicrosoftOAuthService {
	if len(config.Scopes) == 0 {
		config.Scopes = []string{"openid", "email", "profile", "User.Read"}
	}

	return &MicrosoftOAuthService{
		config:       config,
		httpClient:   &http.Client{Timeout: 30 * time.Second},
		stateManager: stateManager,
	}
}

// GetProvider retorna el proveedor OAuth
func (m *MicrosoftOAuthService) GetProvider() iam.OAuthProvider {
	return iam.OAuthProviderMicrosoft
}

// GetAuthURL genera la URL de autorizaci√≥n de Microsoft
func (m *MicrosoftOAuthService) GetAuthURL(state string) string {
	params := url.Values{
		"client_id":     {m.config.ClientID},
		"redirect_uri":  {m.config.RedirectURL},
		"scope":         {strings.Join(m.config.Scopes, " ")},
		"response_type": {"code"},
		"state":         {state},
		"response_mode": {"query"},
	}

	return fmt.Sprintf("%s?%s", MicrosoftAuthURL, params.Encode())
}

// ValidateState valida el estado OAuth
func (m *MicrosoftOAuthService) ValidateState(state string) bool {
	return m.stateManager.ValidateState(state)
}

// ExchangeToken intercambia el c√≥digo de autorizaci√≥n por tokens
func (m *MicrosoftOAuthService) ExchangeToken(ctx context.Context, code string) (*OAuthTokenResponse, error) {
	data := url.Values{
		"client_id":     {m.config.ClientID},
		"client_secret": {m.config.ClientSecret},
		"code":          {code},
		"grant_type":    {"authorization_code"},
		"redirect_uri":  {m.config.RedirectURL},
	}

	req, err := http.NewRequestWithContext(ctx, "POST", MicrosoftTokenURL, strings.NewReader(data.Encode()))
	if err != nil {
		return nil, errx.Wrap(err, "failed to create token request", errx.TypeInternal)
	}

	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	resp, err := m.httpClient.Do(req)
	if err != nil {
		return nil, errx.Wrap(err, "failed to exchange token", errx.TypeExternal)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, ErrOAuthAuthorizationFailed().
			WithDetail("status_code", resp.StatusCode).
			WithDetail("provider", "microsoft")
	}

	var tokenResp OAuthTokenResponse
	if err := json.NewDecoder(resp.Body).Decode(&tokenResp); err != nil {
		return nil, errx.Wrap(err, "failed to decode token response", errx.TypeExternal)
	}

	return &tokenResp, nil
}

// GetUserInfo obtiene la informaci√≥n del usuario desde Microsoft
func (m *MicrosoftOAuthService) GetUserInfo(ctx context.Context, accessToken string) (*OAuthUserInfo, error) {
	req, err := http.NewRequestWithContext(ctx, "GET", MicrosoftUserInfoURL, nil)
	if err != nil {
		return nil, errx.Wrap(err, "failed to create user info request", errx.TypeInternal)
	}

	req.Header.Set("Authorization", "Bearer "+accessToken)

	resp, err := m.httpClient.Do(req)
	if err != nil {
		return nil, errx.Wrap(err, "failed to get user info", errx.TypeExternal)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, ErrOAuthAuthorizationFailed().
			WithDetail("status_code", resp.StatusCode).
			WithDetail("provider", "microsoft").
			WithDetail("endpoint", "userinfo")
	}

	var msUser struct {
		ID                string `json:"id"`
		Mail              string `json:"mail"`
		UserPrincipalName string `json:"userPrincipalName"`
		DisplayName       string `json:"displayName"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&msUser); err != nil {
		return nil, errx.Wrap(err, "failed to decode user info", errx.TypeExternal)
	}

	// Microsoft puede usar mail o userPrincipalName como email
	email := msUser.Mail
	if email == "" {
		email = msUser.UserPrincipalName
	}

	return &OAuthUserInfo{
		ID:            msUser.ID,
		Email:         email,
		Name:          msUser.DisplayName,
		Picture:       "",   // Microsoft Graph requiere endpoint separado para foto
		EmailVerified: true, // Asumimos verificado si viene de Microsoft
	}, nil
}
package auth

import (
	"github.com/Abraxas-365/relay/pkg/kernel"
	"github.com/gofiber/fiber/v2"
)

// ProtectedRoutes helper para configurar rutas protegidas
type ProtectedRoutes struct {
	authMiddleware *AuthMiddleware
}

// NewProtectedRoutes crea un nuevo helper para rutas protegidas
func NewProtectedRoutes(authMiddleware *AuthMiddleware) *ProtectedRoutes {
	return &ProtectedRoutes{
		authMiddleware: authMiddleware,
	}
}

// SetupProtectedRoutes configura rutas protegidas
func (pr *ProtectedRoutes) SetupProtectedRoutes(app *fiber.App) {
	// Rutas p√∫blicas
	public := app.Group("/api/public")
	public.Get("/health", func(c *fiber.Ctx) error {
		return c.JSON(fiber.Map{"status": "OK"})
	})

	// Rutas protegidas (requieren autenticaci√≥n)
	protected := app.Group("/api")
	protected.Use(pr.authMiddleware.Authenticate())

	// Rutas espec√≠ficas de usuario autenticado
	protected.Get("/me", func(c *fiber.Ctx) error {
		authContext, _ := GetAuthContext(c)
		return c.JSON(fiber.Map{
			"user_id":   authContext.UserID,
			"tenant_id": authContext.TenantID,
			"email":     authContext.Email,
			"name":      authContext.Name,
			"is_admin":  authContext.IsAdmin,
		})
	})

	// Rutas de administraci√≥n (requieren admin)
	admin := protected.Group("/admin")
	admin.Use(pr.authMiddleware.RequireAdmin())

	admin.Get("/users", func(c *fiber.Ctx) error {
		return c.JSON(fiber.Map{"message": "Admin users endpoint"})
	})

	admin.Get("/tenants", func(c *fiber.Ctx) error {
		return c.JSON(fiber.Map{"message": "Admin tenants endpoint"})
	})

	// Rutas por tenant
	tenant := protected.Group("/tenant/:tenantId")
	tenant.Use(pr.ValidateTenantAccess())

	tenant.Get("/dashboard", func(c *fiber.Ctx) error {
		return c.JSON(fiber.Map{"message": "Tenant dashboard"})
	})
}

// ValidateTenantAccess middleware para validar acceso a tenant espec√≠fico
func (pr *ProtectedRoutes) ValidateTenantAccess() fiber.Handler {
	return func(c *fiber.Ctx) error {
		tenantIDParam := c.Params("tenantId")
		authContext, ok := GetAuthContext(c)
		if !ok {
			return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
				"error": "Authentication required",
			})
		}

		// Verificar que el usuario tenga acceso al tenant
		if authContext.TenantID.String() != tenantIDParam && !authContext.IsAdmin {
			return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
				"error": "Access denied to this tenant",
			})
		}

		// Agregar tenant ID al contexto
		c.Locals("tenant_id", kernel.NewTenantID(tenantIDParam))
		return c.Next()
	}
}

func ValidateTenantAccess() fiber.Handler {
	return func(c *fiber.Ctx) error {
		tenantIDParam := c.Params("tenantId")
		authContext, ok := GetAuthContext(c)
		if !ok {
			return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
				"error": "Authentication required",
			})
		}

		// Verificar que el usuario tenga acceso al tenant
		// Los admins pueden acceder a cualquier tenant
		if authContext.TenantID.String() != tenantIDParam && !authContext.IsAdmin {
			return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
				"error": "Access denied to this tenant",
			})
		}

		// Agregar tenant ID al contexto para uso en handlers
		c.Locals("tenant_id", kernel.NewTenantID(tenantIDParam))
		return c.Next()
	}
}

// GetTenantID obtiene el tenant ID del contexto
// Helper function para usar en los handlers
func GetTenantID(c *fiber.Ctx) (kernel.TenantID, bool) {
	tenantID, ok := c.Locals("tenant_id").(kernel.TenantID)
	return tenantID, ok
}

func GetUserID(c *fiber.Ctx) (kernel.UserID, bool) {
	userID, ok := c.Locals("user_id").(kernel.UserID)
	return userID, ok
}
package auth

import (
	"context"

	"github.com/Abraxas-365/relay/pkg/kernel"
)

// TokenRepository define el contrato para la persistencia de tokens
type TokenRepository interface {
	SaveRefreshToken(ctx context.Context, token RefreshToken) error
	FindRefreshToken(ctx context.Context, tokenValue string) (*RefreshToken, error)
	RevokeRefreshToken(ctx context.Context, tokenValue string) error
	RevokeAllUserTokens(ctx context.Context, userID kernel.UserID) error
	CleanExpiredTokens(ctx context.Context) error
}

// SessionRepository define el contrato para la persistencia de sesiones
type SessionRepository interface {
	SaveSession(ctx context.Context, session UserSession) error
	FindSession(ctx context.Context, sessionID string) (*UserSession, error)
	FindUserSessions(ctx context.Context, userID kernel.UserID) ([]*UserSession, error)
	UpdateSessionActivity(ctx context.Context, sessionID string) error
	RevokeSession(ctx context.Context, sessionID string) error
	RevokeAllUserSessions(ctx context.Context, userID kernel.UserID) error
	CleanExpiredSessions(ctx context.Context) error
}

// PasswordResetRepository define el contrato para tokens de reset de contrase√±a
type PasswordResetRepository interface {
	SaveResetToken(ctx context.Context, token PasswordResetToken) error
	FindResetToken(ctx context.Context, tokenValue string) (*PasswordResetToken, error)
	ConsumeResetToken(ctx context.Context, tokenValue string) error
	CleanExpiredResetTokens(ctx context.Context) error
}

// TokenService define el contrato para el manejo de tokens JWT
type TokenService interface {
	GenerateAccessToken(userID kernel.UserID, tenantID kernel.TenantID, claims map[string]any) (string, error)
	ValidateAccessToken(token string) (*TokenClaims, error)
	GenerateRefreshToken(userID kernel.UserID) (string, error)
}

// AuditService define el contrato para logs de autenticaci√≥n
type AuditService interface {
	LogLoginAttempt(ctx context.Context, userID kernel.UserID, success bool, ipAddress string) error
	LogPasswordChange(ctx context.Context, userID kernel.UserID, ipAddress string) error
	LogTokenRefresh(ctx context.Context, userID kernel.UserID, ipAddress string) error
}
// pkg/auth/oauth.go
package auth

import (
	"context"

	"github.com/Abraxas-365/relay/iam"
)

// ============================================================================
// OAuth Types
// ============================================================================

// OAuthUserInfo informaci√≥n del usuario desde el proveedor OAuth
type OAuthUserInfo struct {
	ID            string `json:"id"`
	Email         string `json:"email"`
	Name          string `json:"name"`
	Picture       string `json:"picture"`
	EmailVerified bool   `json:"email_verified"`
}

// OAuthService define el contrato para servicios OAuth
type OAuthService interface {
	GetAuthURL(state string) string
	ExchangeToken(ctx context.Context, code string) (*OAuthTokenResponse, error)
	GetUserInfo(ctx context.Context, accessToken string) (*OAuthUserInfo, error)
	ValidateState(state string) bool
	GetProvider() iam.OAuthProvider
}

// OAuthTokenResponse respuesta del intercambio de c√≥digo por token
type OAuthTokenResponse struct {
	AccessToken  string `json:"access_token"`
	TokenType    string `json:"token_type"`
	RefreshToken string `json:"refresh_token,omitempty"`
	ExpiresIn    int    `json:"expires_in"`
}

// StateManager maneja la validaci√≥n de estados OAuth
type StateManager interface {
	GenerateState() string
	ValidateState(state string) bool
	StoreState(ctx context.Context, state string, data map[string]any) error
	GetStateData(ctx context.Context, state string) (map[string]any, error)
}
package auth

import (
	"strings"

	"github.com/Abraxas-365/relay/iam"
	"github.com/Abraxas-365/relay/pkg/kernel"
	"github.com/gofiber/fiber/v2"
)

// AuthMiddleware middleware para autenticaci√≥n JWT con Fiber
type AuthMiddleware struct {
	tokenService TokenService
}

// NewAuthMiddleware crea un nuevo middleware de autenticaci√≥n
func NewAuthMiddleware(tokenService TokenService) *AuthMiddleware {
	return &AuthMiddleware{
		tokenService: tokenService,
	}
}

// Authenticate middleware que valida tokens JWT
func (am *AuthMiddleware) Authenticate() fiber.Handler {
	return func(c *fiber.Ctx) error {
		// Extraer token del header Authorization o cookie de acceso
		authHeader := c.Get("Authorization")
		var token string

		if authHeader != "" {
			// Verificar formato "Bearer <token>"
			parts := strings.SplitN(authHeader, " ", 2)
			if len(parts) == 2 && parts[0] == "Bearer" && parts[1] != "" {
				token = parts[1]
			} else {
				// Fallback: intentar con cookie "access_token" si el header es inv√°lido
				token = c.Cookies("access_token")
				if token == "" {
					return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
						"error": iam.ErrInvalidToken().Error(),
					})
				}
			}
		} else {
			// Fallback: intentar con cookie "access_token"
			token = c.Cookies("access_token")
			if token == "" {
				return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
					"error": iam.ErrUnauthorized().Error(),
				})
			}
		}

		// Validar token
		claims, err := am.tokenService.ValidateAccessToken(token)
		if err != nil {
			return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
				"error": err.Error(),
			})
		}

		// Crear contexto de autenticaci√≥n
		authContext := &kernel.AuthContext{
			UserID:   claims.UserID,
			TenantID: claims.TenantID,
			IsAdmin:  claims.IsAdmin,
			Email:    claims.Email,
			Name:     claims.Name,
		}

		// Agregar al contexto de Fiber
		c.Locals("auth", authContext)

		return c.Next()
	}
}

// RequireAdmin middleware que requiere permisos de administrador
func (am *AuthMiddleware) RequireAdmin() fiber.Handler {
	return func(c *fiber.Ctx) error {
		authContext, ok := c.Locals("auth").(*kernel.AuthContext)
		if !ok || authContext == nil {
			return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
				"error": iam.ErrUnauthorized().Error(),
			})
		}

		if !authContext.IsAdmin {
			return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
				"error": iam.ErrAccessDenied().Error(),
			})
		}

		return c.Next()
	}
}

// RequireTenant middleware que valida acceso al tenant
func (am *AuthMiddleware) RequireTenant(tenantID kernel.TenantID) fiber.Handler {
	return func(c *fiber.Ctx) error {
		authContext, ok := c.Locals("auth").(*kernel.AuthContext)
		if !ok || authContext == nil {
			return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
				"error": iam.ErrUnauthorized().Error(),
			})
		}

		if authContext.TenantID != tenantID {
			return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
				"error": "Access denied for this tenant",
			})
		}

		return c.Next()
	}
}

// GetAuthContext helper para extraer el contexto de autenticaci√≥n de Fiber
func GetAuthContext(c *fiber.Ctx) (*kernel.AuthContext, bool) {
	authContext, ok := c.Locals("auth").(*kernel.AuthContext)
	return authContext, ok && authContext != nil && authContext.IsValid()
}
package auth

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"sync"
	"time"
)

// InMemoryStateManager implementaci√≥n en memoria del StateManager
type InMemoryStateManager struct {
	states map[string]*stateEntry
	mu     sync.RWMutex
}

type stateEntry struct {
	data      map[string]any
	expiresAt time.Time
}

// NewInMemoryStateManager crea un nuevo state manager en memoria
func NewInMemoryStateManager() *InMemoryStateManager {
	sm := &InMemoryStateManager{
		states: make(map[string]*stateEntry),
	}

	// Cleanup goroutine para estados expirados
	go sm.cleanup()

	return sm
}

// GenerateState genera un nuevo estado OAuth
func (sm *InMemoryStateManager) GenerateState() string {
	bytes := make([]byte, 32)
	if _, err := rand.Read(bytes); err != nil {
		// Fallback en caso de error
		return fmt.Sprintf("%d", time.Now().UnixNano())
	}
	return hex.EncodeToString(bytes)
}

// StoreState almacena un estado con sus datos asociados
func (sm *InMemoryStateManager) StoreState(ctx context.Context, state string, data map[string]any) error {
	sm.mu.Lock()
	defer sm.mu.Unlock()

	sm.states[state] = &stateEntry{
		data:      data,
		expiresAt: time.Now().Add(10 * time.Minute), // Estados v√°lidos por 10 minutos
	}

	return nil
}

// ValidateState valida si un estado es v√°lido
func (sm *InMemoryStateManager) ValidateState(state string) bool {
	sm.mu.RLock()
	defer sm.mu.RUnlock()

	entry, exists := sm.states[state]
	if !exists {
		return false
	}

	return time.Now().Before(entry.expiresAt)
}

// GetStateData obtiene los datos asociados a un estado
func (sm *InMemoryStateManager) GetStateData(ctx context.Context, state string) (map[string]any, error) {
	sm.mu.Lock()
	defer sm.mu.Unlock()

	entry, exists := sm.states[state]
	if !exists {
		return nil, ErrInvalidState()
	}

	if time.Now().After(entry.expiresAt) {
		delete(sm.states, state)
		return nil, ErrInvalidState()
	}

	// Eliminar el estado despu√©s de usarlo (one-time use)
	data := entry.data
	delete(sm.states, state)

	return data, nil
}

// cleanup limpia estados expirados periodicamente
func (sm *InMemoryStateManager) cleanup() {
	ticker := time.NewTicker(5 * time.Minute)
	defer ticker.Stop()

	for range ticker.C {
		sm.mu.Lock()
		now := time.Now()
		for state, entry := range sm.states {
			if now.After(entry.expiresAt) {
				delete(sm.states, state)
			}
		}
		sm.mu.Unlock()
	}
}
package tenantinfra
package tenantsrv

import (
	"context"
	"time"

	"github.com/Abraxas-365/craftable/errx"
	"github.com/Abraxas-365/relay/iam/tenant"
	"github.com/Abraxas-365/relay/iam/user"
	"github.com/Abraxas-365/relay/pkg/kernel"
	"github.com/google/uuid"
)

// TenantService proporciona operaciones de negocio para tenants
type TenantService struct {
	tenantRepo       tenant.TenantRepository
	tenantConfigRepo tenant.TenantConfigRepository
	userRepo         user.UserRepository
}

// NewTenantService crea una nueva instancia del servicio de tenants
func NewTenantService(
	tenantRepo tenant.TenantRepository,
	tenantConfigRepo tenant.TenantConfigRepository,
	userRepo user.UserRepository,
) *TenantService {
	return &TenantService{
		tenantRepo:       tenantRepo,
		tenantConfigRepo: tenantConfigRepo,
		userRepo:         userRepo,
	}
}

// CreateTenant crea un nuevo tenant
func (s *TenantService) CreateTenant(ctx context.Context, req tenant.CreateTenantRequest) (*tenant.Tenant, error) {
	// Verificar que no exista un tenant con el mismo RUC
	exists, err := s.tenantRepo.ExistsByRUC(ctx, req.RUC)
	if err != nil {
		return nil, errx.Wrap(err, "failed to check RUC existence", errx.TypeInternal)
	}
	if exists {
		return nil, tenant.ErrTenantAlreadyExists()
	}

	// Crear nuevo tenant
	newTenant := &tenant.Tenant{
		ID:                    kernel.NewTenantID(uuid.NewString()),
		CompanyName:           req.CompanyName,
		RUC:                   req.RUC,
		Status:                tenant.TenantStatusTrial, // Empieza en trial
		SubscriptionPlan:      tenant.PlanTrial,
		MaxUsers:              s.getMaxUsersForPlan(tenant.PlanTrial),
		CurrentUsers:          0,
		TrialExpiresAt:        s.calculateTrialExpiration(),
		SubscriptionExpiresAt: nil,
		CreatedAt:             time.Now(),
		UpdatedAt:             time.Now(),
	}

	// Si se especific√≥ un plan diferente, usar ese
	if req.SubscriptionPlan != "" {
		newTenant.SubscriptionPlan = req.SubscriptionPlan
		newTenant.MaxUsers = s.getMaxUsersForPlan(req.SubscriptionPlan)
		if req.SubscriptionPlan != tenant.PlanTrial {
			newTenant.Status = tenant.TenantStatusActive
			newTenant.SubscriptionExpiresAt = s.calculateSubscriptionExpiration()
		}
	}

	// Guardar tenant
	if err := s.tenantRepo.Save(ctx, *newTenant); err != nil {
		return nil, errx.Wrap(err, "failed to save tenant", errx.TypeInternal)
	}

	return newTenant, nil
}

// GetTenantByID obtiene un tenant por ID
func (s *TenantService) GetTenantByID(ctx context.Context, tenantID kernel.TenantID) (*tenant.TenantResponse, error) {
	tenantEntity, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err != nil {
		return nil, tenant.ErrTenantNotFound()
	}

	// Obtener configuraciones del tenant
	config, err := s.tenantConfigRepo.FindByTenant(ctx, tenantID)
	if err != nil {
		config = make(map[string]string) // Default a empty config
	}

	return &tenant.TenantResponse{
		Tenant: *tenantEntity,
		Config: config,
	}, nil
}

// GetTenantByRUC obtiene un tenant por RUC
func (s *TenantService) GetTenantByRUC(ctx context.Context, ruc string) (*tenant.TenantResponse, error) {
	tenantEntity, err := s.tenantRepo.FindByRUC(ctx, ruc)
	if err != nil {
		return nil, tenant.ErrTenantNotFound()
	}

	// Obtener configuraciones del tenant
	config, err := s.tenantConfigRepo.FindByTenant(ctx, tenantEntity.ID)
	if err != nil {
		config = make(map[string]string)
	}

	return &tenant.TenantResponse{
		Tenant: *tenantEntity,
		Config: config,
	}, nil
}

// GetAllTenants obtiene todos los tenants
func (s *TenantService) GetAllTenants(ctx context.Context) (*tenant.TenantListResponse, error) {
	tenants, err := s.tenantRepo.FindAll(ctx)
	if err != nil {
		return nil, errx.Wrap(err, "failed to get all tenants", errx.TypeInternal)
	}

	var responses []tenant.TenantResponse
	for _, t := range tenants {
		config, _ := s.tenantConfigRepo.FindByTenant(ctx, t.ID)
		if config == nil {
			config = make(map[string]string)
		}
		responses = append(responses, tenant.TenantResponse{
			Tenant: *t,
			Config: config,
		})
	}

	return &tenant.TenantListResponse{
		Tenants: responses,
		Total:   len(responses),
	}, nil
}

// GetActiveTenants obtiene todos los tenants activos
func (s *TenantService) GetActiveTenants(ctx context.Context) (*tenant.TenantListResponse, error) {
	tenants, err := s.tenantRepo.FindActive(ctx)
	if err != nil {
		return nil, errx.Wrap(err, "failed to get active tenants", errx.TypeInternal)
	}

	var responses []tenant.TenantResponse
	for _, t := range tenants {
		config, _ := s.tenantConfigRepo.FindByTenant(ctx, t.ID)
		if config == nil {
			config = make(map[string]string)
		}
		responses = append(responses, tenant.TenantResponse{
			Tenant: *t,
			Config: config,
		})
	}

	return &tenant.TenantListResponse{
		Tenants: responses,
		Total:   len(responses),
	}, nil
}

// UpdateTenant actualiza un tenant
func (s *TenantService) UpdateTenant(ctx context.Context, tenantID kernel.TenantID, req tenant.UpdateTenantRequest) (*tenant.Tenant, error) {
	tenantEntity, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err != nil {
		return nil, tenant.ErrTenantNotFound()
	}

	// Actualizar campos si se proporcionaron
	if req.CompanyName != nil {
		tenantEntity.CompanyName = *req.CompanyName
	}
	if req.Status != nil {
		switch *req.Status {
		case tenant.TenantStatusActive:
			tenantEntity.Activate()
		case tenant.TenantStatusSuspended:
			tenantEntity.Suspend("Updated by admin")
		}
	}

	tenantEntity.UpdatedAt = time.Now()

	// Guardar cambios
	if err := s.tenantRepo.Save(ctx, *tenantEntity); err != nil {
		return nil, errx.Wrap(err, "failed to update tenant", errx.TypeInternal)
	}

	return tenantEntity, nil
}

// SuspendTenant suspende un tenant
func (s *TenantService) SuspendTenant(ctx context.Context, tenantID kernel.TenantID, reason string) error {
	tenantEntity, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err != nil {
		return tenant.ErrTenantNotFound()
	}

	tenantEntity.Suspend(reason)
	return s.tenantRepo.Save(ctx, *tenantEntity)
}

// ActivateTenant activa un tenant
func (s *TenantService) ActivateTenant(ctx context.Context, tenantID kernel.TenantID) error {
	tenantEntity, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err != nil {
		return tenant.ErrTenantNotFound()
	}

	tenantEntity.Activate()
	return s.tenantRepo.Save(ctx, *tenantEntity)
}

// UpgradeTenantPlan mejora el plan de suscripci√≥n de un tenant
func (s *TenantService) UpgradeTenantPlan(ctx context.Context, tenantID kernel.TenantID, newPlan tenant.SubscriptionPlan) error {
	tenantEntity, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err != nil {
		return tenant.ErrTenantNotFound()
	}

	if err := tenantEntity.UpgradePlan(newPlan); err != nil {
		return err
	}

	// Actualizar fecha de expiraci√≥n de suscripci√≥n
	if newPlan != tenant.PlanTrial {
		expirationDate := s.calculateSubscriptionExpiration()
		tenantEntity.SubscriptionExpiresAt = expirationDate
	}

	return s.tenantRepo.Save(ctx, *tenantEntity)
}

// GetTenantUsers obtiene todos los usuarios de un tenant
func (s *TenantService) GetTenantUsers(ctx context.Context, tenantID kernel.TenantID) ([]*user.User, error) {
	// Verificar que el tenant existe
	_, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err != nil {
		return nil, tenant.ErrTenantNotFound()
	}

	users, err := s.userRepo.FindByTenant(ctx, tenantID)
	if err != nil {
		return nil, errx.Wrap(err, "failed to get tenant users", errx.TypeInternal)
	}

	return users, nil
}

// SetTenantConfig establece una configuraci√≥n del tenant
func (s *TenantService) SetTenantConfig(ctx context.Context, tenantID kernel.TenantID, key, value string) error {
	// Verificar que el tenant existe
	_, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err != nil {
		return tenant.ErrTenantNotFound()
	}

	return s.tenantConfigRepo.SaveSetting(ctx, tenantID, key, value)
}

// GetTenantConfig obtiene todas las configuraciones del tenant
func (s *TenantService) GetTenantConfig(ctx context.Context, tenantID kernel.TenantID) (*tenant.TenantConfigResponse, error) {
	// Verificar que el tenant existe
	_, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err != nil {
		return nil, tenant.ErrTenantNotFound()
	}

	config, err := s.tenantConfigRepo.FindByTenant(ctx, tenantID)
	if err != nil {
		return nil, errx.Wrap(err, "failed to get tenant config", errx.TypeInternal)
	}

	return &tenant.TenantConfigResponse{
		TenantID: tenantID,
		Config:   config,
	}, nil
}

// DeleteTenantConfig elimina una configuraci√≥n del tenant
func (s *TenantService) DeleteTenantConfig(ctx context.Context, tenantID kernel.TenantID, key string) error {
	// Verificar que el tenant existe
	_, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err != nil {
		return tenant.ErrTenantNotFound()
	}

	return s.tenantConfigRepo.DeleteSetting(ctx, tenantID, key)
}

// GetTenantStats obtiene estad√≠sticas del tenant
func (s *TenantService) GetTenantStats(ctx context.Context, tenantID kernel.TenantID) (*tenant.TenantStatsResponse, error) {
	tenantEntity, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err != nil {
		return nil, tenant.ErrTenantNotFound()
	}

	// Contar usuarios activos
	users, err := s.userRepo.FindByTenant(ctx, tenantID)
	if err != nil {
		return nil, errx.Wrap(err, "failed to get users for stats", errx.TypeInternal)
	}

	activeUsers := 0
	for _, u := range users {
		if u.IsActive() {
			activeUsers++
		}
	}

	stats := &tenant.TenantStatsResponse{
		TenantID:              tenantEntity.ID,
		TotalUsers:            tenantEntity.CurrentUsers,
		ActiveUsers:           activeUsers,
		MaxUsers:              tenantEntity.MaxUsers,
		UserUtilization:       float64(tenantEntity.CurrentUsers) / float64(tenantEntity.MaxUsers) * 100,
		IsTrialExpired:        tenantEntity.IsTrialExpired(),
		IsSubscriptionExpired: tenantEntity.IsSubscriptionExpired(),
	}

	// Calcular d√≠as hasta expiraci√≥n
	if tenantEntity.SubscriptionExpiresAt != nil && !tenantEntity.IsSubscriptionExpired() {
		days := int(time.Until(*tenantEntity.SubscriptionExpiresAt).Hours() / 24)
		stats.DaysUntilExpiration = &days
	}

	// Determinar estado de suscripci√≥n
	if tenantEntity.IsTrialExpired() {
		stats.SubscriptionStatus = "Trial Expired"
	} else if tenantEntity.IsSubscriptionExpired() {
		stats.SubscriptionStatus = "Subscription Expired"
	} else if tenantEntity.IsTrial() {
		stats.SubscriptionStatus = "Trial Active"
	} else {
		stats.SubscriptionStatus = "Subscription Active"
	}

	return stats, nil
}

// GetTenantUsage obtiene informaci√≥n de uso del tenant
func (s *TenantService) GetTenantUsage(ctx context.Context, tenantID kernel.TenantID) (*tenant.TenantUsageResponse, error) {
	tenantEntity, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err != nil {
		return nil, tenant.ErrTenantNotFound()
	}

	usage := &tenant.TenantUsageResponse{
		TenantID:        tenantEntity.ID,
		CurrentUsers:    tenantEntity.CurrentUsers,
		MaxUsers:        tenantEntity.MaxUsers,
		UsagePercentage: float64(tenantEntity.CurrentUsers) / float64(tenantEntity.MaxUsers) * 100,
		CanAddUsers:     tenantEntity.CanAddUser(),
		RemainingUsers:  tenantEntity.MaxUsers - tenantEntity.CurrentUsers,
	}

	return usage, nil
}

// DeleteTenant elimina un tenant (soft delete recomendado)
func (s *TenantService) DeleteTenant(ctx context.Context, tenantID kernel.TenantID) error {
	// Verificar que el tenant existe
	tenantEntity, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err != nil {
		return tenant.ErrTenantNotFound()
	}

	// Verificar que no tenga usuarios activos
	users, err := s.userRepo.FindByTenant(ctx, tenantID)
	if err == nil && len(users) > 0 {
		return tenant.ErrTenantHasUsers()
	}

	// En lugar de eliminar, suspender permanentemente
	tenantEntity.Suspend("Tenant deleted")
	return s.tenantRepo.Save(ctx, *tenantEntity)
}

// BulkSuspendTenants suspende m√∫ltiples tenants
func (s *TenantService) BulkSuspendTenants(ctx context.Context, tenantIDs []kernel.TenantID, reason string) (*tenant.BulkTenantOperationResponse, error) {
	result := &tenant.BulkTenantOperationResponse{
		Successful: []kernel.TenantID{},
		Failed:     make(map[kernel.TenantID]string),
		Total:      len(tenantIDs),
	}

	for _, tenantID := range tenantIDs {
		if err := s.SuspendTenant(ctx, tenantID, reason); err != nil {
			result.Failed[tenantID] = err.Error()
		} else {
			result.Successful = append(result.Successful, tenantID)
		}
	}

	return result, nil
}

// BulkActivateTenants activa m√∫ltiples tenants
func (s *TenantService) BulkActivateTenants(ctx context.Context, tenantIDs []kernel.TenantID) (*tenant.BulkTenantOperationResponse, error) {
	result := &tenant.BulkTenantOperationResponse{
		Successful: []kernel.TenantID{},
		Failed:     make(map[kernel.TenantID]string),
		Total:      len(tenantIDs),
	}

	for _, tenantID := range tenantIDs {
		if err := s.ActivateTenant(ctx, tenantID); err != nil {
			result.Failed[tenantID] = err.Error()
		} else {
			result.Successful = append(result.Successful, tenantID)
		}
	}

	return result, nil
}

// Helper methods
func (s *TenantService) getMaxUsersForPlan(plan tenant.SubscriptionPlan) int {
	switch plan {
	case tenant.PlanTrial, tenant.PlanBasic:
		return 5
	case tenant.PlanProfessional:
		return 50
	case tenant.PlanEnterprise:
		return 500
	default:
		return 1
	}
}

func (s *TenantService) calculateTrialExpiration() *time.Time {
	expiration := time.Now().AddDate(0, 0, 30) // 30 d√≠as de trial
	return &expiration
}

func (s *TenantService) calculateSubscriptionExpiration() *time.Time {
	expiration := time.Now().AddDate(1, 0, 0) // 1 a√±o
	return &expiration
}
package tenant

import (
	"context"

	"github.com/Abraxas-365/relay/pkg/kernel"
)

// TenantRepository define el contrato para la persistencia de tenants
type TenantRepository interface {
	FindByID(ctx context.Context, id kernel.TenantID) (*Tenant, error)
	FindByRUC(ctx context.Context, ruc string) (*Tenant, error)
	FindAll(ctx context.Context) ([]*Tenant, error)
	FindActive(ctx context.Context) ([]*Tenant, error)
	Save(ctx context.Context, t Tenant) error
	Delete(ctx context.Context, id kernel.TenantID) error
	ExistsByRUC(ctx context.Context, ruc string) (bool, error)
}

// TenantConfigRepository define el contrato para configuraciones del tenant
type TenantConfigRepository interface {
	FindByTenant(ctx context.Context, tenantID kernel.TenantID) (map[string]string, error)
	SaveSetting(ctx context.Context, tenantID kernel.TenantID, key, value string) error
	DeleteSetting(ctx context.Context, tenantID kernel.TenantID, key string) error
}
package tenant

import (
	"net/http"
	"time"

	"github.com/Abraxas-365/craftable/errx"
	"github.com/Abraxas-365/relay/pkg/kernel"
)

// ============================================================================
// Tenant Entity
// ============================================================================

// TenantStatus define los posibles estados de un tenant
type TenantStatus string

const (
	TenantStatusActive    TenantStatus = "ACTIVE"
	TenantStatusSuspended TenantStatus = "SUSPENDED"
	TenantStatusCanceled  TenantStatus = "CANCELED"
	TenantStatusTrial     TenantStatus = "TRIAL"
)

// SubscriptionPlan define los planes de suscripci√≥n
type SubscriptionPlan string

const (
	PlanTrial        SubscriptionPlan = "TRIAL"
	PlanBasic        SubscriptionPlan = "BASIC"
	PlanProfessional SubscriptionPlan = "PROFESSIONAL"
	PlanEnterprise   SubscriptionPlan = "ENTERPRISE"
)

// Tenant es la entidad rica que representa una empresa en el sistema
type Tenant struct {
	ID                    kernel.TenantID  `db:"id" json:"id"`
	CompanyName           string           `db:"company_name" json:"company_name"`
	RUC                   string           `db:"ruc" json:"ruc"`
	Status                TenantStatus     `db:"status" json:"status"`
	SubscriptionPlan      SubscriptionPlan `db:"subscription_plan" json:"subscription_plan"`
	MaxUsers              int              `db:"max_users" json:"max_users"`
	CurrentUsers          int              `db:"current_users" json:"current_users"`
	TrialExpiresAt        *time.Time       `db:"trial_expires_at" json:"trial_expires_at,omitempty"`
	SubscriptionExpiresAt *time.Time       `db:"subscription_expires_at" json:"subscription_expires_at,omitempty"`

	CreatedAt time.Time `db:"created_at" json:"created_at"`
	UpdatedAt time.Time `db:"updated_at" json:"updated_at"`
}

// ============================================================================
// Domain Methods
// ============================================================================

// IsActive verifica si el tenant est√° activo
func (t *Tenant) IsActive() bool {
	return t.Status == TenantStatusActive
}

// IsTrial verifica si el tenant est√° en per√≠odo de prueba
func (t *Tenant) IsTrial() bool {
	return t.SubscriptionPlan == PlanTrial || t.Status == TenantStatusTrial
}

// IsTrialExpired verifica si el trial ha expirado
func (t *Tenant) IsTrialExpired() bool {
	if !t.IsTrial() || t.TrialExpiresAt == nil {
		return false
	}
	return time.Now().After(*t.TrialExpiresAt)
}

// IsSubscriptionExpired verifica si la suscripci√≥n ha expirado
func (t *Tenant) IsSubscriptionExpired() bool {
	if t.SubscriptionExpiresAt == nil {
		return false
	}
	return time.Now().After(*t.SubscriptionExpiresAt)
}

// CanAddUser verifica si se puede agregar un nuevo usuario
func (t *Tenant) CanAddUser() bool {
	if !t.IsActive() {
		return false
	}
	if t.IsTrialExpired() || t.IsSubscriptionExpired() {
		return false
	}
	return t.CurrentUsers < t.MaxUsers
}

// AddUser incrementa el contador de usuarios
func (t *Tenant) AddUser() error {
	if !t.CanAddUser() {
		return ErrMaxUsersReached().WithDetail("max_users", t.MaxUsers).WithDetail("current_users", t.CurrentUsers)
	}

	t.CurrentUsers++
	t.UpdatedAt = time.Now()
	return nil
}

// RemoveUser decrementa el contador de usuarios
func (t *Tenant) RemoveUser() {
	if t.CurrentUsers > 0 {
		t.CurrentUsers--
		t.UpdatedAt = time.Now()
	}
}

// Suspend suspende el tenant
func (t *Tenant) Suspend(reason string) {
	t.Status = TenantStatusSuspended
	t.UpdatedAt = time.Now()
}

// Activate activa el tenant
func (t *Tenant) Activate() {
	t.Status = TenantStatusActive
	t.UpdatedAt = time.Now()
}

// UpgradePlan mejora el plan de suscripci√≥n
func (t *Tenant) UpgradePlan(newPlan SubscriptionPlan) error {
	maxUsers := t.getMaxUsersForPlan(newPlan)
	if t.CurrentUsers > maxUsers {
		return ErrTooManyUsersForPlan().WithDetail("current_users", t.CurrentUsers).WithDetail("max_allowed", maxUsers)
	}

	t.SubscriptionPlan = newPlan
	t.MaxUsers = maxUsers
	t.UpdatedAt = time.Now()
	return nil
}

// getMaxUsersForPlan retorna el m√°ximo de usuarios para un plan
func (t *Tenant) getMaxUsersForPlan(plan SubscriptionPlan) int {
	switch plan {
	case PlanTrial, PlanBasic:
		return 5
	case PlanProfessional:
		return 50
	case PlanEnterprise:
		return 500
	default:
		return 1
	}
}

// ============================================================================
// DTOs
// ============================================================================

// TenantDetailsDTO contiene informaci√≥n b√°sica de un tenant para otros m√≥dulos
type TenantDetailsDTO struct {
	ID               kernel.TenantID  `json:"id"`
	CompanyName      string           `json:"company_name"`
	RUC              string           `json:"ruc"`
	Status           TenantStatus     `json:"status"`
	SubscriptionPlan SubscriptionPlan `json:"subscription_plan"`
	MaxUsers         int              `json:"max_users"`
	CurrentUsers     int              `json:"current_users"`
}

// ToDTO convierte la entidad Tenant a TenantDetailsDTO
func (t *Tenant) ToDTO() TenantDetailsDTO {
	return TenantDetailsDTO{
		ID:               t.ID,
		CompanyName:      t.CompanyName,
		RUC:              t.RUC,
		Status:           t.Status,
		SubscriptionPlan: t.SubscriptionPlan,
		MaxUsers:         t.MaxUsers,
		CurrentUsers:     t.CurrentUsers,
	}
}

// ============================================================================
// Service DTOs - Para operaciones de la capa de servicio
// ============================================================================

// CreateTenantRequest representa la petici√≥n para crear un tenant
type CreateTenantRequest struct {
	CompanyName      string           `json:"company_name" validate:"required,min=2"`
	RUC              string           `json:"ruc" validate:"required,len=11"`
	SubscriptionPlan SubscriptionPlan `json:"subscription_plan"`
}

// UpdateTenantRequest representa la petici√≥n para actualizar un tenant
type UpdateTenantRequest struct {
	CompanyName *string       `json:"company_name,omitempty" validate:"omitempty,min=2"`
	Status      *TenantStatus `json:"status,omitempty"`
}

// TenantResponse representa la respuesta completa de un tenant con configuraci√≥n
type TenantResponse struct {
	Tenant Tenant            `json:"tenant"`
	Config map[string]string `json:"config"`
}

// ToDTO convierte TenantResponse a TenantResponseDTO
func (tr *TenantResponse) ToDTO() TenantResponseDTO {
	return TenantResponseDTO{
		Tenant: tr.Tenant.ToDTO(),
		Config: tr.Config,
	}
}

// TenantResponseDTO es la versi√≥n DTO de TenantResponse
type TenantResponseDTO struct {
	Tenant TenantDetailsDTO  `json:"tenant"`
	Config map[string]string `json:"config"`
}

// SuspendTenantRequest para suspender un tenant
type SuspendTenantRequest struct {
	Reason string `json:"reason" validate:"required,min=10"`
}

// ActivateTenantRequest para activar un tenant
type ActivateTenantRequest struct {
	Comments string `json:"comments,omitempty"`
}

// UpgradePlanRequest para cambiar el plan de suscripci√≥n
type UpgradePlanRequest struct {
	NewPlan SubscriptionPlan `json:"new_plan" validate:"required"`
}

// SetConfigRequest para establecer una configuraci√≥n
type SetConfigRequest struct {
	Key   string `json:"key" validate:"required"`
	Value string `json:"value" validate:"required"`
}

// DeleteConfigRequest para eliminar una configuraci√≥n
type DeleteConfigRequest struct {
	Key string `json:"key" validate:"required"`
}

// TenantListResponse para listas de tenants
type TenantListResponse struct {
	Tenants []TenantResponse `json:"tenants"`
	Total   int              `json:"total"`
}

// ToDTO convierte TenantListResponse a TenantListResponseDTO
func (tlr *TenantListResponse) ToDTO() TenantListResponseDTO {
	var tenantsDTO []TenantResponseDTO
	for _, t := range tlr.Tenants {
		tenantsDTO = append(tenantsDTO, t.ToDTO())
	}

	return TenantListResponseDTO{
		Tenants: tenantsDTO,
		Total:   tlr.Total,
	}
}

// TenantListResponseDTO es la versi√≥n DTO de TenantListResponse
type TenantListResponseDTO struct {
	Tenants []TenantResponseDTO `json:"tenants"`
	Total   int                 `json:"total"`
}

// TenantStatsResponse para estad√≠sticas del tenant
type TenantStatsResponse struct {
	TenantID              kernel.TenantID `json:"tenant_id"`
	TotalUsers            int             `json:"total_users"`
	ActiveUsers           int             `json:"active_users"`
	MaxUsers              int             `json:"max_users"`
	UserUtilization       float64         `json:"user_utilization"` // Porcentaje de usuarios usados
	SubscriptionStatus    string          `json:"subscription_status"`
	DaysUntilExpiration   *int            `json:"days_until_expiration,omitempty"`
	IsTrialExpired        bool            `json:"is_trial_expired"`
	IsSubscriptionExpired bool            `json:"is_subscription_expired"`
}

// TenantHealthResponse para el estado de salud del tenant
type TenantHealthResponse struct {
	TenantID        kernel.TenantID `json:"tenant_id"`
	Status          TenantStatus    `json:"status"`
	IsHealthy       bool            `json:"is_healthy"`
	Issues          []string        `json:"issues,omitempty"`
	LastHealthCheck time.Time       `json:"last_health_check"`
}

// BulkTenantOperationRequest para operaciones masivas
type BulkTenantOperationRequest struct {
	TenantIDs []kernel.TenantID `json:"tenant_ids" validate:"required,min=1"`
	Operation string            `json:"operation" validate:"required,oneof=suspend activate delete"`
	Reason    string            `json:"reason,omitempty"`
}

// BulkTenantOperationResponse resultado de operaciones masivas
type BulkTenantOperationResponse struct {
	Successful []kernel.TenantID          `json:"successful"`
	Failed     map[kernel.TenantID]string `json:"failed"`
	Total      int                        `json:"total"`
}

// TenantConfigResponse para respuestas de configuraci√≥n
type TenantConfigResponse struct {
	TenantID kernel.TenantID   `json:"tenant_id"`
	Config   map[string]string `json:"config"`
}

// TenantUsageResponse para informaci√≥n de uso del tenant
type TenantUsageResponse struct {
	TenantID        kernel.TenantID `json:"tenant_id"`
	CurrentUsers    int             `json:"current_users"`
	MaxUsers        int             `json:"max_users"`
	UsagePercentage float64         `json:"usage_percentage"`
	CanAddUsers     bool            `json:"can_add_users"`
	RemainingUsers  int             `json:"remaining_users"`
}

// ============================================================================
// Error Registry - Errores espec√≠ficos de Tenant
// ============================================================================

var ErrRegistry = errx.NewRegistry("TENANT")

// C√≥digos de error
var (
	CodeTenantNotFound      = ErrRegistry.Register("NOT_FOUND", errx.TypeNotFound, http.StatusNotFound, "Empresa no encontrada")
	CodeTenantAlreadyExists = ErrRegistry.Register("ALREADY_EXISTS", errx.TypeConflict, http.StatusConflict, "La empresa ya existe")
	CodeTenantSuspended     = ErrRegistry.Register("SUSPENDED", errx.TypeBusiness, http.StatusForbidden, "Empresa suspendida")
	CodeTrialExpired        = ErrRegistry.Register("TRIAL_EXPIRED", errx.TypeBusiness, http.StatusPaymentRequired, "Per√≠odo de prueba expirado")
	CodeSubscriptionExpired = ErrRegistry.Register("SUBSCRIPTION_EXPIRED", errx.TypeBusiness, http.StatusPaymentRequired, "Suscripci√≥n expirada")
	CodeMaxUsersReached     = ErrRegistry.Register("MAX_USERS_REACHED", errx.TypeBusiness, http.StatusForbidden, "M√°ximo de usuarios alcanzado")
	CodeTooManyUsersForPlan = ErrRegistry.Register("TOO_MANY_USERS_FOR_PLAN", errx.TypeBusiness, http.StatusBadRequest, "El nuevo plan no permite tantos usuarios")
	CodeTenantHasUsers      = ErrRegistry.Register("TENANT_HAS_USERS", errx.TypeBusiness, http.StatusConflict, "No se puede eliminar tenant con usuarios activos")
	CodeInvalidPlanUpgrade  = ErrRegistry.Register("INVALID_PLAN_UPGRADE", errx.TypeBusiness, http.StatusBadRequest, "Actualizaci√≥n de plan inv√°lida")
)

// Helper functions para crear errores
func ErrTenantNotFound() *errx.Error {
	return ErrRegistry.New(CodeTenantNotFound)
}

func ErrTenantAlreadyExists() *errx.Error {
	return ErrRegistry.New(CodeTenantAlreadyExists)
}

func ErrTenantSuspended() *errx.Error {
	return ErrRegistry.New(CodeTenantSuspended)
}

func ErrTrialExpired() *errx.Error {
	return ErrRegistry.New(CodeTrialExpired)
}

func ErrSubscriptionExpired() *errx.Error {
	return ErrRegistry.New(CodeSubscriptionExpired)
}

func ErrMaxUsersReached() *errx.Error {
	return ErrRegistry.New(CodeMaxUsersReached)
}

func ErrTooManyUsersForPlan() *errx.Error {
	return ErrRegistry.New(CodeTooManyUsersForPlan)
}

func ErrTenantHasUsers() *errx.Error {
	return ErrRegistry.New(CodeTenantHasUsers)
}

func ErrInvalidPlanUpgrade() *errx.Error {
	return ErrRegistry.New(CodeInvalidPlanUpgrade)
}
package iam

import (
	"net/http"

	"github.com/Abraxas-365/craftable/errx"
)

// ============================================================================
// Error Registry - Registro de errores del m√≥dulo IAM
// ============================================================================

var ErrRegistry = errx.NewRegistry("IAM")

// C√≥digos de error del m√≥dulo IAM
var (
	// Errores comunes
	CodeUnauthorized = ErrRegistry.Register("UNAUTHORIZED", errx.TypeAuthorization, http.StatusUnauthorized, "No autorizado")
	CodeInvalidToken = ErrRegistry.Register("INVALID_TOKEN", errx.TypeAuthorization, http.StatusUnauthorized, "Token inv√°lido o expirado")
	CodeAccessDenied = ErrRegistry.Register("ACCESS_DENIED", errx.TypeAuthorization, http.StatusForbidden, "Acceso denegado")
)

// Helper functions para crear errores comunes
func ErrUnauthorized() *errx.Error {
	return ErrRegistry.New(CodeUnauthorized)
}

func ErrInvalidToken() *errx.Error {
	return ErrRegistry.New(CodeInvalidToken)
}

func ErrAccessDenied() *errx.Error {
	return ErrRegistry.New(CodeAccessDenied)
}

// OAuthProvider representa los proveedores OAuth soportados
type OAuthProvider string

const (
	OAuthProviderGoogle    OAuthProvider = "GOOGLE"
	OAuthProviderMicrosoft OAuthProvider = "MICROSOFT"
	OAuthProviderAuth0     OAuthProvider = "AUTH0"
)

// GetProviderName retorna el nombre legible del proveedor
func (p OAuthProvider) GetProviderName() string {
	switch p {
	case OAuthProviderGoogle:
		return "Google"
	case OAuthProviderMicrosoft:
		return "Microsoft"
	case OAuthProviderAuth0:
		return "Auth0"
	default:
		return "Unknown"
	}
}
package usersrv

import (
	"context"
	"time"

	"github.com/Abraxas-365/craftable/errx"
	"github.com/Abraxas-365/relay/iam/role"
	"github.com/Abraxas-365/relay/iam/tenant"
	"github.com/Abraxas-365/relay/iam/user"
	"github.com/Abraxas-365/relay/pkg/kernel"
	"github.com/google/uuid"
)

// UserService proporciona operaciones de negocio para usuarios
type UserService struct {
	userRepo     user.UserRepository
	userRoleRepo user.UserRoleRepository
	tenantRepo   tenant.TenantRepository
	roleRepo     role.RoleRepository
	passwordSvc  user.PasswordService
}

// NewUserService crea una nueva instancia del servicio de usuarios
func NewUserService(
	userRepo user.UserRepository,
	userRoleRepo user.UserRoleRepository,
	tenantRepo tenant.TenantRepository,
	roleRepo role.RoleRepository,
	passwordSvc user.PasswordService,
) *UserService {
	return &UserService{
		userRepo:     userRepo,
		userRoleRepo: userRoleRepo,
		tenantRepo:   tenantRepo,
		roleRepo:     roleRepo,
		passwordSvc:  passwordSvc,
	}
}

// CreateUser crea un nuevo usuario
func (s *UserService) CreateUser(ctx context.Context, req user.CreateUserRequest, creatorID kernel.UserID) (*user.User, error) {
	// Validar que el tenant exista y est√© activo
	tenantEntity, err := s.tenantRepo.FindByID(ctx, req.TenantID)
	if err != nil {
		return nil, tenant.ErrTenantNotFound()
	}

	if !tenantEntity.IsActive() {
		return nil, tenant.ErrTenantSuspended()
	}

	// Verificar que el tenant puede agregar m√°s usuarios
	if !tenantEntity.CanAddUser() {
		return nil, tenant.ErrMaxUsersReached()
	}

	// Verificar que no exista un usuario con el mismo email
	exists, err := s.userRepo.ExistsByEmail(ctx, req.Email, req.TenantID)
	if err != nil {
		return nil, errx.Wrap(err, "failed to check email existence", errx.TypeInternal)
	}
	if exists {
		return nil, user.ErrUserAlreadyExists()
	}

	// Crear nuevo usuario
	newUser := &user.User{
		ID:            kernel.NewUserID(uuid.NewString()),
		TenantID:      req.TenantID,
		Email:         req.Email,
		Name:          req.Name,
		Status:        user.UserStatusPending, // Pendiente hasta completar onboarding
		IsAdmin:       req.IsAdmin,
		EmailVerified: false, // Se verificar√° despu√©s
		CreatedAt:     time.Now(),
		UpdatedAt:     time.Now(),
	}

	// Guardar usuario
	if err := s.userRepo.Save(ctx, *newUser); err != nil {
		return nil, errx.Wrap(err, "failed to save user", errx.TypeInternal)
	}

	// Asignar roles si se especificaron
	if len(req.RoleIDs) > 0 {
		if err := s.assignRolesToUser(ctx, newUser.ID, req.RoleIDs); err != nil {
			// Log error pero no fallar
			// logger.Error("Failed to assign roles to user", err)
		}
	}

	// Incrementar contador de usuarios del tenant
	if err := tenantEntity.AddUser(); err == nil {
		s.tenantRepo.Save(ctx, *tenantEntity)
	}

	return newUser, nil
}

// GetUserByID obtiene un usuario por ID
func (s *UserService) GetUserByID(ctx context.Context, userID kernel.UserID, tenantID kernel.TenantID) (*user.UserResponse, error) {
	userEntity, err := s.userRepo.FindByID(ctx, userID, tenantID)
	if err != nil {
		return nil, user.ErrUserNotFound()
	}

	// Obtener roles del usuario
	roleIDs, err := s.userRoleRepo.FindRolesByUser(ctx, userID)
	if err != nil {
		roleIDs = []kernel.RoleID{} // Default a empty slice
	}

	return &user.UserResponse{
		User:    *userEntity,
		RoleIDs: roleIDs,
	}, nil
}

// GetUserByEmail obtiene un usuario por email
func (s *UserService) GetUserByEmail(ctx context.Context, email string, tenantID kernel.TenantID) (*user.UserResponse, error) {
	userEntity, err := s.userRepo.FindByEmail(ctx, email, tenantID)
	if err != nil {
		return nil, user.ErrUserNotFound()
	}

	// Obtener roles del usuario
	roleIDs, err := s.userRoleRepo.FindRolesByUser(ctx, userEntity.ID)
	if err != nil {
		roleIDs = []kernel.RoleID{}
	}

	return &user.UserResponse{
		User:    *userEntity,
		RoleIDs: roleIDs,
	}, nil
}

// GetUsersByTenant obtiene todos los usuarios de un tenant
func (s *UserService) GetUsersByTenant(ctx context.Context, tenantID kernel.TenantID) (*user.UserListResponse, error) {
	users, err := s.userRepo.FindByTenant(ctx, tenantID)
	if err != nil {
		return nil, errx.Wrap(err, "failed to get users by tenant", errx.TypeInternal)
	}

	var userResponses []user.UserResponse
	for _, u := range users {
		roleIDs, _ := s.userRoleRepo.FindRolesByUser(ctx, u.ID)
		userResponses = append(userResponses, user.UserResponse{
			User:    *u,
			RoleIDs: roleIDs,
		})
	}

	return &user.UserListResponse{
		Users: userResponses,
		Total: len(userResponses),
	}, nil
}

// UpdateUser actualiza un usuario
func (s *UserService) UpdateUser(ctx context.Context, userID kernel.UserID, req user.UpdateUserRequest, updaterID kernel.UserID) (*user.User, error) {
	userEntity, err := s.userRepo.FindByID(ctx, userID, req.TenantID)
	if err != nil {
		return nil, user.ErrUserNotFound()
	}

	// Actualizar campos si se proporcionaron
	if req.Name != nil {
		userEntity.Name = *req.Name
	}
	if req.Status != nil {
		switch *req.Status {
		case user.UserStatusActive:
			if err := userEntity.Activate(); err != nil {
				return nil, err
			}
		case user.UserStatusSuspended:
			if err := userEntity.Suspend("Updated by admin"); err != nil {
				return nil, err
			}
		}
	}
	if req.IsAdmin != nil {
		if *req.IsAdmin {
			userEntity.MakeAdmin()
		} else {
			userEntity.RevokeAdmin()
		}
	}

	userEntity.UpdatedAt = time.Now()

	// Guardar cambios
	if err := s.userRepo.Save(ctx, *userEntity); err != nil {
		return nil, errx.Wrap(err, "failed to update user", errx.TypeInternal)
	}

	return userEntity, nil
}

// ActivateUser activa un usuario pendiente
func (s *UserService) ActivateUser(ctx context.Context, userID kernel.UserID, tenantID kernel.TenantID) error {
	userEntity, err := s.userRepo.FindByID(ctx, userID, tenantID)
	if err != nil {
		return user.ErrUserNotFound()
	}

	if err := userEntity.Activate(); err != nil {
		return err
	}

	return s.userRepo.Save(ctx, *userEntity)
}

// SuspendUser suspende un usuario
func (s *UserService) SuspendUser(ctx context.Context, userID kernel.UserID, tenantID kernel.TenantID, reason string) error {
	userEntity, err := s.userRepo.FindByID(ctx, userID, tenantID)
	if err != nil {
		return user.ErrUserNotFound()
	}

	if err := userEntity.Suspend(reason); err != nil {
		return err
	}

	return s.userRepo.Save(ctx, *userEntity)
}

// AssignUserToRole asigna un usuario a un rol
func (s *UserService) AssignUserToRole(ctx context.Context, userID kernel.UserID, roleID kernel.RoleID, tenantID kernel.TenantID) error {
	// Verificar que el usuario existe
	_, err := s.userRepo.FindByID(ctx, userID, tenantID)
	if err != nil {
		return user.ErrUserNotFound()
	}

	// Verificar que el rol existe y pertenece al mismo tenant
	_, err = s.roleRepo.FindByID(ctx, roleID, tenantID)
	if err != nil {
		return role.ErrRoleNotFound()
	}

	return s.userRoleRepo.AssignUserToRole(ctx, userID, roleID)
}

// RemoveUserFromRole remueve un usuario de un rol
func (s *UserService) RemoveUserFromRole(ctx context.Context, userID kernel.UserID, roleID kernel.RoleID, tenantID kernel.TenantID) error {
	// Verificar que el usuario existe
	_, err := s.userRepo.FindByID(ctx, userID, tenantID)
	if err != nil {
		return user.ErrUserNotFound()
	}

	return s.userRoleRepo.RemoveUserFromRole(ctx, userID, roleID)
}

// GetUserRoles obtiene los roles de un usuario
func (s *UserService) GetUserRoles(ctx context.Context, userID kernel.UserID, tenantID kernel.TenantID) ([]*role.Role, error) {
	// Verificar que el usuario existe
	_, err := s.userRepo.FindByID(ctx, userID, tenantID)
	if err != nil {
		return nil, user.ErrUserNotFound()
	}

	roleIDs, err := s.userRoleRepo.FindRolesByUser(ctx, userID)
	if err != nil {
		return nil, errx.Wrap(err, "failed to get user roles", errx.TypeInternal)
	}

	var roles []*role.Role
	for _, roleID := range roleIDs {
		roleEntity, err := s.roleRepo.FindByID(ctx, roleID, tenantID)
		if err != nil {
			continue // Skip invalid roles
		}
		roles = append(roles, roleEntity)
	}

	return roles, nil
}

// DeleteUser elimina un usuario
func (s *UserService) DeleteUser(ctx context.Context, userID kernel.UserID, tenantID kernel.TenantID) error {
	// Verificar que el usuario existe
	_, err := s.userRepo.FindByID(ctx, userID, tenantID)
	if err != nil {
		return user.ErrUserNotFound()
	}

	// Remover todos los roles del usuario
	if err := s.userRoleRepo.RemoveAllUserRoles(ctx, userID); err != nil {
		// Log error pero contin√∫ar
	}

	// Eliminar usuario
	if err := s.userRepo.Delete(ctx, userID, tenantID); err != nil {
		return errx.Wrap(err, "failed to delete user", errx.TypeInternal)
	}

	// Decrementar contador de usuarios del tenant
	tenantEntity, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err == nil {
		tenantEntity.RemoveUser()
		s.tenantRepo.Save(ctx, *tenantEntity)
	}

	return nil
}

// Helper function to assign multiple roles to user
func (s *UserService) assignRolesToUser(ctx context.Context, userID kernel.UserID, roleIDs []kernel.RoleID) error {
	for _, roleID := range roleIDs {
		if err := s.userRoleRepo.AssignUserToRole(ctx, userID, roleID); err != nil {
			return err
		}
	}
	return nil
}
package user

import (
	"context"

	"github.com/Abraxas-365/relay/pkg/kernel"
)

// UserRepository define el contrato para la persistencia de usuarios
type UserRepository interface {
	FindByID(ctx context.Context, id kernel.UserID, tenantID kernel.TenantID) (*User, error)
	FindByEmail(ctx context.Context, email string, tenantID kernel.TenantID) (*User, error)
	FindByTenant(ctx context.Context, tenantID kernel.TenantID) ([]*User, error)
	Save(ctx context.Context, u User) error
	Delete(ctx context.Context, id kernel.UserID, tenantID kernel.TenantID) error
	ExistsByEmail(ctx context.Context, email string, tenantID kernel.TenantID) (bool, error)
}

// UserRoleRepository define el contrato para la relaci√≥n usuario-rol
type UserRoleRepository interface {
	FindRolesByUser(ctx context.Context, userID kernel.UserID) ([]kernel.RoleID, error)
	AssignUserToRole(ctx context.Context, userID kernel.UserID, roleID kernel.RoleID) error
	RemoveUserFromRole(ctx context.Context, userID kernel.UserID, roleID kernel.RoleID) error
	RemoveAllUserRoles(ctx context.Context, userID kernel.UserID) error
	FindUsersByRole(ctx context.Context, roleID kernel.RoleID) ([]kernel.UserID, error)
	CountUsersByRole(ctx context.Context, roleID kernel.RoleID) (int, error)
}

// PasswordService define el contrato para el manejo de contrase√±as
type PasswordService interface {
	HashPassword(password string) (string, error)
	VerifyPassword(hashedPassword, password string) bool
}
package user

import (
	"net/http"
	"time"

	"github.com/Abraxas-365/craftable/errx"
	"github.com/Abraxas-365/craftable/ptrx"
	"github.com/Abraxas-365/relay/iam"
	"github.com/Abraxas-365/relay/pkg/kernel"
)

// ============================================================================
// User Entity
// ============================================================================

// UserStatus define los posibles estados de un usuario
type UserStatus string

const (
	UserStatusActive    UserStatus = "ACTIVE"
	UserStatusInactive  UserStatus = "INACTIVE"
	UserStatusSuspended UserStatus = "SUSPENDED"
	UserStatusPending   UserStatus = "PENDING" // Invitado pero no complet√≥ onboarding
)

// User es la entidad rica que representa a un usuario en el sistema
type User struct {
	ID              kernel.UserID     `db:"id" json:"id"`
	TenantID        kernel.TenantID   `db:"tenant_id" json:"tenant_id"`
	Email           string            `db:"email" json:"email"`
	Name            string            `db:"name" json:"name"`
	Picture         *string           `db:"picture" json:"picture,omitempty"`
	Status          UserStatus        `db:"status" json:"status"`
	IsAdmin         bool              `db:"is_admin" json:"is_admin"`
	OAuthProvider   iam.OAuthProvider `db:"oauth_provider" json:"oauth_provider"`
	OAuthProviderID string            `db:"oauth_provider_id" json:"oauth_provider_id"`
	EmailVerified   bool              `db:"email_verified" json:"email_verified"`
	LastLoginAt     *time.Time        `db:"last_login_at" json:"last_login_at,omitempty"`
	CreatedAt       time.Time         `db:"created_at" json:"created_at"`
	UpdatedAt       time.Time         `db:"updated_at" json:"updated_at"`
}

// ============================================================================
// Domain Methods
// ============================================================================

// IsActive verifica si el usuario est√° activo
func (u *User) IsActive() bool {
	return u.Status == UserStatusActive
}

// CanLogin verifica si el usuario puede iniciar sesi√≥n
func (u *User) CanLogin() bool {
	return u.IsActive() && u.EmailVerified
}

// Activate activa un usuario pendiente
func (u *User) Activate() error {
	if u.Status != UserStatusPending {
		return ErrInvalidStatus().WithDetail("current_status", u.Status)
	}

	u.Status = UserStatusActive
	u.UpdatedAt = time.Now()
	return nil
}

// Suspend suspende un usuario activo
func (u *User) Suspend(reason string) error {
	if !u.IsActive() {
		return ErrInvalidStatus().WithDetail("current_status", u.Status)
	}

	u.Status = UserStatusSuspended
	u.UpdatedAt = time.Now()
	return nil
}

// UpdateLastLogin actualiza la fecha del √∫ltimo login
func (u *User) UpdateLastLogin() {
	now := time.Now()
	u.LastLoginAt = &now
	u.UpdatedAt = now
}

// UpdateProfile actualiza la informaci√≥n del perfil
func (u *User) UpdateProfile(name, picture string) {
	if name != "" {
		u.Name = name
	}
	if picture != "" {
		u.Picture = ptrx.String(picture)
	}
	u.UpdatedAt = time.Now()
}

// MakeAdmin convierte al usuario en administrador
func (u *User) MakeAdmin() {
	u.IsAdmin = true
	u.UpdatedAt = time.Now()
}

// RevokeAdmin remueve permisos de administrador
func (u *User) RevokeAdmin() {
	u.IsAdmin = false
	u.UpdatedAt = time.Now()
}

// ============================================================================
// DTOs
// ============================================================================

// UserDetailsDTO contiene informaci√≥n b√°sica de un usuario para otros m√≥dulos
type UserDetailsDTO struct {
	ID            kernel.UserID     `json:"id"`
	TenantID      kernel.TenantID   `json:"tenant_id"`
	Name          string            `json:"name"`
	Email         string            `json:"email"`
	Picture       *string           `json:"picture,omitempty"`
	IsActive      bool              `json:"is_active"`
	IsAdmin       bool              `json:"is_admin"`
	OAuthProvider iam.OAuthProvider `json:"oauth_provider"`
}

// ToDTO convierte la entidad User a UserDetailsDTO
func (u *User) ToDTO() UserDetailsDTO {
	return UserDetailsDTO{
		ID:            u.ID,
		TenantID:      u.TenantID,
		Name:          u.Name,
		Email:         u.Email,
		Picture:       u.Picture,
		IsActive:      u.IsActive(),
		IsAdmin:       u.IsAdmin,
		OAuthProvider: u.OAuthProvider,
	}
}

// ============================================================================
// Service DTOs - Para operaciones de la capa de servicio
// ============================================================================

// CreateUserRequest representa la petici√≥n para crear un usuario
type CreateUserRequest struct {
	TenantID kernel.TenantID `json:"tenant_id" validate:"required"`
	Email    string          `json:"email" validate:"required,email"`
	Name     string          `json:"name" validate:"required,min=2"`
	IsAdmin  bool            `json:"is_admin"`
	RoleIDs  []kernel.RoleID `json:"role_ids,omitempty"`
}

// UpdateUserRequest representa la petici√≥n para actualizar un usuario
type UpdateUserRequest struct {
	TenantID kernel.TenantID `json:"tenant_id" validate:"required"`
	Name     *string         `json:"name,omitempty" validate:"omitempty,min=2"`
	Status   *UserStatus     `json:"status,omitempty"`
	IsAdmin  *bool           `json:"is_admin,omitempty"`
}

// InviteUserRequest para invitar usuarios a un tenant
type InviteUserRequest struct {
	Email   string `json:"email" validate:"required,email"`
	IsAdmin bool   `json:"is_admin"`
}

// UserResponse representa la respuesta completa de un usuario con sus roles
type UserResponse struct {
	User    User            `json:"user"`
	RoleIDs []kernel.RoleID `json:"role_ids"`
}

// ToDTO convierte UserResponse a UserResponseDTO
func (ur *UserResponse) ToDTO() UserResponseDTO {
	return UserResponseDTO{
		User:    ur.User.ToDTO(),
		RoleIDs: ur.RoleIDs,
	}
}

// UserResponseDTO es la versi√≥n DTO de UserResponse
type UserResponseDTO struct {
	User    UserDetailsDTO  `json:"user"`
	RoleIDs []kernel.RoleID `json:"role_ids"`
}

// AssignRoleRequest para asignar un rol a un usuario
type AssignRoleRequest struct {
	TenantID kernel.TenantID `json:"tenant_id" validate:"required"`
	RoleID   kernel.RoleID   `json:"role_id" validate:"required"`
}

// RemoveRoleRequest para remover un rol de un usuario
type RemoveRoleRequest struct {
	TenantID kernel.TenantID `json:"tenant_id" validate:"required"`
	RoleID   kernel.RoleID   `json:"role_id" validate:"required"`
}

// SuspendUserRequest para suspender un usuario
type SuspendUserRequest struct {
	TenantID kernel.TenantID `json:"tenant_id" validate:"required"`
	Reason   string          `json:"reason" validate:"required,min=5"`
}

// ActivateUserRequest para activar un usuario
type ActivateUserRequest struct {
	TenantID kernel.TenantID `json:"tenant_id" validate:"required"`
}

// UserListResponse para listas de usuarios
type UserListResponse struct {
	Users []UserResponse `json:"users"`
	Total int            `json:"total"`
}

// ToDTO convierte UserListResponse a UserListResponseDTO
func (ulr *UserListResponse) ToDTO() UserListResponseDTO {
	var usersDTO []UserResponseDTO
	for _, u := range ulr.Users {
		usersDTO = append(usersDTO, u.ToDTO())
	}

	return UserListResponseDTO{
		Users: usersDTO,
		Total: ulr.Total,
	}
}

// UserListResponseDTO es la versi√≥n DTO de UserListResponse
type UserListResponseDTO struct {
	Users []UserResponseDTO `json:"users"`
	Total int               `json:"total"`
}

// ============================================================================
// Error Registry - Errores espec√≠ficos de User
// ============================================================================

var ErrRegistry = errx.NewRegistry("USER")

// C√≥digos de error
var (
	CodeUserNotFound       = ErrRegistry.Register("NOT_FOUND", errx.TypeNotFound, http.StatusNotFound, "Usuario no encontrado")
	CodeUserAlreadyExists  = ErrRegistry.Register("ALREADY_EXISTS", errx.TypeConflict, http.StatusConflict, "El usuario ya existe")
	CodeUserNotInTenant    = ErrRegistry.Register("NOT_IN_TENANT", errx.TypeAuthorization, http.StatusForbidden, "Usuario no pertenece a la empresa")
	CodeEmailNotVerified   = ErrRegistry.Register("EMAIL_NOT_VERIFIED", errx.TypeBusiness, http.StatusPreconditionFailed, "Email no verificado")
	CodeUserSuspended      = ErrRegistry.Register("SUSPENDED", errx.TypeBusiness, http.StatusForbidden, "Usuario suspendido")
	CodeOnboardingRequired = ErrRegistry.Register("ONBOARDING_REQUIRED", errx.TypeBusiness, http.StatusPreconditionRequired, "Se requiere completar el onboarding")
	CodeInvalidStatus      = ErrRegistry.Register("INVALID_STATUS", errx.TypeBusiness, http.StatusBadRequest, "Estado de usuario inv√°lido para esta operaci√≥n")
)

// Helper functions para crear errores
func ErrUserNotFound() *errx.Error {
	return ErrRegistry.New(CodeUserNotFound)
}

func ErrUserAlreadyExists() *errx.Error {
	return ErrRegistry.New(CodeUserAlreadyExists)
}

func ErrUserNotInTenant() *errx.Error {
	return ErrRegistry.New(CodeUserNotInTenant)
}

func ErrEmailNotVerified() *errx.Error {
	return ErrRegistry.New(CodeEmailNotVerified)
}

func ErrUserSuspended() *errx.Error {
	return ErrRegistry.New(CodeUserSuspended)
}

func ErrOnboardingRequired() *errx.Error {
	return ErrRegistry.New(CodeOnboardingRequired)
}

func ErrInvalidStatus() *errx.Error {
	return ErrRegistry.New(CodeInvalidStatus)
}
package userinfra

import (
	"context"
	"database/sql"

	"github.com/Abraxas-365/craftable/errx"
	"github.com/Abraxas-365/craftable/logx"
	"github.com/Abraxas-365/relay/iam/user"
	"github.com/Abraxas-365/relay/pkg/kernel"
	"github.com/jmoiron/sqlx"
	"github.com/lib/pq"
)

// PostgresUserRepository implementaci√≥n de PostgreSQL para UserRepository
type PostgresUserRepository struct {
	db *sqlx.DB
}

// NewPostgresUserRepository crea una nueva instancia del repositorio de usuarios
func NewPostgresUserRepository(db *sqlx.DB) user.UserRepository {
	return &PostgresUserRepository{
		db: db,
	}
}

// FindByID busca un usuario por ID y tenant
func (r *PostgresUserRepository) FindByID(ctx context.Context, id kernel.UserID, tenantID kernel.TenantID) (*user.User, error) {
	query := `
		SELECT 
			id, tenant_id, email, name, picture, status, is_admin,
			oauth_provider, oauth_provider_id, email_verified, 
			last_login_at, created_at, updated_at
		FROM users 
		WHERE id = $1 AND tenant_id = $2`

	var u user.User
	err := r.db.GetContext(ctx, &u, query, id.String(), tenantID.String())
	if err != nil {
		logx.Error("Error fetching user by ID: %v", err)
		if err == sql.ErrNoRows {
			return nil, user.ErrUserNotFound().WithDetail("user_id", id.String())
		}
		return nil, errx.Wrap(err, "failed to find user by id", errx.TypeInternal).
			WithDetail("user_id", id.String()).
			WithDetail("tenant_id", tenantID.String())
	}

	return &u, nil
}

// FindByEmail busca un usuario por email y tenant
func (r *PostgresUserRepository) FindByEmail(ctx context.Context, email string, tenantID kernel.TenantID) (*user.User, error) {
	query := `
		SELECT 
			id, tenant_id, email, name, picture, status, is_admin,
			oauth_provider, oauth_provider_id, email_verified, 
			last_login_at, created_at, updated_at
		FROM users 
		WHERE email = $1 AND tenant_id = $2`

	var u user.User
	err := r.db.GetContext(ctx, &u, query, email, tenantID.String())
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, user.ErrUserNotFound().WithDetail("email", email)
		}
		return nil, errx.Wrap(err, "failed to find user by email", errx.TypeInternal).
			WithDetail("email", email).
			WithDetail("tenant_id", tenantID.String())
	}

	return &u, nil
}

// FindByTenant busca todos los usuarios de un tenant
func (r *PostgresUserRepository) FindByTenant(ctx context.Context, tenantID kernel.TenantID) ([]*user.User, error) {
	query := `
		SELECT 
			id, tenant_id, email, name, picture, status, is_admin,
			oauth_provider, oauth_provider_id, email_verified, 
			last_login_at, created_at, updated_at
		FROM users 
		WHERE tenant_id = $1
		ORDER BY name ASC`

	var users []user.User
	err := r.db.SelectContext(ctx, &users, query, tenantID.String())
	if err != nil {
		return nil, errx.Wrap(err, "failed to find users by tenant", errx.TypeInternal).
			WithDetail("tenant_id", tenantID.String())
	}

	// Convertir a slice de punteros
	result := make([]*user.User, len(users))
	for i := range users {
		result[i] = &users[i]
	}

	return result, nil
}

// Save guarda o actualiza un usuario
func (r *PostgresUserRepository) Save(ctx context.Context, u user.User) error {
	// Verificar si el usuario ya existe
	exists, err := r.userExists(ctx, u.ID, u.TenantID)
	if err != nil {
		return errx.Wrap(err, "failed to check user existence", errx.TypeInternal)
	}

	if exists {
		return r.update(ctx, u)
	}
	return r.create(ctx, u)
}

// create crea un nuevo usuario
func (r *PostgresUserRepository) create(ctx context.Context, u user.User) error {
	query := `
		INSERT INTO users (
			id, tenant_id, email, name, picture, status, is_admin,
			oauth_provider, oauth_provider_id, email_verified, 
			last_login_at, created_at, updated_at
		) VALUES (
			:id, :tenant_id, :email, :name, :picture, :status, :is_admin,
			:oauth_provider, :oauth_provider_id, :email_verified, 
			:last_login_at, :created_at, :updated_at
		)`

	_, err := r.db.NamedExecContext(ctx, query, u)
	if err != nil {
		// Verificar violaci√≥n de constraint de email √∫nico
		if pqErr, ok := err.(*pq.Error); ok {
			if pqErr.Code == "23505" && pqErr.Constraint == "users_email_tenant_id_key" {
				return user.ErrUserAlreadyExists().
					WithDetail("email", u.Email).
					WithDetail("tenant_id", u.TenantID.String())
			}
		}
		return errx.Wrap(err, "failed to create user", errx.TypeInternal).
			WithDetail("user_id", u.ID.String()).
			WithDetail("email", u.Email)
	}

	return nil
}

// update actualiza un usuario existente
func (r *PostgresUserRepository) update(ctx context.Context, u user.User) error {
	query := `
		UPDATE users SET
			email = :email,
			name = :name,
			picture = :picture,
			status = :status,
			is_admin = :is_admin,
			oauth_provider = :oauth_provider,
			oauth_provider_id = :oauth_provider_id,
			email_verified = :email_verified,
			last_login_at = :last_login_at,
			updated_at = :updated_at
		WHERE id = :id AND tenant_id = :tenant_id`

	result, err := r.db.NamedExecContext(ctx, query, u)
	if err != nil {
		// Verificar violaci√≥n de constraint de email √∫nico
		if pqErr, ok := err.(*pq.Error); ok {
			if pqErr.Code == "23505" && pqErr.Constraint == "users_email_tenant_id_key" {
				return user.ErrUserAlreadyExists().
					WithDetail("email", u.Email).
					WithDetail("tenant_id", u.TenantID.String())
			}
		}
		return errx.Wrap(err, "failed to update user", errx.TypeInternal).
			WithDetail("user_id", u.ID.String())
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return errx.Wrap(err, "failed to get rows affected", errx.TypeInternal)
	}

	if rowsAffected == 0 {
		return user.ErrUserNotFound().WithDetail("user_id", u.ID.String())
	}

	return nil
}

// Delete elimina un usuario
func (r *PostgresUserRepository) Delete(ctx context.Context, id kernel.UserID, tenantID kernel.TenantID) error {
	query := `DELETE FROM users WHERE id = $1 AND tenant_id = $2`

	result, err := r.db.ExecContext(ctx, query, id.String(), tenantID.String())
	if err != nil {
		return errx.Wrap(err, "failed to delete user", errx.TypeInternal).
			WithDetail("user_id", id.String()).
			WithDetail("tenant_id", tenantID.String())
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return errx.Wrap(err, "failed to get rows affected", errx.TypeInternal)
	}

	if rowsAffected == 0 {
		return user.ErrUserNotFound().WithDetail("user_id", id.String())
	}

	return nil
}

// ExistsByEmail verifica si existe un usuario con el email dado en el tenant
func (r *PostgresUserRepository) ExistsByEmail(ctx context.Context, email string, tenantID kernel.TenantID) (bool, error) {
	query := `SELECT EXISTS(SELECT 1 FROM users WHERE email = $1 AND tenant_id = $2)`

	var exists bool
	err := r.db.GetContext(ctx, &exists, query, email, tenantID.String())
	if err != nil {
		return false, errx.Wrap(err, "failed to check user existence by email", errx.TypeInternal).
			WithDetail("email", email).
			WithDetail("tenant_id", tenantID.String())
	}

	return exists, nil
}

// userExists verifica si un usuario existe por ID y tenant
func (r *PostgresUserRepository) userExists(ctx context.Context, id kernel.UserID, tenantID kernel.TenantID) (bool, error) {
	query := `SELECT EXISTS(SELECT 1 FROM users WHERE id = $1 AND tenant_id = $2)`

	var exists bool
	err := r.db.GetContext(ctx, &exists, query, id.String(), tenantID.String())
	if err != nil {
		return false, errx.Wrap(err, "failed to check user existence", errx.TypeInternal).
			WithDetail("user_id", id.String()).
			WithDetail("tenant_id", tenantID.String())
	}

	return exists, nil
}

// FindByStatus busca usuarios por estado (m√©todo adicional √∫til)
func (r *PostgresUserRepository) FindByStatus(ctx context.Context, status user.UserStatus, tenantID kernel.TenantID) ([]*user.User, error) {
	query := `
		SELECT 
			id, tenant_id, email, name, picture, status, is_admin,
			oauth_provider, oauth_provider_id, email_verified, 
			last_login_at, created_at, updated_at
		FROM users 
		WHERE status = $1 AND tenant_id = $2
		ORDER BY name ASC`

	var users []user.User
	err := r.db.SelectContext(ctx, &users, query, status, tenantID.String())
	if err != nil {
		return nil, errx.Wrap(err, "failed to find users by status", errx.TypeInternal).
			WithDetail("status", string(status)).
			WithDetail("tenant_id", tenantID.String())
	}

	// Convertir a slice de punteros
	result := make([]*user.User, len(users))
	for i := range users {
		result[i] = &users[i]
	}

	return result, nil
}

// FindActiveUsers busca usuarios activos (m√©todo adicional √∫til)
func (r *PostgresUserRepository) FindActiveUsers(ctx context.Context, tenantID kernel.TenantID) ([]*user.User, error) {
	return r.FindByStatus(ctx, user.UserStatusActive, tenantID)
}

// CountByTenant cuenta los usuarios de un tenant
func (r *PostgresUserRepository) CountByTenant(ctx context.Context, tenantID kernel.TenantID) (int, error) {
	query := `SELECT COUNT(*) FROM users WHERE tenant_id = $1`

	var count int
	err := r.db.GetContext(ctx, &count, query, tenantID.String())
	if err != nil {
		return 0, errx.Wrap(err, "failed to count users by tenant", errx.TypeInternal).
			WithDetail("tenant_id", tenantID.String())
	}

	return count, nil
}

// FindByOAuthProvider busca un usuario por proveedor OAuth y ID
func (r *PostgresUserRepository) FindByOAuthProvider(ctx context.Context, provider string, providerID string, tenantID kernel.TenantID) (*user.User, error) {
	query := `
		SELECT 
			id, tenant_id, email, name, picture, status, is_admin,
			oauth_provider, oauth_provider_id, email_verified, 
			last_login_at, created_at, updated_at
		FROM users 
		WHERE oauth_provider = $1 AND oauth_provider_id = $2 AND tenant_id = $3`

	var u user.User
	err := r.db.GetContext(ctx, &u, query, provider, providerID, tenantID.String())
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, user.ErrUserNotFound().
				WithDetail("oauth_provider", provider).
				WithDetail("oauth_provider_id", providerID)
		}
		return nil, errx.Wrap(err, "failed to find user by oauth provider", errx.TypeInternal).
			WithDetail("oauth_provider", provider).
			WithDetail("oauth_provider_id", providerID).
			WithDetail("tenant_id", tenantID.String())
	}

	return &u, nil
}

// UserRoleRepository Implementation
// =============================================================================

// PostgresUserRoleRepository implementaci√≥n de PostgreSQL para UserRoleRepository
type PostgresUserRoleRepository struct {
	db *sqlx.DB
}

// NewPostgresUserRoleRepository crea una nueva instancia del repositorio de roles de usuarios
func NewPostgresUserRoleRepository(db *sqlx.DB) user.UserRoleRepository {
	return &PostgresUserRoleRepository{
		db: db,
	}
}

// FindRolesByUser busca todos los roles de un usuario
func (r *PostgresUserRoleRepository) FindRolesByUser(ctx context.Context, userID kernel.UserID) ([]kernel.RoleID, error) {
	query := `
		SELECT role_id 
		FROM user_roles 
		WHERE user_id = $1
		ORDER BY assigned_at ASC`

	var roleIDs []string
	err := r.db.SelectContext(ctx, &roleIDs, query, userID.String())
	if err != nil {
		return nil, errx.Wrap(err, "failed to find roles by user", errx.TypeInternal).
			WithDetail("user_id", userID.String())
	}

	// Convertir a slice de kernel.RoleID
	result := make([]kernel.RoleID, len(roleIDs))
	for i, roleID := range roleIDs {
		result[i] = kernel.NewRoleID(roleID)
	}

	return result, nil
}

// AssignUserToRole asigna un usuario a un rol
func (r *PostgresUserRoleRepository) AssignUserToRole(ctx context.Context, userID kernel.UserID, roleID kernel.RoleID) error {
	query := `
		INSERT INTO user_roles (user_id, role_id, assigned_at)
		VALUES ($1, $2, NOW())
		ON CONFLICT (user_id, role_id) DO NOTHING`

	_, err := r.db.ExecContext(ctx, query, userID.String(), roleID.String())
	if err != nil {
		return errx.Wrap(err, "failed to assign user to role", errx.TypeInternal).
			WithDetail("user_id", userID.String()).
			WithDetail("role_id", roleID.String())
	}

	return nil
}

// RemoveUserFromRole remueve un usuario de un rol
func (r *PostgresUserRoleRepository) RemoveUserFromRole(ctx context.Context, userID kernel.UserID, roleID kernel.RoleID) error {
	query := `DELETE FROM user_roles WHERE user_id = $1 AND role_id = $2`

	result, err := r.db.ExecContext(ctx, query, userID.String(), roleID.String())
	if err != nil {
		return errx.Wrap(err, "failed to remove user from role", errx.TypeInternal).
			WithDetail("user_id", userID.String()).
			WithDetail("role_id", roleID.String())
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return errx.Wrap(err, "failed to get rows affected", errx.TypeInternal)
	}

	if rowsAffected == 0 {
		return errx.New("user role assignment not found", errx.TypeNotFound).
			WithDetail("user_id", userID.String()).
			WithDetail("role_id", roleID.String())
	}

	return nil
}

// RemoveAllUserRoles remueve todos los roles de un usuario
func (r *PostgresUserRoleRepository) RemoveAllUserRoles(ctx context.Context, userID kernel.UserID) error {
	query := `DELETE FROM user_roles WHERE user_id = $1`

	_, err := r.db.ExecContext(ctx, query, userID.String())
	if err != nil {
		return errx.Wrap(err, "failed to remove all user roles", errx.TypeInternal).
			WithDetail("user_id", userID.String())
	}

	return nil
}

// FindUsersByRole busca todos los usuarios que tienen un rol espec√≠fico (m√©todo adicional √∫til)
func (r *PostgresUserRoleRepository) FindUsersByRole(ctx context.Context, roleID kernel.RoleID) ([]kernel.UserID, error) {
	query := `
		SELECT user_id 
		FROM user_roles 
		WHERE role_id = $1
		ORDER BY assigned_at ASC`

	var userIDs []string
	err := r.db.SelectContext(ctx, &userIDs, query, roleID.String())
	if err != nil {
		return nil, errx.Wrap(err, "failed to find users by role", errx.TypeInternal).
			WithDetail("role_id", roleID.String())
	}

	// Convertir a slice de kernel.UserID
	result := make([]kernel.UserID, len(userIDs))
	for i, userID := range userIDs {
		result[i] = kernel.NewUserID(userID)
	}

	return result, nil
}

// CountUsersByRole cuenta los usuarios que tienen un rol espec√≠fico (m√©todo adicional √∫til)
func (r *PostgresUserRoleRepository) CountUsersByRole(ctx context.Context, roleID kernel.RoleID) (int, error) {
	query := `SELECT COUNT(*) FROM user_roles WHERE role_id = $1`

	var count int
	err := r.db.GetContext(ctx, &count, query, roleID.String())
	if err != nil {
		return 0, errx.Wrap(err, "failed to count users by role", errx.TypeInternal).
			WithDetail("role_id", roleID.String())
	}

	return count, nil
}

// CountRolesByUser cuenta los roles de un usuario (m√©todo adicional √∫til)
func (r *PostgresUserRoleRepository) CountRolesByUser(ctx context.Context, userID kernel.UserID) (int, error) {
	query := `SELECT COUNT(*) FROM user_roles WHERE user_id = $1`

	var count int
	err := r.db.GetContext(ctx, &count, query, userID.String())
	if err != nil {
		return 0, errx.Wrap(err, "failed to count roles by user", errx.TypeInternal).
			WithDetail("user_id", userID.String())
	}

	return count, nil
}

// BatchAssignUserToRoles asigna un usuario a m√∫ltiples roles (m√©todo adicional √∫til)
func (r *PostgresUserRoleRepository) BatchAssignUserToRoles(ctx context.Context, userID kernel.UserID, roleIDs []kernel.RoleID) error {
	if len(roleIDs) == 0 {
		return nil
	}

	tx, err := r.db.BeginTxx(ctx, nil)
	if err != nil {
		return errx.Wrap(err, "failed to begin transaction", errx.TypeInternal)
	}
	defer tx.Rollback()

	query := `
		INSERT INTO user_roles (user_id, role_id, assigned_at)
		VALUES ($1, $2, NOW())
		ON CONFLICT (user_id, role_id) DO NOTHING`

	for _, roleID := range roleIDs {
		_, err := tx.ExecContext(ctx, query, userID.String(), roleID.String())
		if err != nil {
			return errx.Wrap(err, "failed to assign user to role in batch", errx.TypeInternal).
				WithDetail("user_id", userID.String()).
				WithDetail("role_id", roleID.String())
		}
	}

	if err := tx.Commit(); err != nil {
		return errx.Wrap(err, "failed to commit user role batch transaction", errx.TypeInternal)
	}

	return nil
}

// HasRole verifica si un usuario tiene un rol espec√≠fico (m√©todo adicional √∫til)
func (r *PostgresUserRoleRepository) HasRole(ctx context.Context, userID kernel.UserID, roleID kernel.RoleID) (bool, error) {
	query := `SELECT EXISTS(SELECT 1 FROM user_roles WHERE user_id = $1 AND role_id = $2)`

	var exists bool
	err := r.db.GetContext(ctx, &exists, query, userID.String(), roleID.String())
	if err != nil {
		return false, errx.Wrap(err, "failed to check user role", errx.TypeInternal).
			WithDetail("user_id", userID.String()).
			WithDetail("role_id", roleID.String())
	}

	return exists, nil
}
package role

import (
	"net/http"
	"time"

	"github.com/Abraxas-365/craftable/errx"
	"github.com/Abraxas-365/relay/pkg/kernel"
)

// ============================================================================
// Role Entity
// ============================================================================

// Role representa un rol en el sistema
type Role struct {
	ID          kernel.RoleID   `db:"id" json:"id"`
	TenantID    kernel.TenantID `db:"tenant_id" json:"tenant_id"`
	Name        string          `db:"name" json:"name"`
	Description string          `db:"description" json:"description,omitempty"`
	IsActive    bool            `db:"is_active" json:"is_active"`
	CreatedAt   time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time       `db:"updated_at" json:"updated_at"`
}

// ============================================================================
// Domain Methods
// ============================================================================

// IsValid verifica si el rol es v√°lido
func (r *Role) IsValid() bool {
	return r.Name != "" && !r.TenantID.IsEmpty()
}

// Activate activa el rol
func (r *Role) Activate() {
	r.IsActive = true
	r.UpdatedAt = time.Now()
}

// Deactivate desactiva el rol
func (r *Role) Deactivate() {
	r.IsActive = false
	r.UpdatedAt = time.Now()
}

// UpdateDetails actualiza los detalles del rol
func (r *Role) UpdateDetails(name, description string) {
	if name != "" {
		r.Name = name
	}
	if description != "" {
		r.Description = description
	}
	r.UpdatedAt = time.Now()
}

// ============================================================================
// DTOs
// ============================================================================

// RoleDetailsDTO contiene informaci√≥n b√°sica de un rol para otros m√≥dulos
type RoleDetailsDTO struct {
	ID          kernel.RoleID   `json:"id"`
	TenantID    kernel.TenantID `json:"tenant_id"`
	Name        string          `json:"name"`
	Description string          `json:"description"`
	IsActive    bool            `json:"is_active"`
}

// ToDTO convierte la entidad Role a RoleDetailsDTO
func (r *Role) ToDTO() RoleDetailsDTO {
	return RoleDetailsDTO{
		ID:          r.ID,
		TenantID:    r.TenantID,
		Name:        r.Name,
		Description: r.Description,
		IsActive:    r.IsActive,
	}
}

// ============================================================================
// Service DTOs - Para operaciones de la capa de servicio
// ============================================================================

// CreateRoleRequest representa la petici√≥n para crear un rol
type CreateRoleRequest struct {
	TenantID    kernel.TenantID `json:"tenant_id" validate:"required"`
	Name        string          `json:"name" validate:"required,min=2"`
	Description string          `json:"description"`
	Permissions []string        `json:"permissions,omitempty"`
}

// UpdateRoleRequest representa la petici√≥n para actualizar un rol
type UpdateRoleRequest struct {
	TenantID    kernel.TenantID `json:"tenant_id" validate:"required"`
	Name        *string         `json:"name,omitempty" validate:"omitempty,min=2"`
	Description *string         `json:"description,omitempty"`
	IsActive    *bool           `json:"is_active,omitempty"`
}

// RoleResponse representa la respuesta completa de un rol con sus permisos
type RoleResponse struct {
	Role        Role     `json:"role"`
	Permissions []string `json:"permissions"`
}

// ToDTO convierte RoleResponse a RoleResponseDTO
func (rr *RoleResponse) ToDTO() RoleResponseDTO {
	return RoleResponseDTO{
		ID:          rr.Role.ID,
		TenantID:    rr.Role.TenantID,
		Name:        rr.Role.Name,
		Description: rr.Role.Description,
		IsActive:    rr.Role.IsActive,
		Permissions: rr.Permissions,
		CreatedAt:   rr.Role.CreatedAt,
		UpdatedAt:   rr.Role.UpdatedAt,
	}
}

// RoleResponseDTO es la versi√≥n DTO de RoleResponse
type RoleResponseDTO struct {
	ID          kernel.RoleID   `json:"id"`
	TenantID    kernel.TenantID `json:"tenant_id"`
	Name        string          `json:"name"`
	Description string          `json:"description"`
	IsActive    bool            `json:"is_active"`
	Permissions []string        `json:"permissions"`
	CreatedAt   time.Time       `json:"created_at"`
	UpdatedAt   time.Time       `json:"updated_at"`
}

// AssignPermissionRequest para asignar un permiso a un rol
type AssignPermissionRequest struct {
	TenantID   kernel.TenantID `json:"tenant_id" validate:"required"`
	Permission string          `json:"permission" validate:"required"`
}

// RemovePermissionRequest para remover un permiso de un rol
type RemovePermissionRequest struct {
	TenantID   kernel.TenantID `json:"tenant_id" validate:"required"`
	Permission string          `json:"permission" validate:"required"`
}

// SetPermissionsRequest para establecer todos los permisos de un rol
type SetPermissionsRequest struct {
	TenantID    kernel.TenantID `json:"tenant_id" validate:"required"`
	Permissions []string        `json:"permissions" validate:"required"`
}

// ActivateRoleRequest para activar un rol
type ActivateRoleRequest struct {
	TenantID kernel.TenantID `json:"tenant_id" validate:"required"`
}

// DeactivateRoleRequest para desactivar un rol
type DeactivateRoleRequest struct {
	TenantID kernel.TenantID `json:"tenant_id" validate:"required"`
}

// RoleListResponse para listas de roles
type RoleListResponse struct {
	Roles []RoleResponse `json:"roles"`
	Total int            `json:"total"`
}

// ToDTO convierte RoleListResponse a RoleListResponseDTO
func (rlr *RoleListResponse) ToDTO() RoleListResponseDTO {
	var rolesDTO []RoleResponseDTO
	for _, r := range rlr.Roles {
		rolesDTO = append(rolesDTO, r.ToDTO())
	}

	return RoleListResponseDTO{
		Roles: rolesDTO,
		Total: rlr.Total,
	}
}

// RoleListResponseDTO es la versi√≥n DTO de RoleListResponse
type RoleListResponseDTO struct {
	Roles []RoleResponseDTO `json:"roles"`
	Total int               `json:"total"`
}

// RolePermissionsResponse para respuesta de permisos de un rol
type RolePermissionsResponse struct {
	RoleID      kernel.RoleID `json:"role_id"`
	RoleName    string        `json:"role_name"`
	Permissions []string      `json:"permissions"`
}

// RoleUsersResponse para usuarios que tienen un rol espec√≠fico
type RoleUsersResponse struct {
	RoleID    kernel.RoleID   `json:"role_id"`
	RoleName  string          `json:"role_name"`
	UserIDs   []kernel.UserID `json:"user_ids"`
	UserCount int             `json:"user_count"`
}

// RoleStatsResponse para estad√≠sticas del rol
type RoleStatsResponse struct {
	RoleID           kernel.RoleID `json:"role_id"`
	RoleName         string        `json:"role_name"`
	IsActive         bool          `json:"is_active"`
	TotalPermissions int           `json:"total_permissions"`
	TotalUsers       int           `json:"total_users"`
	CreatedAt        time.Time     `json:"created_at"`
	LastUpdated      time.Time     `json:"last_updated"`
}

// BulkRoleOperationRequest para operaciones masivas en roles
type BulkRoleOperationRequest struct {
	TenantID  kernel.TenantID `json:"tenant_id" validate:"required"`
	RoleIDs   []kernel.RoleID `json:"role_ids" validate:"required,min=1"`
	Operation string          `json:"operation" validate:"required,oneof=activate deactivate delete"`
}

// BulkRoleOperationResponse resultado de operaciones masivas
type BulkRoleOperationResponse struct {
	Successful []kernel.RoleID          `json:"successful"`
	Failed     map[kernel.RoleID]string `json:"failed"`
	Total      int                      `json:"total"`
}

// CheckPermissionRequest para verificar si un rol tiene un permiso
type CheckPermissionRequest struct {
	TenantID   kernel.TenantID `json:"tenant_id" validate:"required"`
	Permission string          `json:"permission" validate:"required"`
}

// CheckPermissionResponse respuesta de verificaci√≥n de permiso
type CheckPermissionResponse struct {
	RoleID        kernel.RoleID `json:"role_id"`
	Permission    string        `json:"permission"`
	HasPermission bool          `json:"has_permission"`
}

// RolePermissionAuditResponse para auditor√≠a de permisos
type RolePermissionAuditResponse struct {
	RoleID      kernel.RoleID `json:"role_id"`
	RoleName    string        `json:"role_name"`
	Permission  string        `json:"permission"`
	Action      string        `json:"action"` // ASSIGNED, REMOVED
	PerformedBy kernel.UserID `json:"performed_by"`
	PerformedAt time.Time     `json:"performed_at"`
}

// AvailablePermissionsResponse para listar permisos disponibles
type AvailablePermissionsResponse struct {
	Permissions []PermissionInfo `json:"permissions"`
	Categories  []string         `json:"categories"`
}

// PermissionInfo informaci√≥n detallada de un permiso
type PermissionInfo struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	Category    string `json:"category"`
	IsSystem    bool   `json:"is_system"` // Si es un permiso del sistema que no se puede eliminar
}

// RoleTemplateRequest para crear roles desde plantillas
type RoleTemplateRequest struct {
	TenantID     kernel.TenantID `json:"tenant_id" validate:"required"`
	TemplateName string          `json:"template_name" validate:"required"`
	RoleName     string          `json:"role_name" validate:"required,min=2"`
	Description  string          `json:"description"`
}

// RoleTemplateResponse plantillas de roles disponibles
type RoleTemplateResponse struct {
	Templates []RoleTemplate `json:"templates"`
}

// RoleTemplate plantilla de rol predefinida
type RoleTemplate struct {
	Name        string   `json:"name"`
	Description string   `json:"description"`
	Permissions []string `json:"permissions"`
	Category    string   `json:"category"`
}

// CopyRoleRequest para copiar un rol existente
type CopyRoleRequest struct {
	TenantID           kernel.TenantID `json:"tenant_id" validate:"required"`
	SourceRoleID       kernel.RoleID   `json:"source_role_id" validate:"required"`
	NewRoleName        string          `json:"new_role_name" validate:"required,min=2"`
	NewRoleDescription string          `json:"new_role_description"`
	CopyPermissions    bool            `json:"copy_permissions"`
}

// ============================================================================
// Error Registry - Errores espec√≠ficos de Role
// ============================================================================

var ErrRegistry = errx.NewRegistry("ROLE")

// C√≥digos de error
var (
	CodeRoleNotFound         = ErrRegistry.Register("NOT_FOUND", errx.TypeNotFound, http.StatusNotFound, "Rol no encontrado")
	CodeRoleAlreadyExists    = ErrRegistry.Register("ALREADY_EXISTS", errx.TypeConflict, http.StatusConflict, "El rol ya existe")
	CodeRoleInUse            = ErrRegistry.Register("IN_USE", errx.TypeBusiness, http.StatusConflict, "El rol est√° siendo usado y no puede ser eliminado")
	CodeInvalidRoleName      = ErrRegistry.Register("INVALID_NAME", errx.TypeValidation, http.StatusBadRequest, "Nombre de rol inv√°lido")
	CodeInvalidPermission    = ErrRegistry.Register("INVALID_PERMISSION", errx.TypeValidation, http.StatusBadRequest, "Permiso inv√°lido")
	CodePermissionNotFound   = ErrRegistry.Register("PERMISSION_NOT_FOUND", errx.TypeNotFound, http.StatusNotFound, "Permiso no encontrado")
	CodeSystemRoleProtected  = ErrRegistry.Register("SYSTEM_ROLE_PROTECTED", errx.TypeBusiness, http.StatusForbidden, "No se puede modificar un rol del sistema")
	CodeRoleTemplateNotFound = ErrRegistry.Register("TEMPLATE_NOT_FOUND", errx.TypeNotFound, http.StatusNotFound, "Plantilla de rol no encontrada")
)

// Helper functions para crear errores
func ErrRoleNotFound() *errx.Error {
	return ErrRegistry.New(CodeRoleNotFound)
}

func ErrRoleAlreadyExists() *errx.Error {
	return ErrRegistry.New(CodeRoleAlreadyExists)
}

func ErrRoleInUse() *errx.Error {
	return ErrRegistry.New(CodeRoleInUse)
}

func ErrInvalidRoleName() *errx.Error {
	return ErrRegistry.New(CodeInvalidRoleName)
}

func ErrInvalidPermission() *errx.Error {
	return ErrRegistry.New(CodeInvalidPermission)
}

func ErrPermissionNotFound() *errx.Error {
	return ErrRegistry.New(CodePermissionNotFound)
}

func ErrSystemRoleProtected() *errx.Error {
	return ErrRegistry.New(CodeSystemRoleProtected)
}

func ErrRoleTemplateNotFound() *errx.Error {
	return ErrRegistry.New(CodeRoleTemplateNotFound)
}
package roleinfra

import (
	"context"
	"database/sql"

	"github.com/Abraxas-365/craftable/errx"
	"github.com/Abraxas-365/relay/iam/role"
	"github.com/Abraxas-365/relay/pkg/kernel"
	"github.com/jmoiron/sqlx"
	"github.com/lib/pq"
)

// PostgresRoleRepository implementaci√≥n de PostgreSQL para RoleRepository
type PostgresRoleRepository struct {
	db *sqlx.DB
}

// NewPostgresRoleRepository crea una nueva instancia del repositorio de roles
func NewPostgresRoleRepository(db *sqlx.DB) role.RoleRepository {
	return &PostgresRoleRepository{
		db: db,
	}
}

// FindByID busca un rol por ID y tenant
func (r *PostgresRoleRepository) FindByID(ctx context.Context, id kernel.RoleID, tenantID kernel.TenantID) (*role.Role, error) {
	query := `
		SELECT 
			id, tenant_id, name, description, is_active, created_at, updated_at
		FROM roles 
		WHERE id = $1 AND tenant_id = $2`

	var roleEntity role.Role
	err := r.db.GetContext(ctx, &roleEntity, query, id.String(), tenantID.String())
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, role.ErrRoleNotFound().WithDetail("role_id", id.String())
		}
		return nil, errx.Wrap(err, "failed to find role by id", errx.TypeInternal).
			WithDetail("role_id", id.String()).
			WithDetail("tenant_id", tenantID.String())
	}

	return &roleEntity, nil
}

// FindByTenant busca todos los roles de un tenant
func (r *PostgresRoleRepository) FindByTenant(ctx context.Context, tenantID kernel.TenantID) ([]*role.Role, error) {
	query := `
		SELECT 
			id, tenant_id, name, description, is_active, created_at, updated_at
		FROM roles 
		WHERE tenant_id = $1
		ORDER BY name ASC`

	var roles []role.Role
	err := r.db.SelectContext(ctx, &roles, query, tenantID.String())
	if err != nil {
		return nil, errx.Wrap(err, "failed to find roles by tenant", errx.TypeInternal).
			WithDetail("tenant_id", tenantID.String())
	}

	// Convertir a slice de punteros
	result := make([]*role.Role, len(roles))
	for i := range roles {
		result[i] = &roles[i]
	}

	return result, nil
}

// FindByName busca un rol por nombre y tenant
func (r *PostgresRoleRepository) FindByName(ctx context.Context, name string, tenantID kernel.TenantID) (*role.Role, error) {
	query := `
		SELECT 
			id, tenant_id, name, description, is_active, created_at, updated_at
		FROM roles 
		WHERE name = $1 AND tenant_id = $2`

	var roleEntity role.Role
	err := r.db.GetContext(ctx, &roleEntity, query, name, tenantID.String())
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, role.ErrRoleNotFound().WithDetail("name", name)
		}
		return nil, errx.Wrap(err, "failed to find role by name", errx.TypeInternal).
			WithDetail("name", name).
			WithDetail("tenant_id", tenantID.String())
	}

	return &roleEntity, nil
}

// FindActive busca todos los roles activos de un tenant
func (r *PostgresRoleRepository) FindActive(ctx context.Context, tenantID kernel.TenantID) ([]*role.Role, error) {
	query := `
		SELECT 
			id, tenant_id, name, description, is_active, created_at, updated_at
		FROM roles 
		WHERE tenant_id = $1 AND is_active = true
		ORDER BY name ASC`

	var roles []role.Role
	err := r.db.SelectContext(ctx, &roles, query, tenantID.String())
	if err != nil {
		return nil, errx.Wrap(err, "failed to find active roles", errx.TypeInternal).
			WithDetail("tenant_id", tenantID.String())
	}

	// Convertir a slice de punteros
	result := make([]*role.Role, len(roles))
	for i := range roles {
		result[i] = &roles[i]
	}

	return result, nil
}

// Save guarda o actualiza un rol
func (r *PostgresRoleRepository) Save(ctx context.Context, roleEntity role.Role) error {
	// Verificar si el rol ya existe
	exists, err := r.roleExists(ctx, roleEntity.ID, roleEntity.TenantID)
	if err != nil {
		return errx.Wrap(err, "failed to check role existence", errx.TypeInternal)
	}

	if exists {
		return r.update(ctx, roleEntity)
	}
	return r.create(ctx, roleEntity)
}

// create crea un nuevo rol
func (r *PostgresRoleRepository) create(ctx context.Context, roleEntity role.Role) error {
	query := `
		INSERT INTO roles (
			id, tenant_id, name, description, is_active, created_at, updated_at
		) VALUES (
			:id, :tenant_id, :name, :description, :is_active, :created_at, :updated_at
		)`

	_, err := r.db.NamedExecContext(ctx, query, roleEntity)
	if err != nil {
		// Verificar violaci√≥n de constraint de nombre √∫nico
		if pqErr, ok := err.(*pq.Error); ok {
			if pqErr.Code == "23505" && pqErr.Constraint == "roles_name_tenant_id_key" {
				return role.ErrRoleAlreadyExists().
					WithDetail("name", roleEntity.Name).
					WithDetail("tenant_id", roleEntity.TenantID.String())
			}
		}
		return errx.Wrap(err, "failed to create role", errx.TypeInternal).
			WithDetail("role_id", roleEntity.ID.String()).
			WithDetail("name", roleEntity.Name)
	}

	return nil
}

// update actualiza un rol existente
func (r *PostgresRoleRepository) update(ctx context.Context, roleEntity role.Role) error {
	query := `
		UPDATE roles SET
			name = :name,
			description = :description,
			is_active = :is_active,
			updated_at = :updated_at
		WHERE id = :id AND tenant_id = :tenant_id`

	result, err := r.db.NamedExecContext(ctx, query, roleEntity)
	if err != nil {
		// Verificar violaci√≥n de constraint de nombre √∫nico
		if pqErr, ok := err.(*pq.Error); ok {
			if pqErr.Code == "23505" && pqErr.Constraint == "roles_name_tenant_id_key" {
				return role.ErrRoleAlreadyExists().
					WithDetail("name", roleEntity.Name).
					WithDetail("tenant_id", roleEntity.TenantID.String())
			}
		}
		return errx.Wrap(err, "failed to update role", errx.TypeInternal).
			WithDetail("role_id", roleEntity.ID.String())
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return errx.Wrap(err, "failed to get rows affected", errx.TypeInternal)
	}

	if rowsAffected == 0 {
		return role.ErrRoleNotFound().WithDetail("role_id", roleEntity.ID.String())
	}

	return nil
}

// Delete elimina un rol
func (r *PostgresRoleRepository) Delete(ctx context.Context, id kernel.RoleID, tenantID kernel.TenantID) error {
	query := `DELETE FROM roles WHERE id = $1 AND tenant_id = $2`

	result, err := r.db.ExecContext(ctx, query, id.String(), tenantID.String())
	if err != nil {
		return errx.Wrap(err, "failed to delete role", errx.TypeInternal).
			WithDetail("role_id", id.String()).
			WithDetail("tenant_id", tenantID.String())
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return errx.Wrap(err, "failed to get rows affected", errx.TypeInternal)
	}

	if rowsAffected == 0 {
		return role.ErrRoleNotFound().WithDetail("role_id", id.String())
	}

	return nil
}

// ExistsByName verifica si existe un rol con el nombre dado en el tenant
func (r *PostgresRoleRepository) ExistsByName(ctx context.Context, name string, tenantID kernel.TenantID) (bool, error) {
	query := `SELECT EXISTS(SELECT 1 FROM roles WHERE name = $1 AND tenant_id = $2)`

	var exists bool
	err := r.db.GetContext(ctx, &exists, query, name, tenantID.String())
	if err != nil {
		return false, errx.Wrap(err, "failed to check role existence by name", errx.TypeInternal).
			WithDetail("name", name).
			WithDetail("tenant_id", tenantID.String())
	}

	return exists, nil
}

// roleExists verifica si un rol existe por ID y tenant
func (r *PostgresRoleRepository) roleExists(ctx context.Context, id kernel.RoleID, tenantID kernel.TenantID) (bool, error) {
	query := `SELECT EXISTS(SELECT 1 FROM roles WHERE id = $1 AND tenant_id = $2)`

	var exists bool
	err := r.db.GetContext(ctx, &exists, query, id.String(), tenantID.String())
	if err != nil {
		return false, errx.Wrap(err, "failed to check role existence", errx.TypeInternal).
			WithDetail("role_id", id.String()).
			WithDetail("tenant_id", tenantID.String())
	}

	return exists, nil
}

// CountByTenant cuenta los roles de un tenant (m√©todo adicional √∫til)
func (r *PostgresRoleRepository) CountByTenant(ctx context.Context, tenantID kernel.TenantID) (int, error) {
	query := `SELECT COUNT(*) FROM roles WHERE tenant_id = $1`

	var count int
	err := r.db.GetContext(ctx, &count, query, tenantID.String())
	if err != nil {
		return 0, errx.Wrap(err, "failed to count roles by tenant", errx.TypeInternal).
			WithDetail("tenant_id", tenantID.String())
	}

	return count, nil
}

// =============================================================================
// RolePermissionRepository Implementation
// =============================================================================

// PostgresRolePermissionRepository implementaci√≥n de PostgreSQL para RolePermissionRepository
type PostgresRolePermissionRepository struct {
	db *sqlx.DB
}

// NewPostgresRolePermissionRepository crea una nueva instancia del repositorio de permisos de roles
func NewPostgresRolePermissionRepository(db *sqlx.DB) role.RolePermissionRepository {
	return &PostgresRolePermissionRepository{
		db: db,
	}
}

// FindPermissionsByRole busca todos los permisos de un rol
func (r *PostgresRolePermissionRepository) FindPermissionsByRole(ctx context.Context, roleID kernel.RoleID) ([]string, error) {
	query := `
		SELECT permission 
		FROM role_permissions 
		WHERE role_id = $1
		ORDER BY permission ASC`

	var permissions []string
	err := r.db.SelectContext(ctx, &permissions, query, roleID.String())
	if err != nil {
		return nil, errx.Wrap(err, "failed to find permissions by role", errx.TypeInternal).
			WithDetail("role_id", roleID.String())
	}

	return permissions, nil
}

// AssignPermissionToRole asigna un permiso a un rol
func (r *PostgresRolePermissionRepository) AssignPermissionToRole(ctx context.Context, roleID kernel.RoleID, permission string) error {
	query := `
		INSERT INTO role_permissions (role_id, permission, assigned_at)
		VALUES ($1, $2, NOW())
		ON CONFLICT (role_id, permission) DO NOTHING`

	_, err := r.db.ExecContext(ctx, query, roleID.String(), permission)
	if err != nil {
		return errx.Wrap(err, "failed to assign permission to role", errx.TypeInternal).
			WithDetail("role_id", roleID.String()).
			WithDetail("permission", permission)
	}

	return nil
}

// RemovePermissionFromRole remueve un permiso de un rol
func (r *PostgresRolePermissionRepository) RemovePermissionFromRole(ctx context.Context, roleID kernel.RoleID, permission string) error {
	query := `DELETE FROM role_permissions WHERE role_id = $1 AND permission = $2`

	result, err := r.db.ExecContext(ctx, query, roleID.String(), permission)
	if err != nil {
		return errx.Wrap(err, "failed to remove permission from role", errx.TypeInternal).
			WithDetail("role_id", roleID.String()).
			WithDetail("permission", permission)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return errx.Wrap(err, "failed to get rows affected", errx.TypeInternal)
	}

	if rowsAffected == 0 {
		return role.ErrPermissionNotFound().
			WithDetail("role_id", roleID.String()).
			WithDetail("permission", permission)
	}

	return nil
}

// RemoveAllRolePermissions remueve todos los permisos de un rol
func (r *PostgresRolePermissionRepository) RemoveAllRolePermissions(ctx context.Context, roleID kernel.RoleID) error {
	query := `DELETE FROM role_permissions WHERE role_id = $1`

	_, err := r.db.ExecContext(ctx, query, roleID.String())
	if err != nil {
		return errx.Wrap(err, "failed to remove all role permissions", errx.TypeInternal).
			WithDetail("role_id", roleID.String())
	}

	return nil
}

// HasPermission verifica si un rol tiene un permiso espec√≠fico
func (r *PostgresRolePermissionRepository) HasPermission(ctx context.Context, roleID kernel.RoleID, permission string) (bool, error) {
	query := `SELECT EXISTS(SELECT 1 FROM role_permissions WHERE role_id = $1 AND permission = $2)`

	var exists bool
	err := r.db.GetContext(ctx, &exists, query, roleID.String(), permission)
	if err != nil {
		return false, errx.Wrap(err, "failed to check role permission", errx.TypeInternal).
			WithDetail("role_id", roleID.String()).
			WithDetail("permission", permission)
	}

	return exists, nil
}

// CountPermissionsByRole cuenta los permisos de un rol (m√©todo adicional √∫til)
func (r *PostgresRolePermissionRepository) CountPermissionsByRole(ctx context.Context, roleID kernel.RoleID) (int, error) {
	query := `SELECT COUNT(*) FROM role_permissions WHERE role_id = $1`

	var count int
	err := r.db.GetContext(ctx, &count, query, roleID.String())
	if err != nil {
		return 0, errx.Wrap(err, "failed to count permissions by role", errx.TypeInternal).
			WithDetail("role_id", roleID.String())
	}

	return count, nil
}

// BatchAssignPermissions asigna m√∫ltiples permisos a un rol (m√©todo adicional √∫til)
func (r *PostgresRolePermissionRepository) BatchAssignPermissions(ctx context.Context, roleID kernel.RoleID, permissions []string) error {
	if len(permissions) == 0 {
		return nil
	}

	tx, err := r.db.BeginTxx(ctx, nil)
	if err != nil {
		return errx.Wrap(err, "failed to begin transaction", errx.TypeInternal)
	}
	defer tx.Rollback()

	query := `
		INSERT INTO role_permissions (role_id, permission, assigned_at)
		VALUES ($1, $2, NOW())
		ON CONFLICT (role_id, permission) DO NOTHING`

	for _, permission := range permissions {
		_, err := tx.ExecContext(ctx, query, roleID.String(), permission)
		if err != nil {
			return errx.Wrap(err, "failed to assign permission in batch", errx.TypeInternal).
				WithDetail("role_id", roleID.String()).
				WithDetail("permission", permission)
		}
	}

	if err := tx.Commit(); err != nil {
		return errx.Wrap(err, "failed to commit permission batch transaction", errx.TypeInternal)
	}

	return nil
}
package role

import (
	"context"

	"github.com/Abraxas-365/relay/pkg/kernel"
)

// RoleRepository define el contrato para la persistencia de roles
type RoleRepository interface {
	FindByID(ctx context.Context, id kernel.RoleID, tenantID kernel.TenantID) (*Role, error)
	FindByTenant(ctx context.Context, tenantID kernel.TenantID) ([]*Role, error)
	FindByName(ctx context.Context, name string, tenantID kernel.TenantID) (*Role, error)
	FindActive(ctx context.Context, tenantID kernel.TenantID) ([]*Role, error)
	Save(ctx context.Context, r Role) error
	Delete(ctx context.Context, id kernel.RoleID, tenantID kernel.TenantID) error
	ExistsByName(ctx context.Context, name string, tenantID kernel.TenantID) (bool, error)
}

// RolePermissionRepository define el contrato para la relaci√≥n rol-permiso
type RolePermissionRepository interface {
	FindPermissionsByRole(ctx context.Context, roleID kernel.RoleID) ([]string, error)
	AssignPermissionToRole(ctx context.Context, roleID kernel.RoleID, permission string) error
	RemovePermissionFromRole(ctx context.Context, roleID kernel.RoleID, permission string) error
	RemoveAllRolePermissions(ctx context.Context, roleID kernel.RoleID) error
	HasPermission(ctx context.Context, roleID kernel.RoleID, permission string) (bool, error)
}
package rolesrv

import (
	"context"
	"time"

	"github.com/Abraxas-365/craftable/errx"
	"github.com/Abraxas-365/relay/iam/role"
	"github.com/Abraxas-365/relay/iam/tenant"
	"github.com/Abraxas-365/relay/iam/user"
	"github.com/Abraxas-365/relay/pkg/kernel"
	"github.com/google/uuid"
)

// RoleService proporciona operaciones de negocio para roles
type RoleService struct {
	roleRepo           role.RoleRepository
	rolePermissionRepo role.RolePermissionRepository
	userRoleRepo       user.UserRoleRepository
	tenantRepo         tenant.TenantRepository
}

// NewRoleService crea una nueva instancia del servicio de roles
func NewRoleService(
	roleRepo role.RoleRepository,
	rolePermissionRepo role.RolePermissionRepository,
	tenantRepo tenant.TenantRepository,
) *RoleService {
	return &RoleService{
		roleRepo:           roleRepo,
		rolePermissionRepo: rolePermissionRepo,
		tenantRepo:         tenantRepo,
	}
}

// CreateRole crea un nuevo rol
func (s *RoleService) CreateRole(ctx context.Context, req role.CreateRoleRequest) (*role.Role, error) {
	// Verificar que el tenant exista y est√© activo
	tenantEntity, err := s.tenantRepo.FindByID(ctx, req.TenantID)
	if err != nil {
		return nil, tenant.ErrTenantNotFound()
	}

	if !tenantEntity.IsActive() {
		return nil, tenant.ErrTenantSuspended()
	}

	// Verificar que no exista un rol con el mismo nombre en el tenant
	exists, err := s.roleRepo.ExistsByName(ctx, req.Name, req.TenantID)
	if err != nil {
		return nil, errx.Wrap(err, "failed to check role name existence", errx.TypeInternal)
	}
	if exists {
		return nil, role.ErrRoleAlreadyExists()
	}

	// Crear nuevo rol
	newRole := &role.Role{
		ID:          kernel.NewRoleID(uuid.NewString()),
		TenantID:    req.TenantID,
		Name:        req.Name,
		Description: req.Description,
		IsActive:    true,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}

	// Guardar rol
	if err := s.roleRepo.Save(ctx, *newRole); err != nil {
		return nil, errx.Wrap(err, "failed to save role", errx.TypeInternal)
	}

	// Asignar permisos si se especificaron
	if len(req.Permissions) > 0 {
		if err := s.assignPermissionsToRole(ctx, newRole.ID, req.Permissions); err != nil {
			// Log error pero no fallar
			// logger.Error("Failed to assign permissions to role", err)
		}
	}

	return newRole, nil
}

// GetRoleByID obtiene un rol por ID
func (s *RoleService) GetRoleByID(ctx context.Context, roleID kernel.RoleID, tenantID kernel.TenantID) (*role.RoleResponse, error) {
	roleEntity, err := s.roleRepo.FindByID(ctx, roleID, tenantID)
	if err != nil {
		return nil, role.ErrRoleNotFound()
	}

	// Obtener permisos del rol
	permissions, err := s.rolePermissionRepo.FindPermissionsByRole(ctx, roleID)
	if err != nil {
		permissions = []string{} // Default to empty slice
	}

	return &role.RoleResponse{
		Role:        *roleEntity,
		Permissions: permissions,
	}, nil
}

// GetRoleByName obtiene un rol por nombre
func (s *RoleService) GetRoleByName(ctx context.Context, name string, tenantID kernel.TenantID) (*role.RoleResponse, error) {
	roleEntity, err := s.roleRepo.FindByName(ctx, name, tenantID)
	if err != nil {
		return nil, role.ErrRoleNotFound()
	}

	// Obtener permisos del rol
	permissions, err := s.rolePermissionRepo.FindPermissionsByRole(ctx, roleEntity.ID)
	if err != nil {
		permissions = []string{}
	}

	return &role.RoleResponse{
		Role:        *roleEntity,
		Permissions: permissions,
	}, nil
}

// GetRolesByTenant obtiene todos los roles de un tenant
func (s *RoleService) GetRolesByTenant(ctx context.Context, tenantID kernel.TenantID) (*role.RoleListResponse, error) {
	roles, err := s.roleRepo.FindByTenant(ctx, tenantID)
	if err != nil {
		return nil, errx.Wrap(err, "failed to get roles by tenant", errx.TypeInternal)
	}

	var responses []role.RoleResponse
	for _, r := range roles {
		permissions, _ := s.rolePermissionRepo.FindPermissionsByRole(ctx, r.ID)
		responses = append(responses, role.RoleResponse{
			Role:        *r,
			Permissions: permissions,
		})
	}

	return &role.RoleListResponse{
		Roles: responses,
		Total: len(responses),
	}, nil
}

// GetActiveRoles obtiene todos los roles activos de un tenant
func (s *RoleService) GetActiveRoles(ctx context.Context, tenantID kernel.TenantID) (*role.RoleListResponse, error) {
	roles, err := s.roleRepo.FindActive(ctx, tenantID)
	if err != nil {
		return nil, errx.Wrap(err, "failed to get active roles", errx.TypeInternal)
	}

	var responses []role.RoleResponse
	for _, r := range roles {
		permissions, _ := s.rolePermissionRepo.FindPermissionsByRole(ctx, r.ID)
		responses = append(responses, role.RoleResponse{
			Role:        *r,
			Permissions: permissions,
		})
	}

	return &role.RoleListResponse{
		Roles: responses,
		Total: len(responses),
	}, nil
}

// UpdateRole actualiza un rol
func (s *RoleService) UpdateRole(ctx context.Context, roleID kernel.RoleID, req role.UpdateRoleRequest) (*role.Role, error) {
	roleEntity, err := s.roleRepo.FindByID(ctx, roleID, req.TenantID)
	if err != nil {
		return nil, role.ErrRoleNotFound()
	}

	// Actualizar campos si se proporcionaron
	if req.Name != nil {
		// Verificar que no exista otro rol con el mismo nombre
		if *req.Name != roleEntity.Name {
			exists, err := s.roleRepo.ExistsByName(ctx, *req.Name, req.TenantID)
			if err != nil {
				return nil, errx.Wrap(err, "failed to check role name", errx.TypeInternal)
			}
			if exists {
				return nil, role.ErrRoleAlreadyExists()
			}
			roleEntity.Name = *req.Name
		}
	}

	if req.Description != nil {
		roleEntity.Description = *req.Description
	}

	if req.IsActive != nil {
		if *req.IsActive {
			roleEntity.Activate()
		} else {
			roleEntity.Deactivate()
		}
	}

	roleEntity.UpdatedAt = time.Now()

	// Guardar cambios
	if err := s.roleRepo.Save(ctx, *roleEntity); err != nil {
		return nil, errx.Wrap(err, "failed to update role", errx.TypeInternal)
	}

	return roleEntity, nil
}

// ActivateRole activa un rol
func (s *RoleService) ActivateRole(ctx context.Context, roleID kernel.RoleID, tenantID kernel.TenantID) error {
	roleEntity, err := s.roleRepo.FindByID(ctx, roleID, tenantID)
	if err != nil {
		return role.ErrRoleNotFound()
	}

	roleEntity.Activate()
	return s.roleRepo.Save(ctx, *roleEntity)
}

// DeactivateRole desactiva un rol
func (s *RoleService) DeactivateRole(ctx context.Context, roleID kernel.RoleID, tenantID kernel.TenantID) error {
	roleEntity, err := s.roleRepo.FindByID(ctx, roleID, tenantID)
	if err != nil {
		return role.ErrRoleNotFound()
	}

	roleEntity.Deactivate()
	return s.roleRepo.Save(ctx, *roleEntity)
}

// AssignPermissionToRole asigna un permiso a un rol
func (s *RoleService) AssignPermissionToRole(ctx context.Context, roleID kernel.RoleID, permission string, tenantID kernel.TenantID) error {
	// Verificar que el rol existe
	_, err := s.roleRepo.FindByID(ctx, roleID, tenantID)
	if err != nil {
		return role.ErrRoleNotFound()
	}

	return s.rolePermissionRepo.AssignPermissionToRole(ctx, roleID, permission)
}

// RemovePermissionFromRole remueve un permiso de un rol
func (s *RoleService) RemovePermissionFromRole(ctx context.Context, roleID kernel.RoleID, permission string, tenantID kernel.TenantID) error {
	// Verificar que el rol existe
	_, err := s.roleRepo.FindByID(ctx, roleID, tenantID)
	if err != nil {
		return role.ErrRoleNotFound()
	}

	return s.rolePermissionRepo.RemovePermissionFromRole(ctx, roleID, permission)
}

// GetRolePermissions obtiene todos los permisos de un rol
func (s *RoleService) GetRolePermissions(ctx context.Context, roleID kernel.RoleID, tenantID kernel.TenantID) (*role.RolePermissionsResponse, error) {
	// Verificar que el rol existe
	roleEntity, err := s.roleRepo.FindByID(ctx, roleID, tenantID)
	if err != nil {
		return nil, role.ErrRoleNotFound()
	}

	permissions, err := s.rolePermissionRepo.FindPermissionsByRole(ctx, roleID)
	if err != nil {
		return nil, errx.Wrap(err, "failed to get role permissions", errx.TypeInternal)
	}

	return &role.RolePermissionsResponse{
		RoleID:      roleID,
		RoleName:    roleEntity.Name,
		Permissions: permissions,
	}, nil
}

// SetRolePermissions establece todos los permisos de un rol (reemplaza los existentes)
func (s *RoleService) SetRolePermissions(ctx context.Context, roleID kernel.RoleID, permissions []string, tenantID kernel.TenantID) error {
	// Verificar que el rol existe
	_, err := s.roleRepo.FindByID(ctx, roleID, tenantID)
	if err != nil {
		return role.ErrRoleNotFound()
	}

	// Remover todos los permisos existentes
	if err := s.rolePermissionRepo.RemoveAllRolePermissions(ctx, roleID); err != nil {
		return errx.Wrap(err, "failed to remove existing permissions", errx.TypeInternal)
	}

	// Asignar los nuevos permisos
	return s.assignPermissionsToRole(ctx, roleID, permissions)
}

// CheckRolePermission verifica si un rol tiene un permiso espec√≠fico
func (s *RoleService) CheckRolePermission(ctx context.Context, roleID kernel.RoleID, permission string, tenantID kernel.TenantID) (*role.CheckPermissionResponse, error) {
	// Verificar que el rol existe
	_, err := s.roleRepo.FindByID(ctx, roleID, tenantID)
	if err != nil {
		return nil, role.ErrRoleNotFound()
	}

	hasPermission, err := s.rolePermissionRepo.HasPermission(ctx, roleID, permission)
	if err != nil {
		return nil, errx.Wrap(err, "failed to check permission", errx.TypeInternal)
	}

	return &role.CheckPermissionResponse{
		RoleID:        roleID,
		Permission:    permission,
		HasPermission: hasPermission,
	}, nil
}

// CopyRole crea una copia de un rol existente
func (s *RoleService) CopyRole(ctx context.Context, req role.CopyRoleRequest) (*role.Role, error) {
	// Verificar que el rol fuente existe
	sourceRole, err := s.roleRepo.FindByID(ctx, req.SourceRoleID, req.TenantID)
	if err != nil {
		return nil, role.ErrRoleNotFound()
	}

	// Verificar que no exista un rol con el nuevo nombre
	exists, err := s.roleRepo.ExistsByName(ctx, req.NewRoleName, req.TenantID)
	if err != nil {
		return nil, errx.Wrap(err, "failed to check new role name", errx.TypeInternal)
	}
	if exists {
		return nil, role.ErrRoleAlreadyExists()
	}

	// Crear nuevo rol
	newRole := &role.Role{
		ID:          kernel.NewRoleID(uuid.NewString()),
		TenantID:    req.TenantID,
		Name:        req.NewRoleName,
		Description: req.NewRoleDescription,
		IsActive:    sourceRole.IsActive,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}

	// Si no se especific√≥ descripci√≥n, usar la del rol fuente
	if newRole.Description == "" {
		newRole.Description = "Copia de " + sourceRole.Name
	}

	// Guardar nuevo rol
	if err := s.roleRepo.Save(ctx, *newRole); err != nil {
		return nil, errx.Wrap(err, "failed to save copied role", errx.TypeInternal)
	}

	// Copiar permisos si se especific√≥
	if req.CopyPermissions {
		permissions, err := s.rolePermissionRepo.FindPermissionsByRole(ctx, req.SourceRoleID)
		if err == nil && len(permissions) > 0 {
			s.assignPermissionsToRole(ctx, newRole.ID, permissions)
		}
	}

	return newRole, nil
}

// DeleteRole elimina un rol
func (s *RoleService) DeleteRole(ctx context.Context, roleID kernel.RoleID, tenantID kernel.TenantID) error {
	// Verificar que el rol existe
	_, err := s.roleRepo.FindByID(ctx, roleID, tenantID)
	if err != nil {
		return role.ErrRoleNotFound()
	}

	// Verificar que el rol no est√© siendo usado
	userCount, err := s.userRoleRepo.CountUsersByRole(ctx, roleID)
	if err != nil {
		return errx.Wrap(err, "failed to check role usage", errx.TypeInternal)
	}
	if userCount > 0 {
		return role.ErrRoleInUse()
	}

	// Remover todos los permisos del rol
	if err := s.rolePermissionRepo.RemoveAllRolePermissions(ctx, roleID); err != nil {
		// Log error pero continuar
	}

	// Eliminar rol
	if err := s.roleRepo.Delete(ctx, roleID, tenantID); err != nil {
		return errx.Wrap(err, "failed to delete role", errx.TypeInternal)
	}

	return nil
}

// BulkActivateRoles activa m√∫ltiples roles
func (s *RoleService) BulkActivateRoles(ctx context.Context, roleIDs []kernel.RoleID, tenantID kernel.TenantID) (*role.BulkRoleOperationResponse, error) {
	result := &role.BulkRoleOperationResponse{
		Successful: []kernel.RoleID{},
		Failed:     make(map[kernel.RoleID]string),
		Total:      len(roleIDs),
	}

	for _, roleID := range roleIDs {
		if err := s.ActivateRole(ctx, roleID, tenantID); err != nil {
			result.Failed[roleID] = err.Error()
		} else {
			result.Successful = append(result.Successful, roleID)
		}
	}

	return result, nil
}

// BulkDeactivateRoles desactiva m√∫ltiples roles
func (s *RoleService) BulkDeactivateRoles(ctx context.Context, roleIDs []kernel.RoleID, tenantID kernel.TenantID) (*role.BulkRoleOperationResponse, error) {
	result := &role.BulkRoleOperationResponse{
		Successful: []kernel.RoleID{},
		Failed:     make(map[kernel.RoleID]string),
		Total:      len(roleIDs),
	}

	for _, roleID := range roleIDs {
		if err := s.DeactivateRole(ctx, roleID, tenantID); err != nil {
			result.Failed[roleID] = err.Error()
		} else {
			result.Successful = append(result.Successful, roleID)
		}
	}

	return result, nil
}

// GetAvailablePermissions obtiene todos los permisos disponibles del sistema
func (s *RoleService) GetAvailablePermissions(ctx context.Context) (*role.AvailablePermissionsResponse, error) {
	// Esta implementaci√≥n deber√≠a obtener los permisos desde una configuraci√≥n
	// o base de datos que defina todos los permisos disponibles del sistema
	permissions := s.getSystemPermissions()
	categories := s.getPermissionCategories()

	return &role.AvailablePermissionsResponse{
		Permissions: permissions,
		Categories:  categories,
	}, nil
}

// Helper function to assign multiple permissions to role
func (s *RoleService) assignPermissionsToRole(ctx context.Context, roleID kernel.RoleID, permissions []string) error {
	for _, permission := range permissions {
		if err := s.rolePermissionRepo.AssignPermissionToRole(ctx, roleID, permission); err != nil {
			return err
		}
	}
	return nil
}

// Helper functions para permisos del sistema (esto deber√≠a venir de configuraci√≥n)
func (s *RoleService) getSystemPermissions() []role.PermissionInfo {
	return []role.PermissionInfo{
		{Name: "users.create", Description: "Crear usuarios", Category: "Usuarios", IsSystem: true},
		{Name: "users.read", Description: "Ver usuarios", Category: "Usuarios", IsSystem: true},
		{Name: "users.update", Description: "Actualizar usuarios", Category: "Usuarios", IsSystem: true},
		{Name: "users.delete", Description: "Eliminar usuarios", Category: "Usuarios", IsSystem: true},
		{Name: "roles.create", Description: "Crear roles", Category: "Roles", IsSystem: true},
		{Name: "roles.read", Description: "Ver roles", Category: "Roles", IsSystem: true},
		{Name: "roles.update", Description: "Actualizar roles", Category: "Roles", IsSystem: true},
		{Name: "roles.delete", Description: "Eliminar roles", Category: "Roles", IsSystem: true},
		{Name: "invoices.create", Description: "Crear facturas", Category: "Facturas", IsSystem: true},
		{Name: "invoices.read", Description: "Ver facturas", Category: "Facturas", IsSystem: true},
		{Name: "invoices.approve", Description: "Aprobar facturas", Category: "Facturas", IsSystem: true},
		{Name: "reports.view", Description: "Ver reportes", Category: "Reportes", IsSystem: true},
		{Name: "admin.full", Description: "Acceso completo de administrador", Category: "Administraci√≥n", IsSystem: true},
	}
}

func (s *RoleService) getPermissionCategories() []string {
	return []string{
		"Usuarios",
		"Roles",
		"Facturas",
		"Reportes",
		"Administraci√≥n",
	}
}
package parser

import (
	"time"

	"github.com/Abraxas-365/relay/engine"
	"github.com/Abraxas-365/relay/pkg/kernel"
)

// ============================================================================
// Parser Entity
// ============================================================================

// Parser representa un analizador de mensajes
type Parser struct {
	ID          kernel.ParserID `db:"id" json:"id"`
	TenantID    kernel.TenantID `db:"tenant_id" json:"tenant_id"`
	Name        string          `db:"name" json:"name"`
	Description string          `db:"description" json:"description"`
	Type        ParserType      `db:"type" json:"type"`
	Config      ParserConfig    `db:"config" json:"config"`
	Priority    int             `db:"priority" json:"priority"` // Mayor n√∫mero = mayor prioridad
	IsActive    bool            `db:"is_active" json:"is_active"`
	CreatedAt   time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time       `db:"updated_at" json:"updated_at"`
}

// ============================================================================
// Parser Types & Enums
// ============================================================================

// ParserType tipo de parser
type ParserType string

const (
	ParserTypeRegex   ParserType = "REGEX"
	ParserTypeAI      ParserType = "AI"
	ParserTypeRule    ParserType = "RULE"
	ParserTypeKeyword ParserType = "KEYWORD"
	ParserTypeNLP     ParserType = "NLP"
)

// ParserConfig configuraci√≥n espec√≠fica por tipo de parser
type ParserConfig struct {
	// Regex Parser
	Patterns []RegexPattern `json:"patterns,omitempty"`

	// AI Parser
	Provider    string   `json:"provider,omitempty"` // openai, anthropic, gemini
	Model       string   `json:"model,omitempty"`
	Prompt      string   `json:"prompt,omitempty"`
	Tools       []string `json:"tools,omitempty"` // IDs de tools disponibles
	Temperature *float64 `json:"temperature,omitempty"`
	MaxTokens   *int     `json:"max_tokens,omitempty"`

	// Rule Parser
	Rules []Rule `json:"rules,omitempty"`

	// Keyword Parser
	Keywords []Keyword `json:"keywords,omitempty"`

	// NLP Parser
	NLPModel      string   `json:"nlp_model,omitempty"`
	Intents       []Intent `json:"intents,omitempty"`
	Entities      []Entity `json:"entities,omitempty"`
	MinConfidence float64  `json:"min_confidence,omitempty"`

	// General
	Timeout        *int           `json:"timeout,omitempty"`         // seconds
	FallbackParser *string        `json:"fallback_parser,omitempty"` // Parser ID
	CacheResults   bool           `json:"cache_results,omitempty"`
	Metadata       map[string]any `json:"metadata,omitempty"`
}

// RegexPattern patr√≥n regex con acciones
type RegexPattern struct {
	Name          string         `json:"name"`
	Pattern       string         `json:"pattern"`
	Description   string         `json:"description,omitempty"`
	Actions       []Action       `json:"actions"`
	Flags         string         `json:"flags,omitempty"`          // i, m, s, etc.
	CaptureGroups map[string]int `json:"capture_groups,omitempty"` // Nombre -> √≠ndice de grupo
}

// Rule regla l√≥gica con condiciones y acciones
type Rule struct {
	ID          string      `json:"id"`
	Name        string      `json:"name"`
	Description string      `json:"description,omitempty"`
	Conditions  []Condition `json:"conditions"`
	Operator    string      `json:"operator"` // AND, OR
	Actions     []Action    `json:"actions"`
	Priority    int         `json:"priority,omitempty"`
}

// Condition condici√≥n para reglas
type Condition struct {
	Field         string `json:"field"`    // message.text, message.sender, context.key
	Operator      string `json:"operator"` // equals, contains, matches, gt, lt, in, etc.
	Value         any    `json:"value"`
	CaseSensitive bool   `json:"case_sensitive,omitempty"`
}

// Action acci√≥n a ejecutar cuando se cumple una condici√≥n
type Action struct {
	Type   ActionType     `json:"type"`
	Config map[string]any `json:"config"`
}

// ActionType tipo de acci√≥n
type ActionType string

const (
	ActionTypeResponse        ActionType = "RESPONSE"
	ActionTypeTool            ActionType = "TOOL"
	ActionTypeRoute           ActionType = "ROUTE"
	ActionTypeSetContext      ActionType = "SET_CONTEXT"
	ActionTypeSetState        ActionType = "SET_STATE"
	ActionTypeTriggerWorkflow ActionType = "TRIGGER_WORKFLOW"
	ActionTypeWebhook         ActionType = "WEBHOOK"
	ActionTypeDelay           ActionType = "DELAY"
)

// Keyword palabra clave con acciones
type Keyword struct {
	Word          string   `json:"word"`
	Aliases       []string `json:"aliases,omitempty"`
	CaseSensitive bool     `json:"case_sensitive,omitempty"`
	MatchWhole    bool     `json:"match_whole,omitempty"` // Match palabra completa vs substring
	Actions       []Action `json:"actions"`
	Weight        float64  `json:"weight,omitempty"` // Para scoring m√∫ltiple
}

// Intent intenci√≥n detectada por NLP
type Intent struct {
	Name             string   `json:"name"`
	Examples         []string `json:"examples"`
	Actions          []Action `json:"actions"`
	RequiredEntities []string `json:"required_entities,omitempty"`
}

// Entity entidad extra√≠da por NLP
type Entity struct {
	Name    string   `json:"name"`
	Type    string   `json:"type"` // person, location, date, custom
	Aliases []string `json:"aliases,omitempty"`
}

// ============================================================================
// Parse Result
// ============================================================================

// ParseResult resultado del parsing
type ParseResult struct {
	Success       bool             `json:"success"`
	ParserID      kernel.ParserID  `json:"parser_id"`
	ParserName    string           `json:"parser_name"`
	Response      string           `json:"response,omitempty"`
	ShouldRespond bool             `json:"should_respond"`
	Actions       []Action         `json:"actions,omitempty"`
	Context       map[string]any   `json:"context,omitempty"`
	ExtractedData map[string]any   `json:"extracted_data,omitempty"` // Datos extra√≠dos (regex groups, entities, etc.)
	Confidence    float64          `json:"confidence,omitempty"`     // 0-1
	NextParser    *kernel.ParserID `json:"next_parser,omitempty"`
	Metadata      map[string]any   `json:"metadata,omitempty"`
	Error         string           `json:"error,omitempty"`
	ProcessedAt   time.Time        `json:"processed_at"`
}

// ============================================================================
// Domain Methods - Parser
// ============================================================================

// IsValid verifica si el parser es v√°lido
func (p *Parser) IsValid() bool {
	return p.Name != "" && p.Type != "" && !p.TenantID.IsEmpty()
}

// Activate activa el parser
func (p *Parser) Activate() {
	p.IsActive = true
	p.UpdatedAt = time.Now()
}

// Deactivate desactiva el parser
func (p *Parser) Deactivate() {
	p.IsActive = false
	p.UpdatedAt = time.Now()
}

// UpdateConfig actualiza la configuraci√≥n
func (p *Parser) UpdateConfig(config ParserConfig) {
	p.Config = config
	p.UpdatedAt = time.Now()
}

// UpdateDetails actualiza nombre y descripci√≥n
func (p *Parser) UpdateDetails(name, description string) {
	if name != "" {
		p.Name = name
	}
	if description != "" {
		p.Description = description
	}
	p.UpdatedAt = time.Now()
}

// UpdatePriority actualiza la prioridad
func (p *Parser) UpdatePriority(priority int) {
	p.Priority = priority
	p.UpdatedAt = time.Now()
}

// HasAIConfig verifica si tiene configuraci√≥n AI
func (p *Parser) HasAIConfig() bool {
	return p.Type == ParserTypeAI && p.Config.Provider != ""
}

// HasRegexPatterns verifica si tiene patrones regex
func (p *Parser) HasRegexPatterns() bool {
	return p.Type == ParserTypeRegex && len(p.Config.Patterns) > 0
}

// HasRules verifica si tiene reglas
func (p *Parser) HasRules() bool {
	return p.Type == ParserTypeRule && len(p.Config.Rules) > 0
}

// GetTimeout obtiene el timeout configurado o default
func (p *Parser) GetTimeout() int {
	if p.Config.Timeout != nil && *p.Config.Timeout > 0 {
		return *p.Config.Timeout
	}
	return 30 // 30 segundos por defecto
}

// ============================================================================
// Domain Methods - ParseResult
// ============================================================================

// IsSuccessful verifica si el parsing fue exitoso
func (pr *ParseResult) IsSuccessful() bool {
	return pr.Success && pr.Error == ""
}

// HasActions verifica si hay acciones para ejecutar
func (pr *ParseResult) HasActions() bool {
	return len(pr.Actions) > 0
}

// GetAction obtiene una acci√≥n por tipo
func (pr *ParseResult) GetAction(actionType ActionType) *Action {
	for i := range pr.Actions {
		if pr.Actions[i].Type == actionType {
			return &pr.Actions[i]
		}
	}
	return nil
}

// GetActionsByType obtiene todas las acciones de un tipo
func (pr *ParseResult) GetActionsByType(actionType ActionType) []Action {
	var actions []Action
	for _, action := range pr.Actions {
		if action.Type == actionType {
			actions = append(actions, action)
		}
	}
	return actions
}

// HasExtractedData verifica si hay datos extra√≠dos
func (pr *ParseResult) HasExtractedData() bool {
	return len(pr.ExtractedData) > 0
}

// GetExtractedValue obtiene un valor extra√≠do
func (pr *ParseResult) GetExtractedValue(key string) (any, bool) {
	if pr.ExtractedData == nil {
		return nil, false
	}
	val, ok := pr.ExtractedData[key]
	return val, ok
}

// SetExtractedValue establece un valor extra√≠do
func (pr *ParseResult) SetExtractedValue(key string, value any) {
	if pr.ExtractedData == nil {
		pr.ExtractedData = make(map[string]any)
	}
	pr.ExtractedData[key] = value
}

// MergeContext combina contexto existente con nuevo
func (pr *ParseResult) MergeContext(newContext map[string]any) {
	if pr.Context == nil {
		pr.Context = make(map[string]any)
	}
	for k, v := range newContext {
		pr.Context[k] = v
	}
}

// IsHighConfidence verifica si tiene alta confianza (> 0.8)
func (pr *ParseResult) IsHighConfidence() bool {
	return pr.Confidence > 0.8
}

// ============================================================================
// Domain Methods - Rule
// ============================================================================

// IsValid verifica si la regla es v√°lida
func (r *Rule) IsValid() bool {
	return r.Name != "" && len(r.Conditions) > 0 && len(r.Actions) > 0
}

// HasOperator verifica el operador
func (r *Rule) IsAND() bool {
	return r.Operator == "AND" || r.Operator == ""
}

func (r *Rule) IsOR() bool {
	return r.Operator == "OR"
}

// ============================================================================
// Domain Methods - Condition
// ============================================================================

// IsValid verifica si la condici√≥n es v√°lida
func (c *Condition) IsValid() bool {
	return c.Field != "" && c.Operator != "" && c.Value != nil
}

// ============================================================================
// Helper Functions
// ============================================================================

// NewParseResult crea un nuevo resultado de parsing
func NewParseResult(parserID kernel.ParserID, parserName string) *ParseResult {
	return &ParseResult{
		ParserID:      parserID,
		ParserName:    parserName,
		Context:       make(map[string]any),
		ExtractedData: make(map[string]any),
		Metadata:      make(map[string]any),
		ProcessedAt:   time.Now(),
	}
}

// NewSuccessResult crea un resultado exitoso
func NewSuccessResult(parserID kernel.ParserID, parserName string) *ParseResult {
	result := NewParseResult(parserID, parserName)
	result.Success = true
	return result
}

// NewFailureResult crea un resultado fallido
func NewFailureResult(parserID kernel.ParserID, parserName string, err error) *ParseResult {
	result := NewParseResult(parserID, parserName)
	result.Success = false
	result.Error = err.Error()
	return result
}

// ============================================================================
// Parser Selection Context
// ============================================================================

// SelectionContext contexto para selecci√≥n de parser
type SelectionContext struct {
	Message          engine.Message
	Session          *engine.Session
	AvailableParsers []*Parser
	PreviousResults  []*ParseResult
	Metadata         map[string]any
}

// NewSelectionContext crea un nuevo contexto de selecci√≥n
func NewSelectionContext(message engine.Message, session *engine.Session, parsers []*Parser) *SelectionContext {
	return &SelectionContext{
		Message:          message,
		Session:          session,
		AvailableParsers: parsers,
		PreviousResults:  make([]*ParseResult, 0),
		Metadata:         make(map[string]any),
	}
}

// AddResult a√±ade un resultado previo
func (sc *SelectionContext) AddResult(result *ParseResult) {
	sc.PreviousResults = append(sc.PreviousResults, result)
}

// GetLastResult obtiene el √∫ltimo resultado
func (sc *SelectionContext) GetLastResult() *ParseResult {
	if len(sc.PreviousResults) == 0 {
		return nil
	}
	return sc.PreviousResults[len(sc.PreviousResults)-1]
}

// HasSuccessfulResult verifica si hay alg√∫n resultado exitoso
func (sc *SelectionContext) HasSuccessfulResult() bool {
	for _, result := range sc.PreviousResults {
		if result.IsSuccessful() {
			return true
		}
	}
	return false
}
package parserinfra

import (
	"context"
	"github.com/Abraxas-365/relay/engine"
	"github.com/Abraxas-365/relay/parser"
	"regexp"
)

type RegexParserEngine struct{}

func NewRegexParserEngine() *RegexParserEngine {
	return &RegexParserEngine{}
}

func (rpe *RegexParserEngine) Parse(ctx context.Context, p parser.Parser, msg engine.Message, session *engine.Session) (*parser.ParseResult, error) {
	messageText := msg.Content.Text

	// Iterar patterns
	for _, pattern := range p.Config.Patterns {
		re, err := regexp.Compile(pattern.Pattern)
		if err != nil {
			continue
		}

		if re.MatchString(messageText) {
			// Match encontrado, ejecutar acciones
			return &parser.ParseResult{
				Success:       true,
				Actions:       pattern.Actions,
				ShouldRespond: hasResponseAction(pattern.Actions),
				Response:      extractResponse(pattern.Actions),
			}, nil
		}
	}

	// No match
	return &parser.ParseResult{
		Success: false,
	}, nil
}

func hasResponseAction(actions []parser.Action) bool {
	for _, action := range actions {
		if action.Type == "response" {
			return true
		}
	}
	return false
}

func extractResponse(actions []parser.Action) string {
	for _, action := range actions {
		if action.Type == "response" {
			if msg, ok := action.Config["message"].(string); ok {
				return msg
			}
		}
	}
	return ""
}
package parser

import (
	"context"

	"github.com/Abraxas-365/relay/engine"
	"github.com/Abraxas-365/relay/pkg/kernel"
)

// ============================================================================
// Repository Interface
// ============================================================================

// ParserRepository define el contrato para persistencia de parsers
type ParserRepository interface {
	// CRUD b√°sico
	Save(ctx context.Context, parser Parser) error
	FindByID(ctx context.Context, id kernel.ParserID, tenantID kernel.TenantID) (*Parser, error)
	FindByName(ctx context.Context, name string, tenantID kernel.TenantID) (*Parser, error)
	Delete(ctx context.Context, id kernel.ParserID, tenantID kernel.TenantID) error
	ExistsByName(ctx context.Context, name string, tenantID kernel.TenantID) (bool, error)

	// B√∫squedas
	FindByTenant(ctx context.Context, tenantID kernel.TenantID) ([]*Parser, error)
	FindByType(ctx context.Context, parserType ParserType, tenantID kernel.TenantID) ([]*Parser, error)
	FindActive(ctx context.Context, tenantID kernel.TenantID) ([]*Parser, error)
	FindByPriority(ctx context.Context, tenantID kernel.TenantID) ([]*Parser, error) // Ordenado por prioridad desc

	// List con paginaci√≥n
	List(ctx context.Context, req ListParsersRequest) (ParserListResponse, error)

	// Bulk operations
	BulkUpdateStatus(ctx context.Context, ids []kernel.ParserID, tenantID kernel.TenantID, isActive bool) error
}

// ============================================================================
// Engine Interface
// ============================================================================

// ParserEngine ejecuta parsers seg√∫n su tipo
type ParserEngine interface {
	// Parse procesa un mensaje con un parser espec√≠fico
	Parse(ctx context.Context, parser Parser, message engine.Message, session *engine.Session) (*ParseResult, error)

	// Soporta el tipo de parser
	SupportsType(parserType ParserType) bool

	// Validar configuraci√≥n del parser
	ValidateConfig(parserType ParserType, config ParserConfig) error
}

// ============================================================================
// Selector Interface
// ============================================================================

// ParserSelector selecciona el parser apropiado para un mensaje
type ParserSelector interface {
	// SelectParser selecciona el mejor parser para un mensaje
	SelectParser(ctx context.Context, selectionCtx *SelectionContext) (*Parser, error)

	// SelectParsers selecciona m√∫ltiples parsers (para cascada)
	SelectParsers(ctx context.Context, selectionCtx *SelectionContext, maxParsers int) ([]*Parser, error)

	// ShouldRetry determina si se debe intentar con otro parser
	ShouldRetry(ctx context.Context, result *ParseResult) bool
}

// ============================================================================
// Orchestrator Interface
// ============================================================================

// ParserOrchestrator orquesta la ejecuci√≥n de m√∫ltiples parsers
type ParserOrchestrator interface {
	// Process procesa un mensaje con la cadena de parsers apropiada
	Process(ctx context.Context, message engine.Message, session *engine.Session) (*ParseResult, error)

	// ProcessWithParser procesa con un parser espec√≠fico
	ProcessWithParser(ctx context.Context, parserID kernel.ParserID, message engine.Message, session *engine.Session) (*ParseResult, error)

	// ProcessCascade procesa en cascada hasta encontrar un resultado exitoso
	ProcessCascade(ctx context.Context, message engine.Message, session *engine.Session, maxAttempts int) (*ParseResult, error)
}

// ============================================================================
// Validator Interface
// ============================================================================

// ParserValidator valida parsers
type ParserValidator interface {
	// ValidateParser valida un parser completo
	ValidateParser(parser Parser) error

	// ValidateConfig valida configuraci√≥n por tipo
	ValidateConfig(parserType ParserType, config ParserConfig) error

	// ValidateRegexPatterns valida patrones regex
	ValidateRegexPatterns(patterns []RegexPattern) error

	// ValidateRules valida reglas
	ValidateRules(rules []Rule) error

	// ValidateActions valida acciones
	ValidateActions(actions []Action) error
}

// ============================================================================
// Cache Interface
// ============================================================================

// ParserCache cachea resultados de parsing
type ParserCache interface {
	// Get obtiene resultado cacheado
	Get(ctx context.Context, cacheKey string) (*ParseResult, error)

	// Set guarda resultado en cache
	Set(ctx context.Context, cacheKey string, result *ParseResult, ttl int) error

	// Delete elimina del cache
	Delete(ctx context.Context, cacheKey string) error

	// Clear limpia cache de un tenant
	Clear(ctx context.Context, tenantID kernel.TenantID) error

	// GenerateKey genera una clave de cache
	GenerateKey(message engine.Message, parserID kernel.ParserID) string
}
package parser

import (
	"github.com/Abraxas-365/craftable/storex"
	"github.com/Abraxas-365/relay/engine"
	"github.com/Abraxas-365/relay/pkg/kernel"
)

// CreateParserRequest request para crear un parser
type CreateParserRequest struct {
	TenantID    kernel.TenantID `json:"tenant_id" validate:"required"`
	Name        string          `json:"name" validate:"required,min=2"`
	Description string          `json:"description"`
	Type        ParserType      `json:"type" validate:"required"`
	Config      ParserConfig    `json:"config" validate:"required"`
	Priority    int             `json:"priority"`
}

// UpdateParserRequest request para actualizar un parser
type UpdateParserRequest struct {
	Name        *string       `json:"name,omitempty"`
	Description *string       `json:"description,omitempty"`
	Config      *ParserConfig `json:"config,omitempty"`
	Priority    *int          `json:"priority,omitempty"`
	IsActive    *bool         `json:"is_active,omitempty"`
}

// ParseMessageRequest request para parsear un mensaje
type ParseMessageRequest struct {
	ParserID  *kernel.ParserID `json:"parser_id,omitempty"` // Si es nil, usa selector
	Message   engine.Message   `json:"message" validate:"required"`
	SessionID *string          `json:"session_id,omitempty"`
}

// ListParsersRequest request para listar parsers
type ListParsersRequest struct {
	storex.PaginationOptions

	TenantID kernel.TenantID `json:"tenant_id" validate:"required"`
	Type     *ParserType     `json:"type,omitempty"`
	IsActive *bool           `json:"is_active,omitempty"`
	Search   string          `json:"search,omitempty"`
}

// ParserListResponse lista paginada de parsers
type ParserListResponse = storex.Paginated[Parser]

// ParserResponse respuesta con parser
type ParserResponse struct {
	Parser Parser `json:"parser"`
}

// ParseResultResponse respuesta de parsing
type ParseResultResponse struct {
	Result ParseResult `json:"result"`
}

// ParserStatsResponse estad√≠sticas de parser
type ParserStatsResponse struct {
	ParserID       kernel.ParserID `json:"parser_id"`
	ParserName     string          `json:"parser_name"`
	TotalParses    int             `json:"total_parses"`
	SuccessCount   int             `json:"success_count"`
	FailureCount   int             `json:"failure_count"`
	AvgConfidence  float64         `json:"avg_confidence"`
	AvgProcessTime float64         `json:"avg_process_time_ms"`
	LastUsedAt     *string         `json:"last_used_at,omitempty"`
}

// BulkParserOperationRequest request para operaciones masivas
type BulkParserOperationRequest struct {
	TenantID  kernel.TenantID   `json:"tenant_id" validate:"required"`
	ParserIDs []kernel.ParserID `json:"parser_ids" validate:"required,min=1"`
	Operation string            `json:"operation" validate:"required,oneof=activate deactivate delete"`
}

// BulkParserOperationResponse respuesta de operaci√≥n masiva
type BulkParserOperationResponse struct {
	Successful []kernel.ParserID          `json:"successful"`
	Failed     map[kernel.ParserID]string `json:"failed"`
	Total      int                        `json:"total"`
}

// ValidateParserRequest request para validar parser
type ValidateParserRequest struct {
	Type   ParserType   `json:"type" validate:"required"`
	Config ParserConfig `json:"config" validate:"required"`
}

// ValidateParserResponse respuesta de validaci√≥n
type ValidateParserResponse struct {
	IsValid  bool     `json:"is_valid"`
	Errors   []string `json:"errors,omitempty"`
	Warnings []string `json:"warnings,omitempty"`
}

// ParserDetailsDTO DTO simplificado de parser
type ParserDetailsDTO struct {
	ID       kernel.ParserID `json:"id"`
	Name     string          `json:"name"`
	Type     ParserType      `json:"type"`
	Priority int             `json:"priority"`
	IsActive bool            `json:"is_active"`
}

// ToDTO convierte Parser a ParserDetailsDTO
func (p *Parser) ToDTO() ParserDetailsDTO {
	return ParserDetailsDTO{
		ID:       p.ID,
		Name:     p.Name,
		Type:     p.Type,
		Priority: p.Priority,
		IsActive: p.IsActive,
	}
}
package parser

import (
	"net/http"

	"github.com/Abraxas-365/craftable/errx"
)

// ============================================================================
// Error Registry
// ============================================================================

var ErrRegistry = errx.NewRegistry("PARSER")

// ============================================================================
// Error Codes - Parser
// ============================================================================

var (
	CodeParserNotFound      = ErrRegistry.Register("PARSER_NOT_FOUND", errx.TypeNotFound, http.StatusNotFound, "Parser no encontrado")
	CodeParserAlreadyExists = ErrRegistry.Register("PARSER_ALREADY_EXISTS", errx.TypeConflict, http.StatusConflict, "Parser ya existe")
	CodeInvalidParserType   = ErrRegistry.Register("INVALID_PARSER_TYPE", errx.TypeValidation, http.StatusBadRequest, "Tipo de parser inv√°lido")
	CodeInvalidParserConfig = ErrRegistry.Register("INVALID_PARSER_CONFIG", errx.TypeValidation, http.StatusBadRequest, "Configuraci√≥n de parser inv√°lida")
	CodeParserInactive      = ErrRegistry.Register("PARSER_INACTIVE", errx.TypeBusiness, http.StatusForbidden, "Parser est√° inactivo")
	CodeParserNotSupported  = ErrRegistry.Register("PARSER_NOT_SUPPORTED", errx.TypeValidation, http.StatusBadRequest, "Tipo de parser no soportado")
)

// ============================================================================
// Error Codes - Parsing
// ============================================================================

var (
	CodeParsingFailed   = ErrRegistry.Register("PARSING_FAILED", errx.TypeInternal, http.StatusInternalServerError, "Fallo al parsear mensaje")
	CodeNoMatchFound    = ErrRegistry.Register("NO_MATCH_FOUND", errx.TypeBusiness, http.StatusNotFound, "No se encontr√≥ coincidencia")
	CodeInvalidInput    = ErrRegistry.Register("INVALID_INPUT", errx.TypeValidation, http.StatusBadRequest, "Input inv√°lido para parser")
	CodeParsingTimeout  = ErrRegistry.Register("PARSING_TIMEOUT", errx.TypeInternal, http.StatusRequestTimeout, "Parsing excedi√≥ timeout")
	CodeLowConfidence   = ErrRegistry.Register("LOW_CONFIDENCE", errx.TypeBusiness, http.StatusPartialContent, "Confianza de parsing baja")
	CodeAmbiguousResult = ErrRegistry.Register("AMBIGUOUS_RESULT", errx.TypeBusiness, http.StatusMultipleChoices, "Resultado ambiguo")
)

// ============================================================================
// Error Codes - Regex Parser
// ============================================================================

var (
	CodeInvalidRegexPattern = ErrRegistry.Register("INVALID_REGEX_PATTERN", errx.TypeValidation, http.StatusBadRequest, "Patr√≥n regex inv√°lido")
	CodeRegexCompileFailed  = ErrRegistry.Register("REGEX_COMPILE_FAILED", errx.TypeValidation, http.StatusBadRequest, "Fallo al compilar regex")
	CodeInvalidCaptureGroup = ErrRegistry.Register("INVALID_CAPTURE_GROUP", errx.TypeValidation, http.StatusBadRequest, "Grupo de captura inv√°lido")
	CodeNoPatternsDefined   = ErrRegistry.Register("NO_PATTERNS_DEFINED", errx.TypeValidation, http.StatusBadRequest, "No hay patrones definidos")
)

// ============================================================================
// Error Codes - AI Parser
// ============================================================================

var (
	CodeAIProviderNotConfigured = ErrRegistry.Register("AI_PROVIDER_NOT_CONFIGURED", errx.TypeValidation, http.StatusBadRequest, "Proveedor AI no configurado")
	CodeAIRequestFailed         = ErrRegistry.Register("AI_REQUEST_FAILED", errx.TypeExternal, http.StatusBadGateway, "Request a AI fall√≥")
	CodeAIInvalidResponse       = ErrRegistry.Register("AI_INVALID_RESPONSE", errx.TypeExternal, http.StatusBadGateway, "Respuesta de AI inv√°lida")
	CodeAIQuotaExceeded         = ErrRegistry.Register("AI_QUOTA_EXCEEDED", errx.TypeExternal, http.StatusTooManyRequests, "Cuota de AI excedida")
	CodeInvalidPrompt           = ErrRegistry.Register("INVALID_PROMPT", errx.TypeValidation, http.StatusBadRequest, "Prompt inv√°lido")
	CodeInvalidModel            = ErrRegistry.Register("INVALID_MODEL", errx.TypeValidation, http.StatusBadRequest, "Modelo de AI inv√°lido")
)

// ============================================================================
// Error Codes - Rule Parser
// ============================================================================

var (
	CodeInvalidRule         = ErrRegistry.Register("INVALID_RULE", errx.TypeValidation, http.StatusBadRequest, "Regla inv√°lida")
	CodeInvalidCondition    = ErrRegistry.Register("INVALID_CONDITION", errx.TypeValidation, http.StatusBadRequest, "Condici√≥n inv√°lida")
	CodeConditionEvalFailed = ErrRegistry.Register("CONDITION_EVAL_FAILED", errx.TypeInternal, http.StatusInternalServerError, "Evaluaci√≥n de condici√≥n fall√≥")
	CodeNoRulesDefined      = ErrRegistry.Register("NO_RULES_DEFINED", errx.TypeValidation, http.StatusBadRequest, "No hay reglas definidas")
	CodeInvalidRuleOperator = ErrRegistry.Register("INVALID_RULE_OPERATOR", errx.TypeValidation, http.StatusBadRequest, "Operador de regla inv√°lido")
)

// ============================================================================
// Error Codes - Keyword Parser
// ============================================================================

var (
	CodeNoKeywordsDefined  = ErrRegistry.Register("NO_KEYWORDS_DEFINED", errx.TypeValidation, http.StatusBadRequest, "No hay keywords definidos")
	CodeInvalidKeyword     = ErrRegistry.Register("INVALID_KEYWORD", errx.TypeValidation, http.StatusBadRequest, "Keyword inv√°lido")
	CodeKeywordMatchFailed = ErrRegistry.Register("KEYWORD_MATCH_FAILED", errx.TypeInternal, http.StatusInternalServerError, "Fallo al buscar keywords")
)

// ============================================================================
// Error Codes - NLP Parser
// ============================================================================

var (
	CodeNLPModelNotFound       = ErrRegistry.Register("NLP_MODEL_NOT_FOUND", errx.TypeNotFound, http.StatusNotFound, "Modelo NLP no encontrado")
	CodeNLPModelLoadFailed     = ErrRegistry.Register("NLP_MODEL_LOAD_FAILED", errx.TypeInternal, http.StatusInternalServerError, "Fallo al cargar modelo NLP")
	CodeIntentNotRecognized    = ErrRegistry.Register("INTENT_NOT_RECOGNIZED", errx.TypeBusiness, http.StatusNotFound, "Intenci√≥n no reconocida")
	CodeEntityExtractionFailed = ErrRegistry.Register("ENTITY_EXTRACTION_FAILED", errx.TypeInternal, http.StatusInternalServerError, "Fallo al extraer entidades")
	CodeInvalidIntent          = ErrRegistry.Register("INVALID_INTENT", errx.TypeValidation, http.StatusBadRequest, "Intenci√≥n inv√°lida")
	CodeInvalidEntity          = ErrRegistry.Register("INVALID_ENTITY", errx.TypeValidation, http.StatusBadRequest, "Entidad inv√°lida")
)

// ============================================================================
// Error Codes - Actions
// ============================================================================

var (
	CodeInvalidAction         = ErrRegistry.Register("INVALID_ACTION", errx.TypeValidation, http.StatusBadRequest, "Acci√≥n inv√°lida")
	CodeActionExecutionFailed = ErrRegistry.Register("ACTION_EXECUTION_FAILED", errx.TypeInternal, http.StatusInternalServerError, "Ejecuci√≥n de acci√≥n fall√≥")
	CodeInvalidActionConfig   = ErrRegistry.Register("INVALID_ACTION_CONFIG", errx.TypeValidation, http.StatusBadRequest, "Configuraci√≥n de acci√≥n inv√°lida")
	CodeNoActionsDefined      = ErrRegistry.Register("NO_ACTIONS_DEFINED", errx.TypeValidation, http.StatusBadRequest, "No hay acciones definidas")
)

// ============================================================================
// Error Codes - Selection
// ============================================================================

var (
	CodeNoParserAvailable     = ErrRegistry.Register("NO_PARSER_AVAILABLE", errx.TypeBusiness, http.StatusNotFound, "No hay parser disponible")
	CodeParserSelectionFailed = ErrRegistry.Register("PARSER_SELECTION_FAILED", errx.TypeInternal, http.StatusInternalServerError, "Fallo al seleccionar parser")
	CodeMaxRetriesExceeded    = ErrRegistry.Register("MAX_RETRIES_EXCEEDED", errx.TypeInternal, http.StatusInternalServerError, "M√°ximo de reintentos excedido")
)

// ============================================================================
// Error Codes - Cache
// ============================================================================

var (
	CodeCacheReadFailed  = ErrRegistry.Register("CACHE_READ_FAILED", errx.TypeInternal, http.StatusInternalServerError, "Fallo al leer cache")
	CodeCacheWriteFailed = ErrRegistry.Register("CACHE_WRITE_FAILED", errx.TypeInternal, http.StatusInternalServerError, "Fallo al escribir cache")
	CodeCacheClearFailed = ErrRegistry.Register("CACHE_CLEAR_FAILED", errx.TypeInternal, http.StatusInternalServerError, "Fallo al limpiar cache")
)

// ============================================================================
// Error Constructor Functions - Parser
// ============================================================================

func ErrParserNotFound() *errx.Error {
	return ErrRegistry.New(CodeParserNotFound)
}

func ErrParserAlreadyExists() *errx.Error {
	return ErrRegistry.New(CodeParserAlreadyExists)
}

func ErrInvalidParserType() *errx.Error {
	return ErrRegistry.New(CodeInvalidParserType)
}

func ErrInvalidParserConfig() *errx.Error {
	return ErrRegistry.New(CodeInvalidParserConfig)
}

func ErrParserInactive() *errx.Error {
	return ErrRegistry.New(CodeParserInactive)
}

func ErrParserNotSupported() *errx.Error {
	return ErrRegistry.New(CodeParserNotSupported)
}

// ============================================================================
// Error Constructor Functions - Parsing
// ============================================================================

func ErrParsingFailed() *errx.Error {
	return ErrRegistry.New(CodeParsingFailed)
}

func ErrNoMatchFound() *errx.Error {
	return ErrRegistry.New(CodeNoMatchFound)
}

func ErrInvalidInput() *errx.Error {
	return ErrRegistry.New(CodeInvalidInput)
}

func ErrParsingTimeout() *errx.Error {
	return ErrRegistry.New(CodeParsingTimeout)
}

func ErrLowConfidence() *errx.Error {
	return ErrRegistry.New(CodeLowConfidence)
}

func ErrAmbiguousResult() *errx.Error {
	return ErrRegistry.New(CodeAmbiguousResult)
}

// ============================================================================
// Error Constructor Functions - Regex Parser
// ============================================================================

func ErrInvalidRegexPattern() *errx.Error {
	return ErrRegistry.New(CodeInvalidRegexPattern)
}

func ErrRegexCompileFailed() *errx.Error {
	return ErrRegistry.New(CodeRegexCompileFailed)
}

func ErrInvalidCaptureGroup() *errx.Error {
	return ErrRegistry.New(CodeInvalidCaptureGroup)
}

func ErrNoPatternsDefined() *errx.Error {
	return ErrRegistry.New(CodeNoPatternsDefined)
}

// ============================================================================
// Error Constructor Functions - AI Parser
// ============================================================================

func ErrAIProviderNotConfigured() *errx.Error {
	return ErrRegistry.New(CodeAIProviderNotConfigured)
}

func ErrAIRequestFailed() *errx.Error {
	return ErrRegistry.New(CodeAIRequestFailed)
}

func ErrAIInvalidResponse() *errx.Error {
	return ErrRegistry.New(CodeAIInvalidResponse)
}

func ErrAIQuotaExceeded() *errx.Error {
	return ErrRegistry.New(CodeAIQuotaExceeded)
}

func ErrInvalidPrompt() *errx.Error {
	return ErrRegistry.New(CodeInvalidPrompt)
}

func ErrInvalidModel() *errx.Error {
	return ErrRegistry.New(CodeInvalidModel)
}

// ============================================================================
// Error Constructor Functions - Rule Parser
// ============================================================================

func ErrInvalidRule() *errx.Error {
	return ErrRegistry.New(CodeInvalidRule)
}

func ErrInvalidCondition() *errx.Error {
	return ErrRegistry.New(CodeInvalidCondition)
}

func ErrConditionEvalFailed() *errx.Error {
	return ErrRegistry.New(CodeConditionEvalFailed)
}

func ErrNoRulesDefined() *errx.Error {
	return ErrRegistry.New(CodeNoRulesDefined)
}

func ErrInvalidRuleOperator() *errx.Error {
	return ErrRegistry.New(CodeInvalidRuleOperator)
}

// ============================================================================
// Error Constructor Functions - Keyword Parser
// ============================================================================

func ErrNoKeywordsDefined() *errx.Error {
	return ErrRegistry.New(CodeNoKeywordsDefined)
}

func ErrInvalidKeyword() *errx.Error {
	return ErrRegistry.New(CodeInvalidKeyword)
}

func ErrKeywordMatchFailed() *errx.Error {
	return ErrRegistry.New(CodeKeywordMatchFailed)
}

// ============================================================================
// Error Constructor Functions - NLP Parser
// ============================================================================

func ErrNLPModelNotFound() *errx.Error {
	return ErrRegistry.New(CodeNLPModelNotFound)
}

func ErrNLPModelLoadFailed() *errx.Error {
	return ErrRegistry.New(CodeNLPModelLoadFailed)
}

func ErrIntentNotRecognized() *errx.Error {
	return ErrRegistry.New(CodeIntentNotRecognized)
}

func ErrEntityExtractionFailed() *errx.Error {
	return ErrRegistry.New(CodeEntityExtractionFailed)
}

func ErrInvalidIntent() *errx.Error {
	return ErrRegistry.New(CodeInvalidIntent)
}

func ErrInvalidEntity() *errx.Error {
	return ErrRegistry.New(CodeInvalidEntity)
}

// ============================================================================
// Error Constructor Functions - Actions
// ============================================================================

func ErrInvalidAction() *errx.Error {
	return ErrRegistry.New(CodeInvalidAction)
}

func ErrActionExecutionFailed() *errx.Error {
	return ErrRegistry.New(CodeActionExecutionFailed)
}

func ErrInvalidActionConfig() *errx.Error {
	return ErrRegistry.New(CodeInvalidActionConfig)
}

func ErrNoActionsDefined() *errx.Error {
	return ErrRegistry.New(CodeNoActionsDefined)
}

// ============================================================================
// Error Constructor Functions - Selection
// ============================================================================

func ErrNoParserAvailable() *errx.Error {
	return ErrRegistry.New(CodeNoParserAvailable)
}

func ErrParserSelectionFailed() *errx.Error {
	return ErrRegistry.New(CodeParserSelectionFailed)
}

func ErrMaxRetriesExceeded() *errx.Error {
	return ErrRegistry.New(CodeMaxRetriesExceeded)
}

// ============================================================================
// Error Constructor Functions - Cache
// ============================================================================

func ErrCacheReadFailed() *errx.Error {
	return ErrRegistry.New(CodeCacheReadFailed)
}

func ErrCacheWriteFailed() *errx.Error {
	return ErrRegistry.New(CodeCacheWriteFailed)
}

func ErrCacheClearFailed() *errx.Error {
	return ErrRegistry.New(CodeCacheClearFailed)
}
package tool

import (
	"context"

	"github.com/Abraxas-365/relay/pkg/kernel"
)

// ============================================================================
// Repository Interfaces
// ============================================================================

// ToolRepository define el contrato para persistencia de tools
type ToolRepository interface {
	// CRUD b√°sico
	Save(ctx context.Context, tool Tool) error
	FindByID(ctx context.Context, id kernel.ToolID, tenantID kernel.TenantID) (*Tool, error)
	FindByName(ctx context.Context, name string, tenantID kernel.TenantID) (*Tool, error)
	Delete(ctx context.Context, id kernel.ToolID, tenantID kernel.TenantID) error
	ExistsByName(ctx context.Context, name string, tenantID kernel.TenantID) (bool, error)

	// List con filtros y paginaci√≥n
	List(ctx context.Context, req ListToolsRequest) (ToolListResponse, error)

	// B√∫squedas espec√≠ficas
	FindByType(ctx context.Context, toolType ToolType, tenantID kernel.TenantID) ([]*Tool, error)
	FindActive(ctx context.Context, tenantID kernel.TenantID) ([]*Tool, error)

	// Bulk operations
	BulkUpdateStatus(ctx context.Context, ids []kernel.ToolID, tenantID kernel.TenantID, isActive bool) error
}

// ToolExecutionRepository define el contrato para persistencia de ejecuciones
type ToolExecutionRepository interface {
	// CRUD b√°sico
	Save(ctx context.Context, execution ToolExecution) error
	FindByID(ctx context.Context, id string) (*ToolExecution, error)

	// List con filtros y paginaci√≥n
	List(ctx context.Context, req ListExecutionsRequest) (ExecutionListResponse, error)

	// Estad√≠sticas
	CountByTool(ctx context.Context, toolID kernel.ToolID) (int, error)
	CountByStatus(ctx context.Context, toolID kernel.ToolID, status ExecutionStatus) (int, error)
	GetAverageDuration(ctx context.Context, toolID kernel.ToolID) (float64, error)
}

// ============================================================================
// Executor Interfaces
// ============================================================================

// ToolExecutor ejecuta tools seg√∫n su tipo
type ToolExecutor interface {
	// Execute ejecuta un tool con input dado
	Execute(ctx context.Context, tool *Tool, input map[string]any) (map[string]any, error)

	// ValidateInput valida input contra schema del tool
	ValidateInput(tool *Tool, input map[string]any) error

	// ValidateConfig valida configuraci√≥n del tool
	ValidateConfig(toolType ToolType, config ToolConfig) error
}
package tool

import (
	"github.com/Abraxas-365/craftable/storex"
	"github.com/Abraxas-365/relay/pkg/kernel"
)

// ============================================================================
// Request DTOs
// ============================================================================

// CreateToolRequest request para crear un tool
type CreateToolRequest struct {
	TenantID     kernel.TenantID `json:"tenant_id" validate:"required"`
	Name         string          `json:"name" validate:"required,min=2"`
	Description  string          `json:"description"`
	Type         ToolType        `json:"type" validate:"required"`
	Config       ToolConfig      `json:"config" validate:"required"`
	InputSchema  map[string]any  `json:"input_schema"`
	OutputSchema map[string]any  `json:"output_schema"`
}

// UpdateToolRequest request para actualizar un tool
type UpdateToolRequest struct {
	Name         *string         `json:"name,omitempty"`
	Description  *string         `json:"description,omitempty"`
	Config       *ToolConfig     `json:"config,omitempty"`
	InputSchema  *map[string]any `json:"input_schema,omitempty"`
	OutputSchema *map[string]any `json:"output_schema,omitempty"`
	IsActive     *bool           `json:"is_active,omitempty"`
}

// ExecuteToolRequest request para ejecutar un tool
type ExecuteToolRequest struct {
	ToolID kernel.ToolID  `json:"tool_id" validate:"required"`
	Input  map[string]any `json:"input" validate:"required"`
}

// ============================================================================
// List Request DTOs (con embedding de storex)
// ============================================================================

// ListToolsRequest request para listar tools con paginaci√≥n y filtros
type ListToolsRequest struct {
	storex.PaginationOptions

	// Filtros tipados propios
	TenantID kernel.TenantID `json:"tenant_id" validate:"required"`
	Type     *ToolType       `json:"type,omitempty"`
	IsActive *bool           `json:"is_active,omitempty"`
	Search   string          `json:"search,omitempty"`
}

// ListExecutionsRequest request para listar ejecuciones con filtros
type ListExecutionsRequest struct {
	storex.PaginationOptions

	// Filtros tipados propios
	TenantID kernel.TenantID  `json:"tenant_id" validate:"required"`
	ToolID   *kernel.ToolID   `json:"tool_id,omitempty"`
	Status   *ExecutionStatus `json:"status,omitempty"`
	From     *string          `json:"from,omitempty"` // ISO 8601 date
	To       *string          `json:"to,omitempty"`   // ISO 8601 date
}

// ============================================================================
// Response DTOs
// ============================================================================

// ToolResponse respuesta con tool y sus ejecuciones recientes
type ToolResponse struct {
	Tool             Tool            `json:"tool"`
	RecentExecutions []ToolExecution `json:"recent_executions,omitempty"`
}

// ExecutionResponse respuesta de una ejecuci√≥n
type ExecutionResponse struct {
	Execution ToolExecution `json:"execution"`
}

// ToolListResponse lista paginada de tools (usa storex.Paginated)
type ToolListResponse = storex.Paginated[Tool]

// ExecutionListResponse lista paginada de executions (usa storex.Paginated)
type ExecutionListResponse = storex.Paginated[ToolExecution]

// ============================================================================
// Stats DTOs
// ============================================================================

// ToolStatsResponse estad√≠sticas de un tool
type ToolStatsResponse struct {
	ToolID          kernel.ToolID `json:"tool_id"`
	ToolName        string        `json:"tool_name"`
	TotalExecutions int           `json:"total_executions"`
	SuccessCount    int           `json:"success_count"`
	FailureCount    int           `json:"failure_count"`
	AvgDuration     float64       `json:"avg_duration_ms"`
	LastExecutedAt  *string       `json:"last_executed_at,omitempty"`
}

// ToolUsageResponse uso de tools en un periodo
type ToolUsageResponse struct {
	TenantID        kernel.TenantID      `json:"tenant_id"`
	Period          string               `json:"period"` // day, week, month
	TotalExecutions int                  `json:"total_executions"`
	SuccessRate     float64              `json:"success_rate"`
	ToolBreakdown   []ToolUsageBreakdown `json:"tool_breakdown"`
}

type ToolUsageBreakdown struct {
	ToolID      kernel.ToolID `json:"tool_id"`
	ToolName    string        `json:"tool_name"`
	Executions  int           `json:"executions"`
	SuccessRate float64       `json:"success_rate"`
}

// ============================================================================
// Bulk Operation DTOs
// ============================================================================

// BulkToolOperationRequest request para operaciones masivas
type BulkToolOperationRequest struct {
	TenantID  kernel.TenantID `json:"tenant_id" validate:"required"`
	ToolIDs   []kernel.ToolID `json:"tool_ids" validate:"required,min=1"`
	Operation string          `json:"operation" validate:"required,oneof=activate deactivate delete"`
}

// BulkToolOperationResponse respuesta de operaci√≥n masiva
type BulkToolOperationResponse struct {
	Successful []kernel.ToolID          `json:"successful"`
	Failed     map[kernel.ToolID]string `json:"failed"`
	Total      int                      `json:"total"`
}

// ============================================================================
// Simple DTOs
// ============================================================================

// ToolDetailsDTO DTO simplificado de tool
type ToolDetailsDTO struct {
	ID          kernel.ToolID `json:"id"`
	Name        string        `json:"name"`
	Description string        `json:"description"`
	Type        ToolType      `json:"type"`
	IsActive    bool          `json:"is_active"`
}

// ToDTO convierte Tool a ToolDetailsDTO
func (t *Tool) ToDTO() ToolDetailsDTO {
	return ToolDetailsDTO{
		ID:          t.ID,
		Name:        t.Name,
		Description: t.Description,
		Type:        t.Type,
		IsActive:    t.IsActive,
	}
}
package tool

import (
	"net/http"

	"github.com/Abraxas-365/craftable/errx"
)

// ============================================================================
// Error Registry
// ============================================================================

var ErrRegistry = errx.NewRegistry("TOOL")

// ============================================================================
// Error Codes
// ============================================================================

var (
	// Tool errors
	CodeToolNotFound      = ErrRegistry.Register("NOT_FOUND", errx.TypeNotFound, http.StatusNotFound, "Tool no encontrado")
	CodeToolAlreadyExists = ErrRegistry.Register("ALREADY_EXISTS", errx.TypeConflict, http.StatusConflict, "Tool ya existe")
	CodeInvalidToolType   = ErrRegistry.Register("INVALID_TYPE", errx.TypeValidation, http.StatusBadRequest, "Tipo de tool inv√°lido")
	CodeInvalidToolConfig = ErrRegistry.Register("INVALID_CONFIG", errx.TypeValidation, http.StatusBadRequest, "Configuraci√≥n de tool inv√°lida")
	CodeToolInactive      = ErrRegistry.Register("TOOL_INACTIVE", errx.TypeBusiness, http.StatusForbidden, "Tool est√° inactivo")

	// Execution errors
	CodeExecutionFailed   = ErrRegistry.Register("EXECUTION_FAILED", errx.TypeInternal, http.StatusInternalServerError, "Ejecuci√≥n de tool fall√≥")
	CodeInvalidInput      = ErrRegistry.Register("INVALID_INPUT", errx.TypeValidation, http.StatusBadRequest, "Input inv√°lido para tool")
	CodeTimeoutExceeded   = ErrRegistry.Register("TIMEOUT_EXCEEDED", errx.TypeInternal, http.StatusRequestTimeout, "Timeout excedido")
	CodeExecutionNotFound = ErrRegistry.Register("EXECUTION_NOT_FOUND", errx.TypeNotFound, http.StatusNotFound, "Ejecuci√≥n no encontrada")

	// HTTP Tool errors
	CodeHTTPRequestFailed = ErrRegistry.Register("HTTP_REQUEST_FAILED", errx.TypeExternal, http.StatusBadGateway, "HTTP request fall√≥")
	CodeHTTPInvalidURL    = ErrRegistry.Register("HTTP_INVALID_URL", errx.TypeValidation, http.StatusBadRequest, "URL inv√°lida")

	// Database Tool errors
	CodeDatabaseQueryFailed        = ErrRegistry.Register("DATABASE_QUERY_FAILED", errx.TypeInternal, http.StatusInternalServerError, "Query de base de datos fall√≥")
	CodeDatabaseConnectionNotFound = ErrRegistry.Register("DATABASE_CONNECTION_NOT_FOUND", errx.TypeValidation, http.StatusBadRequest, "Conexi√≥n de base de datos no encontrada")

	// Email Tool errors
	CodeEmailSendFailed = ErrRegistry.Register("EMAIL_SEND_FAILED", errx.TypeExternal, http.StatusBadGateway, "Env√≠o de email fall√≥")

	// Custom Tool errors
	CodeCustomCodeExecutionFailed = ErrRegistry.Register("CUSTOM_CODE_FAILED", errx.TypeInternal, http.StatusInternalServerError, "Ejecuci√≥n de c√≥digo custom fall√≥")
	CodeCustomCodeTimeout         = ErrRegistry.Register("CUSTOM_CODE_TIMEOUT", errx.TypeInternal, http.StatusRequestTimeout, "C√≥digo custom excedi√≥ timeout")
)

// ============================================================================
// Error Constructor Functions
// ============================================================================

// Tool errors
func ErrToolNotFound() *errx.Error {
	return ErrRegistry.New(CodeToolNotFound)
}

func ErrToolAlreadyExists() *errx.Error {
	return ErrRegistry.New(CodeToolAlreadyExists)
}

func ErrInvalidToolType() *errx.Error {
	return ErrRegistry.New(CodeInvalidToolType)
}

func ErrInvalidToolConfig() *errx.Error {
	return ErrRegistry.New(CodeInvalidToolConfig)
}

func ErrToolInactive() *errx.Error {
	return ErrRegistry.New(CodeToolInactive)
}

// Execution errors
func ErrExecutionFailed() *errx.Error {
	return ErrRegistry.New(CodeExecutionFailed)
}

func ErrInvalidInput() *errx.Error {
	return ErrRegistry.New(CodeInvalidInput)
}

func ErrTimeoutExceeded() *errx.Error {
	return ErrRegistry.New(CodeTimeoutExceeded)
}

func ErrExecutionNotFound() *errx.Error {
	return ErrRegistry.New(CodeExecutionNotFound)
}

// HTTP Tool errors
func ErrHTTPRequestFailed() *errx.Error {
	return ErrRegistry.New(CodeHTTPRequestFailed)
}

func ErrHTTPInvalidURL() *errx.Error {
	return ErrRegistry.New(CodeHTTPInvalidURL)
}

// Database Tool errors
func ErrDatabaseQueryFailed() *errx.Error {
	return ErrRegistry.New(CodeDatabaseQueryFailed)
}

func ErrDatabaseConnectionNotFound() *errx.Error {
	return ErrRegistry.New(CodeDatabaseConnectionNotFound)
}

// Email Tool errors
func ErrEmailSendFailed() *errx.Error {
	return ErrRegistry.New(CodeEmailSendFailed)
}

// Custom Tool errors
func ErrCustomCodeExecutionFailed() *errx.Error {
	return ErrRegistry.New(CodeCustomCodeExecutionFailed)
}

func ErrCustomCodeTimeout() *errx.Error {
	return ErrRegistry.New(CodeCustomCodeTimeout)
}
package tool

import (
	"time"

	"github.com/Abraxas-365/relay/pkg/kernel"
)

// ============================================================================
// Tool Entity
// ============================================================================

// Tool representa una herramienta/funci√≥n ejecutable
type Tool struct {
	ID           kernel.ToolID   `db:"id" json:"id"`
	TenantID     kernel.TenantID `db:"tenant_id" json:"tenant_id"`
	Name         string          `db:"name" json:"name"`
	Description  string          `db:"description" json:"description"`
	Type         ToolType        `db:"type" json:"type"`
	Config       ToolConfig      `db:"config" json:"config"`
	InputSchema  map[string]any  `db:"input_schema" json:"input_schema"`
	OutputSchema map[string]any  `db:"output_schema" json:"output_schema"`
	IsActive     bool            `db:"is_active" json:"is_active"`
	CreatedAt    time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt    time.Time       `db:"updated_at" json:"updated_at"`
}

// ToolType define los tipos de tools disponibles
type ToolType string

const (
	ToolTypeHTTP     ToolType = "HTTP"
	ToolTypeDatabase ToolType = "DATABASE"
	ToolTypeEmail    ToolType = "EMAIL"
	ToolTypeCustom   ToolType = "CUSTOM"
)

// ToolConfig configuraci√≥n espec√≠fica por tipo de tool
type ToolConfig struct {
	// HTTP
	Method  string            `json:"method,omitempty"`
	URL     string            `json:"url,omitempty"`
	Headers map[string]string `json:"headers,omitempty"`
	Body    map[string]any    `json:"body,omitempty"`
	Timeout int               `json:"timeout,omitempty"` // seconds

	// Database
	Query        string `json:"query,omitempty"`
	ConnectionID string `json:"connection_id,omitempty"`

	// Email
	Provider   string         `json:"provider,omitempty"`
	TemplateID string         `json:"template_id,omitempty"`
	From       string         `json:"from,omitempty"`
	Subject    string         `json:"subject,omitempty"`
	Variables  map[string]any `json:"variables,omitempty"`

	// Custom
	Runtime string `json:"runtime,omitempty"` // nodejs, python
	Code    string `json:"code,omitempty"`
	Memory  string `json:"memory,omitempty"` // 128mb, 256mb
}

// ============================================================================
// Tool Execution Entity
// ============================================================================

// ToolExecution representa una ejecuci√≥n de un tool
type ToolExecution struct {
	ID        string          `db:"id" json:"id"`
	ToolID    kernel.ToolID   `db:"tool_id" json:"tool_id"`
	TenantID  kernel.TenantID `db:"tenant_id" json:"tenant_id"`
	Input     map[string]any  `db:"input" json:"input"`
	Output    map[string]any  `db:"output" json:"output"`
	Status    ExecutionStatus `db:"status" json:"status"`
	Error     string          `db:"error" json:"error,omitempty"`
	StartedAt time.Time       `db:"started_at" json:"started_at"`
	EndedAt   *time.Time      `db:"ended_at" json:"ended_at,omitempty"`
	Duration  int64           `db:"duration_ms" json:"duration_ms"` // milliseconds
}

// ExecutionStatus estado de ejecuci√≥n
type ExecutionStatus string

const (
	ExecutionStatusPending ExecutionStatus = "PENDING"
	ExecutionStatusRunning ExecutionStatus = "RUNNING"
	ExecutionStatusSuccess ExecutionStatus = "SUCCESS"
	ExecutionStatusFailed  ExecutionStatus = "FAILED"
)

// ============================================================================
// Domain Methods - Tool
// ============================================================================

// IsValid verifica si el tool es v√°lido
func (t *Tool) IsValid() bool {
	return t.Name != "" && t.Type != "" && !t.TenantID.IsEmpty()
}

// Activate activa el tool
func (t *Tool) Activate() {
	t.IsActive = true
	t.UpdatedAt = time.Now()
}

// Deactivate desactiva el tool
func (t *Tool) Deactivate() {
	t.IsActive = false
	t.UpdatedAt = time.Now()
}

// UpdateConfig actualiza la configuraci√≥n del tool
func (t *Tool) UpdateConfig(config ToolConfig) {
	t.Config = config
	t.UpdatedAt = time.Now()
}

// UpdateDetails actualiza nombre y descripci√≥n
func (t *Tool) UpdateDetails(name, description string) {
	if name != "" {
		t.Name = name
	}
	if description != "" {
		t.Description = description
	}
	t.UpdatedAt = time.Now()
}

// ============================================================================
// Domain Methods - ToolExecution
// ============================================================================

// IsCompleted verifica si la ejecuci√≥n termin√≥
func (e *ToolExecution) IsCompleted() bool {
	return e.Status == ExecutionStatusSuccess || e.Status == ExecutionStatusFailed
}

// IsSuccessful verifica si la ejecuci√≥n fue exitosa
func (e *ToolExecution) IsSuccessful() bool {
	return e.Status == ExecutionStatusSuccess
}

// Complete marca la ejecuci√≥n como completada
func (e *ToolExecution) Complete(output map[string]any) {
	now := time.Now()
	e.EndedAt = &now
	e.Status = ExecutionStatusSuccess
	e.Output = output
	e.Duration = now.Sub(e.StartedAt).Milliseconds()
}

// Fail marca la ejecuci√≥n como fallida
func (e *ToolExecution) Fail(err error) {
	now := time.Now()
	e.EndedAt = &now
	e.Status = ExecutionStatusFailed
	e.Error = err.Error()
	e.Duration = now.Sub(e.StartedAt).Milliseconds()
}
package database

import (
	"context"
	"fmt"
	"time"

	"github.com/Abraxas-365/relay/pkg/config"
	"github.com/jmoiron/sqlx"
	_ "github.com/lib/pq"
)

// NewPostgresDB crea una nueva conexi√≥n a PostgreSQL
func NewPostgresDB(cfg config.DatabaseConfig) (*sqlx.DB, error) {
	db, err := sqlx.Connect("postgres", cfg.GetDSN())
	if err != nil {
		return nil, fmt.Errorf("failed to connect to database: %w", err)
	}

	// Configurar pool de conexiones
	db.SetMaxOpenConns(cfg.MaxOpenConns)
	db.SetMaxIdleConns(cfg.MaxIdleConns)
	db.SetConnMaxLifetime(cfg.ConnMaxLifetime)

	// Verificar conexi√≥n
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err := db.PingContext(ctx); err != nil {
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}

	return db, nil
}

// CloseDB cierra la conexi√≥n a la base de datos
func CloseDB(db *sqlx.DB) error {
	if db != nil {
		return db.Close()
	}
	return nil
}
package database

import (
	"context"
	"fmt"
	"time"

	"github.com/Abraxas-365/relay/pkg/config"
	"github.com/go-redis/redis/v8"
)

// NewRedisClient crea una nueva conexi√≥n a Redis
func NewRedisClient(cfg config.RedisConfig) (*redis.Client, error) {
	client := redis.NewClient(&redis.Options{
		Addr:     cfg.GetAddr(),
		Password: cfg.Password,
		DB:       cfg.DB,
	})

	// Verificar conexi√≥n
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err := client.Ping(ctx).Err(); err != nil {
		return nil, fmt.Errorf("failed to connect to redis: %w", err)
	}

	return client, nil
}

// CloseRedis cierra la conexi√≥n a Redis
func CloseRedis(client *redis.Client) error {
	if client != nil {
		return client.Close()
	}
	return nil
}
package kernel

type UserID string

func NewUserID(id string) UserID { return UserID(id) }
func (u UserID) String() string  { return string(u) }
func (u UserID) IsEmpty() bool   { return string(u) == "" }

type TenantID string

func NewTenantID(id string) TenantID { return TenantID(id) }
func (t TenantID) String() string    { return string(t) }
func (t TenantID) IsEmpty() bool     { return string(t) == "" }

type RoleID string

func NewRoleID(id string) RoleID { return RoleID(id) }
func (r RoleID) String() string  { return string(r) }
func (r RoleID) IsEmpty() bool   { return string(r) == "" }

type MessageID string

func NewMessageID(id string) MessageID { return MessageID(id) }
func (r MessageID) String() string     { return string(r) }
func (r MessageID) IsEmpty() bool      { return string(r) == "" }

type ChannelID string

func NewChannelID(id string) ChannelID { return ChannelID(id) }
func (r ChannelID) String() string     { return string(r) }
func (r ChannelID) IsEmpty() bool      { return string(r) == "" }

type WorkflowID string

func NewWorkflowID(id string) WorkflowID { return WorkflowID(id) }
func (r WorkflowID) String() string      { return string(r) }
func (r WorkflowID) IsEmpty() bool       { return string(r) == "" }

type ParserID string

func NewParserID(id string) ParserID { return ParserID(id) }
func (r ParserID) String() string    { return string(r) }
func (r ParserID) IsEmpty() bool     { return string(r) == "" }

type ToolID string

func NewToolID(id string) ToolID { return ToolID(id) }
func (r ToolID) String() string  { return string(r) }
func (r ToolID) IsEmpty() bool   { return string(r) == "" }
package kernel

// ============================================================================
// Context Types - Tipos para context.Context
// ============================================================================

// AuthContext es el contexto de autenticaci√≥n que se inyecta en cada request
type AuthContext struct {
	UserID   UserID   `json:"user_id"`
	TenantID TenantID `json:"tenant_id"`
	IsAdmin  bool     `json:"is_admin"`
	Email    string   `json:"email"`
	Name     string   `json:"name"`
}

// IsValid verifica si el AuthContext es v√°lido
func (a *AuthContext) IsValid() bool {
	return !a.UserID.IsEmpty() && !a.TenantID.IsEmpty()
}

// ============================================================================
// Context Keys - Claves para context.Context
// ============================================================================

type ContextKey string

const (
	// AuthContextKey es la clave para almacenar AuthContext en context.Context
	AuthContextKey ContextKey = "auth_context"

	// TenantContextKey es la clave para almacenar TenantID en context.Context
	TenantContextKey ContextKey = "tenant_id"

	// UserContextKey es la clave para almacenar UserID en context.Context
	UserContextKey ContextKey = "user_id"

	// RequestIDKey es la clave para almacenar el ID de la petici√≥n
	RequestIDKey ContextKey = "request_id"
)
package config

import (
	"fmt"
	"os"
	"time"

	"github.com/Abraxas-365/relay/iam/auth"
)

// Config configuraci√≥n principal de la aplicaci√≥n
type Config struct {
	Server   ServerConfig
	Database DatabaseConfig
	Redis    RedisConfig
	Auth     auth.Config
}

// ServerConfig configuraci√≥n del servidor HTTP
type ServerConfig struct {
	Port            string
	Environment     string
	ReadTimeout     time.Duration
	WriteTimeout    time.Duration
	ShutdownTimeout time.Duration
}

// DatabaseConfig configuraci√≥n de PostgreSQL
type DatabaseConfig struct {
	Host            string
	Port            string
	User            string
	Password        string
	DBName          string
	SSLMode         string
	MaxOpenConns    int
	MaxIdleConns    int
	ConnMaxLifetime time.Duration
}

// RedisConfig configuraci√≥n de Redis
type RedisConfig struct {
	Host     string
	Port     string
	Password string
	DB       int
}

// Load carga la configuraci√≥n desde variables de entorno
func Load() (*Config, error) {
	// Cargar .env si existe

	config := &Config{
		Server: ServerConfig{
			Port:            getEnv("PORT", "8080"),
			Environment:     getEnv("ENVIRONMENT", "development"),
			ReadTimeout:     getDurationEnv("READ_TIMEOUT", 10*time.Second),
			WriteTimeout:    getDurationEnv("WRITE_TIMEOUT", 10*time.Second),
			ShutdownTimeout: getDurationEnv("SHUTDOWN_TIMEOUT", 30*time.Second),
		},
		Database: DatabaseConfig{
			Host:            getEnv("DB_HOST", getEnv("POSTGRES_HOST", "localhost")),
			Port:            getEnv("DB_PORT", getEnv("POSTGRES_PORT", "5432")),
			User:            getEnv("DB_USER", getEnv("POSTGRES_USER", "postgres")),
			Password:        getEnv("DB_PASSWORD", getEnv("POSTGRES_PASSWORD", "postgres")),
			DBName:          getEnv("DB_NAME", getEnv("POSTGRES_DB", "facturamelo")),
			SSLMode:         getEnv("DB_SSLMODE", "disable"),
			MaxOpenConns:    getIntEnv("DB_MAX_OPEN_CONNS", 25),
			MaxIdleConns:    getIntEnv("DB_MAX_IDLE_CONNS", 5),
			ConnMaxLifetime: getDurationEnv("DB_CONN_MAX_LIFETIME", 5*time.Minute),
		},
		Redis: RedisConfig{
			Host:     getEnv("REDIS_HOST", "localhost"),
			Port:     getEnv("REDIS_PORT", "6379"),
			Password: getEnv("REDIS_PASSWORD", ""),
			DB:       getIntEnv("REDIS_DB", 0),
		},
		Auth: LoadAuthConfig(),
	}

	if err := config.Validate(); err != nil {
		return nil, err
	}

	return config, nil
}

// Validate valida la configuraci√≥n
func (c *Config) Validate() error {
	if c.Database.Host == "" {
		return fmt.Errorf("DB_HOST is required")
	}
	if c.Database.User == "" {
		return fmt.Errorf("DB_USER is required")
	}
	if c.Database.DBName == "" {
		return fmt.Errorf("DB_NAME is required")
	}

	// Validar configuraci√≥n de Auth
	if err := c.Auth.Validate(); err != nil {
		return fmt.Errorf("invalid auth config: %w", err)
	}

	return nil
}

// GetDSN retorna el DSN de PostgreSQL
func (c *DatabaseConfig) GetDSN() string {
	return fmt.Sprintf(
		"host=%s port=%s user=%s password=%s dbname=%s sslmode=%s",
		c.Host, c.Port, c.User, c.Password, c.DBName, c.SSLMode,
	)
}

// GetRedisAddr retorna la direcci√≥n de Redis
func (c *RedisConfig) GetAddr() string {
	return fmt.Sprintf("%s:%s", c.Host, c.Port)
}

// Helper functions
func getEnv(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}

func getIntEnv(key string, defaultValue int) int {
	if value := os.Getenv(key); value != "" {
		var intValue int
		if _, err := fmt.Sscanf(value, "%d", &intValue); err == nil {
			return intValue
		}
	}
	return defaultValue
}

func getDurationEnv(key string, defaultValue time.Duration) time.Duration {
	if value := os.Getenv(key); value != "" {
		if duration, err := time.ParseDuration(value); err == nil {
			return duration
		}
	}
	return defaultValue
}

// LoadAuthConfig carga la configuraci√≥n desde variables de entorno
func LoadAuthConfig() auth.Config {
	return auth.Config{
		JWT: auth.JWTConfig{
			SecretKey:       getEnv("JWT_SECRET", "default-secret-change-in-production"),
			AccessTokenTTL:  getDurationEnv("ACCESS_TOKEN_TTL", 15*time.Minute),
			RefreshTokenTTL: getDurationEnv("REFRESH_TOKEN_TTL", 7*24*time.Hour),
			Issuer:          getEnv("JWT_ISSUER", "facturamelo"),
		},
		OAuth: auth.OAuthConfigs{
			Google: auth.OAuthConfig{
				ClientID:     getEnv("GOOGLE_CLIENT_ID", ""),
				ClientSecret: getEnv("GOOGLE_CLIENT_SECRET", ""),
				RedirectURL:  getEnv("GOOGLE_REDIRECT_URL", "http://localhost:8080/auth/callback/google"),
				Scopes:       []string{"openid", "email", "profile"},
			},
			Microsoft: auth.OAuthConfig{
				ClientID:     getEnv("MICROSOFT_CLIENT_ID", ""),
				ClientSecret: getEnv("MICROSOFT_CLIENT_SECRET", ""),
				RedirectURL:  getEnv("MICROSOFT_REDIRECT_URL", "http://localhost:8080/auth/callback/microsoft"),
				Scopes:       []string{"openid", "email", "profile", "User.Read"},
			},
		},
	}
}
package channels

import (
	"encoding/json"
	"time"

	"github.com/Abraxas-365/relay/pkg/kernel"
)

// ============================================================================
// Channel Entity (Single struct for DB)
// ============================================================================

// Channel estructura √∫nica que se guarda en la DB
type Channel struct {
	ID          kernel.ChannelID `db:"id" json:"id"`
	TenantID    kernel.TenantID  `db:"tenant_id" json:"tenant_id"`
	Type        ChannelType      `db:"type" json:"type"`
	Name        string           `db:"name" json:"name"`
	Description string           `db:"description" json:"description"`
	Config      json.RawMessage  `db:"config" json:"config"` // JSON que se deserializa seg√∫n Type
	IsActive    bool             `db:"is_active" json:"is_active"`
	WebhookURL  string           `db:"webhook_url" json:"webhook_url"`
	CreatedAt   time.Time        `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time        `db:"updated_at" json:"updated_at"`
}

// ChannelType tipo de canal
type ChannelType string

const (
	ChannelTypeWhatsApp  ChannelType = "WHATSAPP"
	ChannelTypeInstagram ChannelType = "INSTAGRAM"
	ChannelTypeTelegram  ChannelType = "TELEGRAM"
	ChannelTypeInfobip   ChannelType = "INFOBIP"
	ChannelTypeEmail     ChannelType = "EMAIL"
	ChannelTypeSMS       ChannelType = "SMS"
	ChannelTypeWebChat   ChannelType = "WEBCHAT"
	ChannelTypeVoice     ChannelType = "VOICE"
)

// ============================================================================
// Channel Features
// ============================================================================

// ChannelFeatures caracter√≠sticas/capacidades de un canal
type ChannelFeatures struct {
	SupportsText                bool     `json:"supports_text"`
	SupportsAttachments         bool     `json:"supports_attachments"`
	SupportsImages              bool     `json:"supports_images"`
	SupportsAudio               bool     `json:"supports_audio"`
	SupportsVideo               bool     `json:"supports_video"`
	SupportsDocuments           bool     `json:"supports_documents"`
	SupportsInteractiveMessages bool     `json:"supports_interactive_messages"`
	SupportsButtons             bool     `json:"supports_buttons"`
	SupportsQuickReplies        bool     `json:"supports_quick_replies"`
	SupportsTemplates           bool     `json:"supports_templates"`
	SupportsLocation            bool     `json:"supports_location"`
	SupportsContacts            bool     `json:"supports_contacts"`
	SupportsReactions           bool     `json:"supports_reactions"`
	SupportsThreads             bool     `json:"supports_threads"`
	MaxMessageLength            int      `json:"max_message_length"`
	MaxAttachmentSize           int64    `json:"max_attachment_size_bytes"`
	SupportedMimeTypes          []string `json:"supported_mime_types,omitempty"`
}

// ============================================================================
// Config Interface
// ============================================================================

// ChannelConfig interfaz que todos los configs deben implementar
type ChannelConfig interface {
	Validate() error
	GetProvider() string
	GetFeatures() ChannelFeatures
	GetType() ChannelType
}

// ============================================================================
// WhatsApp Config
// ============================================================================

// WhatsAppConfig configuraci√≥n para WhatsApp
type WhatsAppConfig struct {
	Provider           string `json:"provider"` // meta, twilio, infobip
	PhoneNumberID      string `json:"phone_number_id"`
	BusinessAccountID  string `json:"business_account_id"`
	AccessToken        string `json:"access_token"`
	AppSecret          string `json:"app_secret,omitempty"`
	WebhookVerifyToken string `json:"webhook_verify_token"`
	APIVersion         string `json:"api_version,omitempty"` // v17.0, v18.0
}

func (c WhatsAppConfig) Validate() error {
	if c.Provider == "" {
		return ErrInvalidChannelConfig().WithDetail("reason", "provider is required")
	}
	if c.PhoneNumberID == "" {
		return ErrInvalidChannelConfig().WithDetail("reason", "phone_number_id is required")
	}
	if c.AccessToken == "" {
		return ErrInvalidChannelConfig().WithDetail("reason", "access_token is required")
	}
	return nil
}

func (c WhatsAppConfig) GetProvider() string {
	return c.Provider
}

func (c WhatsAppConfig) GetType() ChannelType {
	return ChannelTypeWhatsApp
}

func (c WhatsAppConfig) GetFeatures() ChannelFeatures {
	return ChannelFeatures{
		SupportsText:                true,
		SupportsAttachments:         true,
		SupportsImages:              true,
		SupportsAudio:               true,
		SupportsVideo:               true,
		SupportsDocuments:           true,
		SupportsInteractiveMessages: true,
		SupportsButtons:             true,
		SupportsQuickReplies:        true,
		SupportsTemplates:           true,
		SupportsLocation:            true,
		SupportsContacts:            true,
		SupportsReactions:           true,
		SupportsThreads:             false,
		MaxMessageLength:            4096,
		MaxAttachmentSize:           16 * 1024 * 1024, // 16MB
		SupportedMimeTypes: []string{
			"image/jpeg", "image/png",
			"video/mp4", "video/3gpp",
			"audio/aac", "audio/mp4", "audio/mpeg", "audio/amr", "audio/ogg",
			"application/pdf",
		},
	}
}

// ============================================================================
// Instagram Config
// ============================================================================

// InstagramConfig configuraci√≥n para Instagram
type InstagramConfig struct {
	Provider    string `json:"provider"` // meta
	PageID      string `json:"page_id"`
	PageToken   string `json:"page_token"`
	AppSecret   string `json:"app_secret"`
	VerifyToken string `json:"verify_token"`
}

func (c InstagramConfig) Validate() error {
	if c.PageID == "" {
		return ErrInvalidChannelConfig().WithDetail("reason", "page_id is required")
	}
	if c.PageToken == "" {
		return ErrInvalidChannelConfig().WithDetail("reason", "page_token is required")
	}
	return nil
}

func (c InstagramConfig) GetProvider() string {
	return c.Provider
}

func (c InstagramConfig) GetType() ChannelType {
	return ChannelTypeInstagram
}

func (c InstagramConfig) GetFeatures() ChannelFeatures {
	return ChannelFeatures{
		SupportsText:                true,
		SupportsAttachments:         true,
		SupportsImages:              true,
		SupportsAudio:               false,
		SupportsVideo:               true,
		SupportsDocuments:           false,
		SupportsInteractiveMessages: true,
		SupportsButtons:             true,
		SupportsQuickReplies:        true,
		SupportsTemplates:           false,
		SupportsLocation:            false,
		SupportsContacts:            false,
		SupportsReactions:           true,
		SupportsThreads:             true,
		MaxMessageLength:            1000,
		MaxAttachmentSize:           8 * 1024 * 1024, // 8MB
		SupportedMimeTypes: []string{
			"image/jpeg", "image/png",
			"video/mp4",
		},
	}
}

// ============================================================================
// Telegram Config
// ============================================================================

// TelegramConfig configuraci√≥n para Telegram
type TelegramConfig struct {
	Provider      string `json:"provider"` // telegram
	BotToken      string `json:"bot_token"`
	BotUsername   string `json:"bot_username,omitempty"`
	WebhookSecret string `json:"webhook_secret,omitempty"`
}

func (c TelegramConfig) Validate() error {
	if c.BotToken == "" {
		return ErrInvalidChannelConfig().WithDetail("reason", "bot_token is required")
	}
	return nil
}

func (c TelegramConfig) GetProvider() string {
	return c.Provider
}

func (c TelegramConfig) GetType() ChannelType {
	return ChannelTypeTelegram
}

func (c TelegramConfig) GetFeatures() ChannelFeatures {
	return ChannelFeatures{
		SupportsText:                true,
		SupportsAttachments:         true,
		SupportsImages:              true,
		SupportsAudio:               true,
		SupportsVideo:               true,
		SupportsDocuments:           true,
		SupportsInteractiveMessages: true,
		SupportsButtons:             true,
		SupportsQuickReplies:        false,
		SupportsTemplates:           false,
		SupportsLocation:            true,
		SupportsContacts:            true,
		SupportsReactions:           false,
		SupportsThreads:             true,
		MaxMessageLength:            4096,
		MaxAttachmentSize:           50 * 1024 * 1024, // 50MB
		SupportedMimeTypes: []string{
			"image/jpeg", "image/png", "image/gif",
			"video/mp4",
			"audio/mpeg", "audio/ogg",
			"application/pdf", "application/zip",
		},
	}
}

// ============================================================================
// Infobip Config
// ============================================================================

// InfobipConfig configuraci√≥n para Infobip (multi-canal)
type InfobipConfig struct {
	Provider       string `json:"provider"` // infobip
	APIKey         string `json:"api_key"`
	BaseURL        string `json:"base_url"`         // https://api.infobip.com
	Sender         string `json:"sender"`           // n√∫mero o ID de remitente
	SubChannelType string `json:"sub_channel_type"` // whatsapp, sms, email, viber
}

func (c InfobipConfig) Validate() error {
	if c.APIKey == "" {
		return ErrInvalidChannelConfig().WithDetail("reason", "api_key is required")
	}
	if c.BaseURL == "" {
		return ErrInvalidChannelConfig().WithDetail("reason", "base_url is required")
	}
	return nil
}

func (c InfobipConfig) GetProvider() string {
	return c.Provider
}

func (c InfobipConfig) GetType() ChannelType {
	return ChannelTypeInfobip
}

func (c InfobipConfig) GetFeatures() ChannelFeatures {
	// Features var√≠an seg√∫n SubChannelType, aqu√≠ las m√°s comunes
	return ChannelFeatures{
		SupportsText:                true,
		SupportsAttachments:         true,
		SupportsImages:              true,
		SupportsAudio:               true,
		SupportsVideo:               true,
		SupportsDocuments:           true,
		SupportsInteractiveMessages: true,
		SupportsButtons:             true,
		SupportsQuickReplies:        true,
		SupportsTemplates:           true,
		SupportsLocation:            true,
		SupportsContacts:            false,
		SupportsReactions:           false,
		SupportsThreads:             false,
		MaxMessageLength:            4096,
		MaxAttachmentSize:           10 * 1024 * 1024, // 10MB
		SupportedMimeTypes: []string{
			"image/jpeg", "image/png",
			"video/mp4",
			"audio/mpeg",
			"application/pdf",
		},
	}
}

// ============================================================================
// Email Config
// ============================================================================

// EmailConfig configuraci√≥n para Email
type EmailConfig struct {
	Provider  string `json:"provider"` // sendgrid, ses, smtp
	FromEmail string `json:"from_email"`
	FromName  string `json:"from_name"`
	APIKey    string `json:"api_key,omitempty"`

	// SMTP espec√≠fico
	SMTPHost     string `json:"smtp_host,omitempty"`
	SMTPPort     int    `json:"smtp_port,omitempty"`
	SMTPUsername string `json:"smtp_username,omitempty"`
	SMTPPassword string `json:"smtp_password,omitempty"`
	UseTLS       bool   `json:"use_tls,omitempty"`
}

func (c EmailConfig) Validate() error {
	if c.Provider == "" {
		return ErrInvalidChannelConfig().WithDetail("reason", "provider is required")
	}
	if c.FromEmail == "" {
		return ErrInvalidChannelConfig().WithDetail("reason", "from_email is required")
	}
	return nil
}

func (c EmailConfig) GetProvider() string {
	return c.Provider
}

func (c EmailConfig) GetType() ChannelType {
	return ChannelTypeEmail
}

func (c EmailConfig) GetFeatures() ChannelFeatures {
	return ChannelFeatures{
		SupportsText:                true,
		SupportsAttachments:         true,
		SupportsImages:              true,
		SupportsAudio:               false,
		SupportsVideo:               false,
		SupportsDocuments:           true,
		SupportsInteractiveMessages: false,
		SupportsButtons:             false,
		SupportsQuickReplies:        false,
		SupportsTemplates:           true,
		SupportsLocation:            false,
		SupportsContacts:            false,
		SupportsReactions:           false,
		SupportsThreads:             true,
		MaxMessageLength:            100000,
		MaxAttachmentSize:           25 * 1024 * 1024, // 25MB
		SupportedMimeTypes: []string{
			"image/jpeg", "image/png", "image/gif",
			"application/pdf",
			"application/msword",
			"application/vnd.ms-excel",
		},
	}
}

// ============================================================================
// SMS Config
// ============================================================================

// SMSConfig configuraci√≥n para SMS
type SMSConfig struct {
	Provider  string `json:"provider"` // twilio, infobip, nexmo
	APIKey    string `json:"api_key"`
	APISecret string `json:"api_secret,omitempty"`
	Sender    string `json:"sender"` // n√∫mero de remitente
}

func (c SMSConfig) Validate() error {
	if c.Provider == "" {
		return ErrInvalidChannelConfig().WithDetail("reason", "provider is required")
	}
	if c.APIKey == "" {
		return ErrInvalidChannelConfig().WithDetail("reason", "api_key is required")
	}
	if c.Sender == "" {
		return ErrInvalidChannelConfig().WithDetail("reason", "sender is required")
	}
	return nil
}

func (c SMSConfig) GetProvider() string {
	return c.Provider
}

func (c SMSConfig) GetType() ChannelType {
	return ChannelTypeSMS
}

func (c SMSConfig) GetFeatures() ChannelFeatures {
	return ChannelFeatures{
		SupportsText:                true,
		SupportsAttachments:         false,
		SupportsImages:              false,
		SupportsAudio:               false,
		SupportsVideo:               false,
		SupportsDocuments:           false,
		SupportsInteractiveMessages: false,
		SupportsButtons:             false,
		SupportsQuickReplies:        false,
		SupportsTemplates:           false,
		SupportsLocation:            false,
		SupportsContacts:            false,
		SupportsReactions:           false,
		SupportsThreads:             false,
		MaxMessageLength:            160, // o 1600 para concatenados
		MaxAttachmentSize:           0,
		SupportedMimeTypes:          []string{},
	}
}

// ============================================================================
// WebChat Config
// ============================================================================

// WebChatConfig configuraci√≥n para WebChat
type WebChatConfig struct {
	Provider   string            `json:"provider"` // custom, tawk, intercom
	WidgetID   string            `json:"widget_id"`
	APIKey     string            `json:"api_key,omitempty"`
	Settings   map[string]string `json:"settings,omitempty"`
	CustomCSS  string            `json:"custom_css,omitempty"`
	WelcomeMsg string            `json:"welcome_message,omitempty"`
}

func (c WebChatConfig) Validate() error {
	if c.WidgetID == "" {
		return ErrInvalidChannelConfig().WithDetail("reason", "widget_id is required")
	}
	return nil
}

func (c WebChatConfig) GetProvider() string {
	return c.Provider
}

func (c WebChatConfig) GetType() ChannelType {
	return ChannelTypeWebChat
}

func (c WebChatConfig) GetFeatures() ChannelFeatures {
	return ChannelFeatures{
		SupportsText:                true,
		SupportsAttachments:         true,
		SupportsImages:              true,
		SupportsAudio:               false,
		SupportsVideo:               false,
		SupportsDocuments:           true,
		SupportsInteractiveMessages: true,
		SupportsButtons:             true,
		SupportsQuickReplies:        true,
		SupportsTemplates:           false,
		SupportsLocation:            false,
		SupportsContacts:            false,
		SupportsReactions:           true,
		SupportsThreads:             true,
		MaxMessageLength:            10000,
		MaxAttachmentSize:           10 * 1024 * 1024, // 10MB
		SupportedMimeTypes: []string{
			"image/jpeg", "image/png", "image/gif",
			"application/pdf",
		},
	}
}

// ============================================================================
// Channel Domain Methods
// ============================================================================

// IsValid verifica si el canal es v√°lido
func (c *Channel) IsValid() bool {
	return c.Name != "" && c.Type != "" && !c.TenantID.IsEmpty()
}

// Activate activa el canal
func (c *Channel) Activate() {
	c.IsActive = true
	c.UpdatedAt = time.Now()
}

// Deactivate desactiva el canal
func (c *Channel) Deactivate() {
	c.IsActive = false
	c.UpdatedAt = time.Now()
}

// UpdateDetails actualiza nombre y descripci√≥n
func (c *Channel) UpdateDetails(name, description string) {
	if name != "" {
		c.Name = name
	}
	if description != "" {
		c.Description = description
	}
	c.UpdatedAt = time.Now()
}

// UpdateConfig actualiza la configuraci√≥n
func (c *Channel) UpdateConfig(config ChannelConfig) error {
	configJSON, err := json.Marshal(config)
	if err != nil {
		return err
	}
	c.Config = configJSON
	c.UpdatedAt = time.Now()
	return nil
}

// GetConfigStruct deserializa el config seg√∫n el tipo
func (c *Channel) GetConfigStruct() (ChannelConfig, error) {
	switch c.Type {
	case ChannelTypeWhatsApp:
		var config WhatsAppConfig
		if err := json.Unmarshal(c.Config, &config); err != nil {
			return nil, err
		}
		return config, nil

	case ChannelTypeInstagram:
		var config InstagramConfig
		if err := json.Unmarshal(c.Config, &config); err != nil {
			return nil, err
		}
		return config, nil

	case ChannelTypeTelegram:
		var config TelegramConfig
		if err := json.Unmarshal(c.Config, &config); err != nil {
			return nil, err
		}
		return config, nil

	case ChannelTypeInfobip:
		var config InfobipConfig
		if err := json.Unmarshal(c.Config, &config); err != nil {
			return nil, err
		}
		return config, nil

	case ChannelTypeEmail:
		var config EmailConfig
		if err := json.Unmarshal(c.Config, &config); err != nil {
			return nil, err
		}
		return config, nil

	case ChannelTypeSMS:
		var config SMSConfig
		if err := json.Unmarshal(c.Config, &config); err != nil {
			return nil, err
		}
		return config, nil

	case ChannelTypeWebChat:
		var config WebChatConfig
		if err := json.Unmarshal(c.Config, &config); err != nil {
			return nil, err
		}
		return config, nil

	default:
		return nil, ErrChannelNotSupported().WithDetail("type", string(c.Type))
	}
}

// GetFeatures obtiene las features del canal
func (c *Channel) GetFeatures() (ChannelFeatures, error) {
	config, err := c.GetConfigStruct()
	if err != nil {
		return ChannelFeatures{}, err
	}
	return config.GetFeatures(), nil
}

// HasCredentials verifica si tiene credenciales configuradas
func (c *Channel) HasCredentials() bool {
	config, err := c.GetConfigStruct()
	if err != nil {
		return false
	}
	return config.GetProvider() != ""
}

// GetProvider retorna el proveedor
func (c *Channel) GetProvider() string {
	config, err := c.GetConfigStruct()
	if err != nil {
		return ""
	}
	return config.GetProvider()
}

// ============================================================================
// Helper Functions
// ============================================================================

// NewChannelFromConfig crea un canal desde una config
func NewChannelFromConfig(
	id kernel.ChannelID,
	tenantID kernel.TenantID,
	name string,
	description string,
	config ChannelConfig,
	webhookURL string,
) (*Channel, error) {
	configJSON, err := json.Marshal(config)
	if err != nil {
		return nil, err
	}

	return &Channel{
		ID:          id,
		TenantID:    tenantID,
		Type:        config.GetType(),
		Name:        name,
		Description: description,
		Config:      configJSON,
		IsActive:    true,
		WebhookURL:  webhookURL,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}, nil
}
package channelsrv

import (
	"context"
	"time"

	"github.com/Abraxas-365/craftable/errx"
	"github.com/Abraxas-365/relay/channels"
	"github.com/Abraxas-365/relay/iam/tenant"
	"github.com/Abraxas-365/relay/pkg/kernel"
	"github.com/google/uuid"
)

// ChannelService proporciona operaciones de negocio para canales
type ChannelService struct {
	channelRepo    channels.ChannelRepository
	tenantRepo     tenant.TenantRepository
	channelManager channels.ChannelManager
}

// NewChannelService crea una nueva instancia del servicio de canales
func NewChannelService(
	channelRepo channels.ChannelRepository,
	tenantRepo tenant.TenantRepository,
	channelManager channels.ChannelManager,
) *ChannelService {
	return &ChannelService{
		channelRepo:    channelRepo,
		tenantRepo:     tenantRepo,
		channelManager: channelManager,
	}
}

// ============================================================================
// CRUD Operations
// ============================================================================

// CreateChannel crea un nuevo canal
func (s *ChannelService) CreateChannel(ctx context.Context, req channels.CreateChannelRequest) (*channels.Channel, error) {
	// Verificar que el tenant exista y est√© activo
	tenantEntity, err := s.tenantRepo.FindByID(ctx, req.TenantID)
	if err != nil {
		return nil, tenant.ErrTenantNotFound()
	}

	if !tenantEntity.IsActive() {
		return nil, tenant.ErrTenantSuspended()
	}

	// Verificar que no exista un canal con el mismo nombre
	exists, err := s.channelRepo.ExistsByName(ctx, req.Name, req.TenantID)
	if err != nil {
		return nil, errx.Wrap(err, "failed to check channel name existence", errx.TypeInternal)
	}
	if exists {
		return nil, channels.ErrChannelAlreadyExists().WithDetail("name", req.Name)
	}

	// Generar webhook URL
	webhookURL := s.generateWebhookURL(req.TenantID, req.Type)

	// Crear canal usando el helper
	newChannel, err := channels.NewChannelFromConfig(
		kernel.NewChannelID(uuid.NewString()),
		req.TenantID,
		req.Name,
		req.Description,
		req.Config,
		webhookURL,
	)
	if err != nil {
		return nil, errx.Wrap(err, "failed to create channel", errx.TypeInternal)
	}

	// Validar config usando el adapter si est√° disponible
	if adapter, err := s.channelManager.GetAdapter(newChannel.Type); err == nil {
		if err := adapter.ValidateConfig(req.Config); err != nil {
			return nil, channels.ErrInvalidChannelConfig().
				WithDetail("reason", err.Error())
		}
	}

	// Guardar canal
	if err := s.channelRepo.Save(ctx, *newChannel); err != nil {
		return nil, errx.Wrap(err, "failed to save channel", errx.TypeInternal)
	}

	// Registrar en el channel manager
	if err := s.channelManager.RegisterChannel(ctx, *newChannel); err != nil {
		// Log error but don't fail
		// logger.Error("Failed to register channel in manager", err)
	}

	return newChannel, nil
}

// GetChannelByID obtiene un canal por ID
func (s *ChannelService) GetChannelByID(ctx context.Context, channelID kernel.ChannelID, tenantID kernel.TenantID) (*channels.ChannelResponse, error) {
	channel, err := s.channelRepo.FindByID(ctx, channelID, tenantID)
	if err != nil {
		return nil, channels.ErrChannelNotFound().WithDetail("channel_id", channelID.String())
	}

	features, err := channel.GetFeatures()
	if err != nil {
		// Return channel without features
		features = channels.ChannelFeatures{}
	}

	return &channels.ChannelResponse{
		Channel:  *channel,
		Features: features,
	}, nil
}

// GetChannelByName obtiene un canal por nombre
func (s *ChannelService) GetChannelByName(ctx context.Context, name string, tenantID kernel.TenantID) (*channels.ChannelResponse, error) {
	channel, err := s.channelRepo.FindByName(ctx, name, tenantID)
	if err != nil {
		return nil, channels.ErrChannelNotFound().WithDetail("name", name)
	}

	features, _ := channel.GetFeatures()

	return &channels.ChannelResponse{
		Channel:  *channel,
		Features: features,
	}, nil
}

// GetChannelsByTenant obtiene todos los canales de un tenant
func (s *ChannelService) GetChannelsByTenant(ctx context.Context, tenantID kernel.TenantID) ([]*channels.Channel, error) {
	return s.channelRepo.FindByTenant(ctx, tenantID)
}

// GetActiveChannels obtiene canales activos de un tenant
func (s *ChannelService) GetActiveChannels(ctx context.Context, tenantID kernel.TenantID) ([]*channels.Channel, error) {
	return s.channelRepo.FindActive(ctx, tenantID)
}

// GetChannelsByType obtiene canales por tipo
func (s *ChannelService) GetChannelsByType(ctx context.Context, channelType channels.ChannelType, tenantID kernel.TenantID) ([]*channels.Channel, error) {
	return s.channelRepo.FindByType(ctx, channelType, tenantID)
}

// UpdateChannel actualiza un canal
func (s *ChannelService) UpdateChannel(ctx context.Context, channelID kernel.ChannelID, req channels.UpdateChannelRequest, tenantID kernel.TenantID) (*channels.Channel, error) {
	channel, err := s.channelRepo.FindByID(ctx, channelID, tenantID)
	if err != nil {
		return nil, channels.ErrChannelNotFound().WithDetail("channel_id", channelID.String())
	}

	// Actualizar campos si se proporcionaron
	if req.Name != nil {
		// Verificar que no exista otro canal con el mismo nombre
		if *req.Name != channel.Name {
			exists, err := s.channelRepo.ExistsByName(ctx, *req.Name, tenantID)
			if err != nil {
				return nil, errx.Wrap(err, "failed to check channel name", errx.TypeInternal)
			}
			if exists {
				return nil, channels.ErrChannelAlreadyExists().WithDetail("name", *req.Name)
			}
		}
		channel.Name = *req.Name
	}

	if req.Description != nil {
		channel.Description = *req.Description
	}

	if req.Config != nil {
		// Validar config
		if adapter, err := s.channelManager.GetAdapter(channel.Type); err == nil {
			if err := adapter.ValidateConfig(*req.Config); err != nil {
				return nil, channels.ErrInvalidChannelConfig().WithDetail("reason", err.Error())
			}
		}

		if err := channel.UpdateConfig(*req.Config); err != nil {
			return nil, errx.Wrap(err, "failed to update config", errx.TypeInternal)
		}
	}

	if req.IsActive != nil {
		if *req.IsActive {
			channel.Activate()
		} else {
			channel.Deactivate()
		}
	}

	channel.UpdatedAt = time.Now()

	// Guardar cambios
	if err := s.channelRepo.Save(ctx, *channel); err != nil {
		return nil, errx.Wrap(err, "failed to update channel", errx.TypeInternal)
	}

	return channel, nil
}

// ActivateChannel activa un canal
func (s *ChannelService) ActivateChannel(ctx context.Context, channelID kernel.ChannelID, tenantID kernel.TenantID) error {
	channel, err := s.channelRepo.FindByID(ctx, channelID, tenantID)
	if err != nil {
		return channels.ErrChannelNotFound().WithDetail("channel_id", channelID.String())
	}

	channel.Activate()
	return s.channelRepo.Save(ctx, *channel)
}

// DeactivateChannel desactiva un canal
func (s *ChannelService) DeactivateChannel(ctx context.Context, channelID kernel.ChannelID, tenantID kernel.TenantID) error {
	channel, err := s.channelRepo.FindByID(ctx, channelID, tenantID)
	if err != nil {
		return channels.ErrChannelNotFound().WithDetail("channel_id", channelID.String())
	}

	channel.Deactivate()
	return s.channelRepo.Save(ctx, *channel)
}

// DeleteChannel elimina un canal
func (s *ChannelService) DeleteChannel(ctx context.Context, channelID kernel.ChannelID, tenantID kernel.TenantID) error {
	// Verificar que el canal existe
	_, err := s.channelRepo.FindByID(ctx, channelID, tenantID)
	if err != nil {
		return channels.ErrChannelNotFound().WithDetail("channel_id", channelID.String())
	}

	// Eliminar canal
	return s.channelRepo.Delete(ctx, channelID, tenantID)
}

// ============================================================================
// Messaging Operations
// ============================================================================

// SendMessage env√≠a un mensaje a trav√©s de un canal
func (s *ChannelService) SendMessage(ctx context.Context, channelID kernel.ChannelID, msg channels.OutgoingMessage) (*channels.SendMessageResponse, error) {
	// Verificar que el canal existe y est√° activo
	channel, err := s.channelRepo.FindByID(ctx, channelID, msg.Metadata["tenant_id"].(kernel.TenantID))
	if err != nil {
		return nil, channels.ErrChannelNotFound().WithDetail("channel_id", channelID.String())
	}

	if !channel.IsActive {
		return nil, channels.ErrChannelInactive().WithDetail("channel_id", channelID.String())
	}

	// Enviar mensaje usando el channel manager
	startTime := time.Now()
	if err := s.channelManager.SendMessage(ctx, channelID, msg); err != nil {
		return &channels.SendMessageResponse{
			Success:   false,
			Timestamp: time.Now().Unix(),
			Error:     err.Error(),
		}, err
	}

	return &channels.SendMessageResponse{
		Success:   true,
		Timestamp: time.Now().Unix(),
		Metadata: map[string]any{
			"processing_time_ms": time.Since(startTime).Milliseconds(),
		},
	}, nil
}

// TestChannel prueba la conexi√≥n de un canal
func (s *ChannelService) TestChannel(ctx context.Context, channelID kernel.ChannelID, tenantID kernel.TenantID) (*channels.TestChannelResponse, error) {
	channel, err := s.channelRepo.FindByID(ctx, channelID, tenantID)
	if err != nil {
		return nil, channels.ErrChannelNotFound().WithDetail("channel_id", channelID.String())
	}

	// Obtener adapter
	adapter, err := s.channelManager.GetAdapter(channel.Type)
	if err != nil {
		return &channels.TestChannelResponse{
			Success: false,
			Message: "Adapter not available",
			Error:   err.Error(),
		}, err
	}

	// Probar conexi√≥n
	startTime := time.Now()
	config, err := channel.GetConfigStruct()
	if err != nil {
		return &channels.TestChannelResponse{
			Success: false,
			Message: "Invalid channel configuration",
			Error:   err.Error(),
		}, err
	}

	if err := adapter.TestConnection(ctx, config); err != nil {
		return &channels.TestChannelResponse{
			Success:      false,
			Message:      "Connection test failed",
			ResponseTime: time.Since(startTime).Milliseconds(),
			Error:        err.Error(),
		}, err
	}

	return &channels.TestChannelResponse{
		Success:      true,
		Message:      "Connection test successful",
		ResponseTime: time.Since(startTime).Milliseconds(),
	}, nil
}

// ============================================================================
// Bulk Operations
// ============================================================================

// BulkActivateChannels activa m√∫ltiples canales
func (s *ChannelService) BulkActivateChannels(ctx context.Context, channelIDs []kernel.ChannelID, tenantID kernel.TenantID) (*channels.BulkChannelOperationResponse, error) {
	result := &channels.BulkChannelOperationResponse{
		Successful: []kernel.ChannelID{},
		Failed:     make(map[kernel.ChannelID]string),
		Total:      len(channelIDs),
	}

	for _, channelID := range channelIDs {
		if err := s.ActivateChannel(ctx, channelID, tenantID); err != nil {
			result.Failed[channelID] = err.Error()
		} else {
			result.Successful = append(result.Successful, channelID)
		}
	}

	return result, nil
}

// BulkDeactivateChannels desactiva m√∫ltiples canales
func (s *ChannelService) BulkDeactivateChannels(ctx context.Context, channelIDs []kernel.ChannelID, tenantID kernel.TenantID) (*channels.BulkChannelOperationResponse, error) {
	result := &channels.BulkChannelOperationResponse{
		Successful: []kernel.ChannelID{},
		Failed:     make(map[kernel.ChannelID]string),
		Total:      len(channelIDs),
	}

	for _, channelID := range channelIDs {
		if err := s.DeactivateChannel(ctx, channelID, tenantID); err != nil {
			result.Failed[channelID] = err.Error()
		} else {
			result.Successful = append(result.Successful, channelID)
		}
	}

	return result, nil
}

// ============================================================================
// Helper Methods
// ============================================================================

// generateWebhookURL genera una URL de webhook para el canal
func (s *ChannelService) generateWebhookURL(tenantID kernel.TenantID, channelType channels.ChannelType) string {
	// En producci√≥n, esto deber√≠a usar la configuraci√≥n real del servidor
	baseURL := "https://api.yourdomain.com" // O desde config
	return baseURL + "/webhooks/channels/" + string(channelType) + "/" + tenantID.String()
}
package channels

import (
	"context"

	"github.com/Abraxas-365/relay/pkg/kernel"
)

// ============================================================================
// Repository Interfaces
// ============================================================================

// ChannelRepository define el contrato para persistencia de canales
type ChannelRepository interface {
	// CRUD b√°sico
	Save(ctx context.Context, channel Channel) error
	FindByID(ctx context.Context, id kernel.ChannelID, tenantID kernel.TenantID) (*Channel, error)
	FindByName(ctx context.Context, name string, tenantID kernel.TenantID) (*Channel, error)
	Delete(ctx context.Context, id kernel.ChannelID, tenantID kernel.TenantID) error
	ExistsByName(ctx context.Context, name string, tenantID kernel.TenantID) (bool, error)

	// B√∫squedas espec√≠ficas
	FindByTenant(ctx context.Context, tenantID kernel.TenantID) ([]*Channel, error)
	FindByType(ctx context.Context, channelType ChannelType, tenantID kernel.TenantID) ([]*Channel, error)
	FindActive(ctx context.Context, tenantID kernel.TenantID) ([]*Channel, error)
	FindByProvider(ctx context.Context, provider string, tenantID kernel.TenantID) ([]*Channel, error)

	// List con paginaci√≥n
	List(ctx context.Context, req ListChannelsRequest) (ChannelListResponse, error)

	// Bulk operations
	BulkUpdateStatus(ctx context.Context, ids []kernel.ChannelID, tenantID kernel.TenantID, isActive bool) error

	// Stats
	CountByType(ctx context.Context, channelType ChannelType, tenantID kernel.TenantID) (int, error)
	CountByTenant(ctx context.Context, tenantID kernel.TenantID) (int, error)
}

// ============================================================================
// Adapter Interfaces
// ============================================================================

// ChannelAdapter interfaz para adaptadores de canal espec√≠ficos
type ChannelAdapter interface {
	// GetType retorna el tipo de canal que maneja
	GetType() ChannelType

	// SendMessage env√≠a un mensaje a trav√©s del canal
	SendMessage(ctx context.Context, msg OutgoingMessage) error

	// ValidateConfig valida la configuraci√≥n del canal
	ValidateConfig(config ChannelConfig) error

	// ProcessWebhook procesa webhooks entrantes del proveedor
	ProcessWebhook(ctx context.Context, payload []byte, headers map[string]string) (*IncomingMessage, error)

	// GetFeatures retorna las caracter√≠sticas soportadas
	GetFeatures() ChannelFeatures

	// TestConnection prueba la conexi√≥n con el proveedor
	TestConnection(ctx context.Context, config ChannelConfig) error
}

// ============================================================================
// Manager Interfaces
// ============================================================================

// ChannelManager gestiona operaciones de alto nivel con canales
type ChannelManager interface {
	// RegisterChannel registra un nuevo canal
	RegisterChannel(ctx context.Context, channel Channel) error

	// SendMessage env√≠a un mensaje a trav√©s de un canal
	SendMessage(ctx context.Context, channelID kernel.ChannelID, msg OutgoingMessage) error

	// ProcessIncomingMessage procesa un mensaje entrante
	ProcessIncomingMessage(ctx context.Context, channelID kernel.ChannelID, msg IncomingMessage) error

	// GetAdapter obtiene el adapter para un tipo de canal
	GetAdapter(channelType ChannelType) (ChannelAdapter, error)

	// RegisterAdapter registra un adapter
	RegisterAdapter(adapter ChannelAdapter)

	// TestChannel prueba la conexi√≥n de un canal
	TestChannel(ctx context.Context, channelID kernel.ChannelID) error
}
package channels

import (
	"github.com/Abraxas-365/craftable/storex"
	"github.com/Abraxas-365/relay/pkg/kernel"
)

// ============================================================================
// Message DTOs
// ============================================================================

// OutgoingMessage mensaje saliente a enviar por el canal
type OutgoingMessage struct {
	RecipientID string            `json:"recipient_id" validate:"required"`
	Content     MessageContent    `json:"content" validate:"required"`
	Metadata    map[string]any    `json:"metadata,omitempty"`
	ReplyToID   string            `json:"reply_to_id,omitempty"`
	TemplateID  string            `json:"template_id,omitempty"`
	Variables   map[string]string `json:"variables,omitempty"`
}

// IncomingMessage mensaje entrante recibido del canal
type IncomingMessage struct {
	MessageID  string           `json:"message_id"`
	ChannelID  kernel.ChannelID `json:"channel_id"`
	SenderID   string           `json:"sender_id"`
	Content    MessageContent   `json:"content"`
	Timestamp  int64            `json:"timestamp"`
	Metadata   map[string]any   `json:"metadata,omitempty"`
	RawPayload map[string]any   `json:"raw_payload,omitempty"`
}

// MessageContent contenido del mensaje
type MessageContent struct {
	Type        string         `json:"type"` // text, image, audio, video, document, location, contact
	Text        string         `json:"text,omitempty"`
	MediaURL    string         `json:"media_url,omitempty"`
	Caption     string         `json:"caption,omitempty"`
	MimeType    string         `json:"mime_type,omitempty"`
	Filename    string         `json:"filename,omitempty"`
	Attachments []Attachment   `json:"attachments,omitempty"`
	Location    *Location      `json:"location,omitempty"`
	Contact     *Contact       `json:"contact,omitempty"`
	Interactive *Interactive   `json:"interactive,omitempty"`
	Metadata    map[string]any `json:"metadata,omitempty"`
}

// Attachment archivo adjunto
type Attachment struct {
	Type     string `json:"type"` // image, audio, video, document
	URL      string `json:"url"`
	MimeType string `json:"mime_type,omitempty"`
	Filename string `json:"filename,omitempty"`
	Size     int64  `json:"size,omitempty"`
	Caption  string `json:"caption,omitempty"`
}

// Location ubicaci√≥n geogr√°fica
type Location struct {
	Latitude  float64 `json:"latitude"`
	Longitude float64 `json:"longitude"`
	Name      string  `json:"name,omitempty"`
	Address   string  `json:"address,omitempty"`
}

// Contact contacto compartido
type Contact struct {
	Name         string `json:"name"`
	PhoneNumber  string `json:"phone_number,omitempty"`
	Email        string `json:"email,omitempty"`
	Organization string `json:"organization,omitempty"`
}

// Interactive mensaje interactivo (botones, listas, etc)
type Interactive struct {
	Type    string   `json:"type"` // button, list, template
	Header  string   `json:"header,omitempty"`
	Body    string   `json:"body"`
	Footer  string   `json:"footer,omitempty"`
	Buttons []Button `json:"buttons,omitempty"`
	Items   []Item   `json:"items,omitempty"`
}

// Button bot√≥n interactivo
type Button struct {
	ID    string `json:"id"`
	Title string `json:"title"`
	Type  string `json:"type,omitempty"` // reply, url, call
	URL   string `json:"url,omitempty"`
	Phone string `json:"phone,omitempty"`
}

// Item elemento de lista
type Item struct {
	ID          string `json:"id"`
	Title       string `json:"title"`
	Description string `json:"description,omitempty"`
}

// ============================================================================
// Request DTOs
// ============================================================================

// CreateChannelRequest request para crear un canal
type CreateChannelRequest struct {
	TenantID    kernel.TenantID `json:"tenant_id" validate:"required"`
	Name        string          `json:"name" validate:"required,min=2"`
	Description string          `json:"description"`
	Type        ChannelType     `json:"type" validate:"required"`
	Config      ChannelConfig   `json:"config" validate:"required"`
}

// UpdateChannelRequest request para actualizar un canal
type UpdateChannelRequest struct {
	Name        *string        `json:"name,omitempty"`
	Description *string        `json:"description,omitempty"`
	Config      *ChannelConfig `json:"config,omitempty"`
	IsActive    *bool          `json:"is_active,omitempty"`
}

// SendMessageRequest request para enviar mensaje
type SendMessageRequest struct {
	ChannelID   kernel.ChannelID  `json:"channel_id" validate:"required"`
	RecipientID string            `json:"recipient_id" validate:"required"`
	Content     MessageContent    `json:"content" validate:"required"`
	ReplyToID   string            `json:"reply_to_id,omitempty"`
	TemplateID  string            `json:"template_id,omitempty"`
	Variables   map[string]string `json:"variables,omitempty"`
}

// TestChannelRequest request para probar un canal
type TestChannelRequest struct {
	ChannelID   kernel.ChannelID `json:"channel_id" validate:"required"`
	RecipientID string           `json:"recipient_id" validate:"required"`
	Message     string           `json:"message"`
}

// ProcessWebhookRequest request para procesar webhook
type ProcessWebhookRequest struct {
	ChannelID kernel.ChannelID  `json:"channel_id" validate:"required"`
	Payload   map[string]any    `json:"payload" validate:"required"`
	Headers   map[string]string `json:"headers,omitempty"`
	Signature string            `json:"signature,omitempty"`
}

// ============================================================================
// List Request DTOs
// ============================================================================

// ListChannelsRequest request para listar canales
type ListChannelsRequest struct {
	storex.PaginationOptions

	TenantID kernel.TenantID `json:"tenant_id" validate:"required"`
	Type     *ChannelType    `json:"type,omitempty"`
	IsActive *bool           `json:"is_active,omitempty"`
	Provider *string         `json:"provider,omitempty"`
	Search   string          `json:"search,omitempty"`
}

// ============================================================================
// Response DTOs
// ============================================================================

// ChannelResponse respuesta con canal
type ChannelResponse struct {
	Channel  Channel         `json:"channel"`
	Features ChannelFeatures `json:"features"`
	Stats    *ChannelStats   `json:"stats,omitempty"`
}

// ChannelListResponse lista paginada de canales
type ChannelListResponse = storex.Paginated[Channel]

// SendMessageResponse respuesta de env√≠o de mensaje
type SendMessageResponse struct {
	Success       bool           `json:"success"`
	MessageID     string         `json:"message_id,omitempty"`
	ProviderMsgID string         `json:"provider_message_id,omitempty"`
	Timestamp     int64          `json:"timestamp"`
	Error         string         `json:"error,omitempty"`
	Metadata      map[string]any `json:"metadata,omitempty"`
}

// TestChannelResponse respuesta de prueba de canal
type TestChannelResponse struct {
	Success      bool           `json:"success"`
	Message      string         `json:"message"`
	ResponseTime int64          `json:"response_time_ms"`
	ProviderInfo map[string]any `json:"provider_info,omitempty"`
	Error        string         `json:"error,omitempty"`
}

// ProcessWebhookResponse respuesta de procesamiento de webhook
type ProcessWebhookResponse struct {
	Success   bool            `json:"success"`
	Message   IncomingMessage `json:"message,omitempty"`
	Processed bool            `json:"processed"`
	Error     string          `json:"error,omitempty"`
}

// ============================================================================
// Stats DTOs
// ============================================================================

// ChannelStats estad√≠sticas de un canal
type ChannelStats struct {
	ChannelID         kernel.ChannelID `json:"channel_id"`
	ChannelName       string           `json:"channel_name"`
	TotalMessagesSent int              `json:"total_messages_sent"`
	TotalMessagesRecv int              `json:"total_messages_received"`
	SuccessRate       float64          `json:"success_rate"`
	AvgResponseTime   float64          `json:"avg_response_time_ms"`
	LastMessageAt     *string          `json:"last_message_at,omitempty"`
	ErrorCount        int              `json:"error_count"`
}

// ChannelUsageResponse uso de canales en un periodo
type ChannelUsageResponse struct {
	TenantID         kernel.TenantID         `json:"tenant_id"`
	Period           string                  `json:"period"` // day, week, month
	TotalMessages    int                     `json:"total_messages"`
	MessagesSent     int                     `json:"messages_sent"`
	MessagesReceived int                     `json:"messages_received"`
	SuccessRate      float64                 `json:"success_rate"`
	ChannelBreakdown []ChannelUsageBreakdown `json:"channel_breakdown"`
}

type ChannelUsageBreakdown struct {
	ChannelID    kernel.ChannelID `json:"channel_id"`
	ChannelName  string           `json:"channel_name"`
	ChannelType  ChannelType      `json:"channel_type"`
	MessagesSent int              `json:"messages_sent"`
	MessagesRecv int              `json:"messages_received"`
	SuccessRate  float64          `json:"success_rate"`
}

// ============================================================================
// Bulk Operation DTOs
// ============================================================================

// BulkChannelOperationRequest request para operaciones masivas
type BulkChannelOperationRequest struct {
	TenantID   kernel.TenantID    `json:"tenant_id" validate:"required"`
	ChannelIDs []kernel.ChannelID `json:"channel_ids" validate:"required,min=1"`
	Operation  string             `json:"operation" validate:"required,oneof=activate deactivate delete test"`
}

// BulkChannelOperationResponse respuesta de operaci√≥n masiva
type BulkChannelOperationResponse struct {
	Successful []kernel.ChannelID          `json:"successful"`
	Failed     map[kernel.ChannelID]string `json:"failed"`
	Total      int                         `json:"total"`
}

// ============================================================================
// Simple DTOs
// ============================================================================

// ChannelDetailsDTO DTO simplificado de canal
type ChannelDetailsDTO struct {
	ID         kernel.ChannelID `json:"id"`
	Name       string           `json:"name"`
	Type       ChannelType      `json:"type"`
	Provider   string           `json:"provider"`
	IsActive   bool             `json:"is_active"`
	WebhookURL string           `json:"webhook_url"`
}

// ToDTO convierte Channel a ChannelDetailsDTO
func (c *Channel) ToDTO() ChannelDetailsDTO {
	return ChannelDetailsDTO{
		ID:         c.ID,
		Name:       c.Name,
		Type:       c.Type,
		Provider:   c.GetProvider(),
		IsActive:   c.IsActive,
		WebhookURL: c.WebhookURL,
	}
}

// ============================================================================
// Validation DTOs
// ============================================================================

// ValidateChannelConfigRequest request para validar config de canal
type ValidateChannelConfigRequest struct {
	Type   ChannelType   `json:"type" validate:"required"`
	Config ChannelConfig `json:"config" validate:"required"`
}

// ValidateChannelConfigResponse respuesta de validaci√≥n
type ValidateChannelConfigResponse struct {
	IsValid  bool     `json:"is_valid"`
	Errors   []string `json:"errors,omitempty"`
	Warnings []string `json:"warnings,omitempty"`
}

// ChannelFeaturesResponse caracter√≠sticas de un tipo de canal
type ChannelFeaturesResponse struct {
	ChannelType ChannelType     `json:"channel_type"`
	Features    ChannelFeatures `json:"features"`
}

// AvailableChannelTypesResponse tipos de canales disponibles
type AvailableChannelTypesResponse struct {
	Types []ChannelTypeInfo `json:"types"`
}

type ChannelTypeInfo struct {
	Type        ChannelType     `json:"type"`
	Name        string          `json:"name"`
	Description string          `json:"description"`
	Providers   []string        `json:"providers"`
	Features    ChannelFeatures `json:"features"`
}
package channels

import (
	"net/http"

	"github.com/Abraxas-365/craftable/errx"
)

// ============================================================================
// Error Registry
// ============================================================================

var ErrRegistry = errx.NewRegistry("CHANNEL")

// ============================================================================
// Error Codes
// ============================================================================

var (
	// Channel errors
	CodeChannelNotFound      = ErrRegistry.Register("NOT_FOUND", errx.TypeNotFound, http.StatusNotFound, "Canal no encontrado")
	CodeChannelAlreadyExists = ErrRegistry.Register("ALREADY_EXISTS", errx.TypeConflict, http.StatusConflict, "Canal ya existe")
	CodeInvalidChannelType   = ErrRegistry.Register("INVALID_TYPE", errx.TypeValidation, http.StatusBadRequest, "Tipo de canal inv√°lido")
	CodeInvalidChannelConfig = ErrRegistry.Register("INVALID_CONFIG", errx.TypeValidation, http.StatusBadRequest, "Configuraci√≥n de canal inv√°lida")
	CodeChannelInactive      = ErrRegistry.Register("CHANNEL_INACTIVE", errx.TypeBusiness, http.StatusForbidden, "Canal est√° inactivo")
	CodeChannelNotSupported  = ErrRegistry.Register("NOT_SUPPORTED", errx.TypeValidation, http.StatusBadRequest, "Tipo de canal no soportado")

	// Message sending errors
	CodeMessageSendFailed    = ErrRegistry.Register("MESSAGE_SEND_FAILED", errx.TypeExternal, http.StatusBadGateway, "Env√≠o de mensaje fall√≥")
	CodeInvalidRecipient     = ErrRegistry.Register("INVALID_RECIPIENT", errx.TypeValidation, http.StatusBadRequest, "Destinatario inv√°lido")
	CodeInvalidMessageFormat = ErrRegistry.Register("INVALID_MESSAGE_FORMAT", errx.TypeValidation, http.StatusBadRequest, "Formato de mensaje inv√°lido")
	CodeAttachmentTooLarge   = ErrRegistry.Register("ATTACHMENT_TOO_LARGE", errx.TypeValidation, http.StatusRequestEntityTooLarge, "Archivo adjunto muy grande")
	CodeUnsupportedMediaType = ErrRegistry.Register("UNSUPPORTED_MEDIA_TYPE", errx.TypeValidation, http.StatusUnsupportedMediaType, "Tipo de medio no soportado")

	// Provider errors
	CodeProviderNotConfigured = ErrRegistry.Register("PROVIDER_NOT_CONFIGURED", errx.TypeValidation, http.StatusBadRequest, "Proveedor no configurado")
	CodeProviderAuthFailed    = ErrRegistry.Register("PROVIDER_AUTH_FAILED", errx.TypeExternal, http.StatusUnauthorized, "Autenticaci√≥n con proveedor fall√≥")
	CodeProviderAPIError      = ErrRegistry.Register("PROVIDER_API_ERROR", errx.TypeExternal, http.StatusBadGateway, "Error en API del proveedor")
	CodeProviderRateLimited   = ErrRegistry.Register("PROVIDER_RATE_LIMITED", errx.TypeExternal, http.StatusTooManyRequests, "Proveedor limit√≥ la tasa de requests")

	// Webhook errors
	CodeInvalidWebhookSignature = ErrRegistry.Register("INVALID_WEBHOOK_SIGNATURE", errx.TypeValidation, http.StatusUnauthorized, "Firma de webhook inv√°lida")
	CodeWebhookProcessingFailed = ErrRegistry.Register("WEBHOOK_PROCESSING_FAILED", errx.TypeInternal, http.StatusInternalServerError, "Procesamiento de webhook fall√≥")

	// Feature errors
	CodeFeatureNotSupported = ErrRegistry.Register("FEATURE_NOT_SUPPORTED", errx.TypeBusiness, http.StatusNotImplemented, "Caracter√≠stica no soportada por el canal")
)

// ============================================================================
// Error Constructor Functions
// ============================================================================

// Channel errors
func ErrChannelNotFound() *errx.Error {
	return ErrRegistry.New(CodeChannelNotFound)
}

func ErrChannelAlreadyExists() *errx.Error {
	return ErrRegistry.New(CodeChannelAlreadyExists)
}

func ErrInvalidChannelType() *errx.Error {
	return ErrRegistry.New(CodeInvalidChannelType)
}

func ErrInvalidChannelConfig() *errx.Error {
	return ErrRegistry.New(CodeInvalidChannelConfig)
}

func ErrChannelInactive() *errx.Error {
	return ErrRegistry.New(CodeChannelInactive)
}

func ErrChannelNotSupported() *errx.Error {
	return ErrRegistry.New(CodeChannelNotSupported)
}

// Message sending errors
func ErrMessageSendFailed() *errx.Error {
	return ErrRegistry.New(CodeMessageSendFailed)
}

func ErrInvalidRecipient() *errx.Error {
	return ErrRegistry.New(CodeInvalidRecipient)
}

func ErrInvalidMessageFormat() *errx.Error {
	return ErrRegistry.New(CodeInvalidMessageFormat)
}

func ErrAttachmentTooLarge() *errx.Error {
	return ErrRegistry.New(CodeAttachmentTooLarge)
}

func ErrUnsupportedMediaType() *errx.Error {
	return ErrRegistry.New(CodeUnsupportedMediaType)
}

// Provider errors
func ErrProviderNotConfigured() *errx.Error {
	return ErrRegistry.New(CodeProviderNotConfigured)
}

func ErrProviderAuthFailed() *errx.Error {
	return ErrRegistry.New(CodeProviderAuthFailed)
}

func ErrProviderAPIError() *errx.Error {
	return ErrRegistry.New(CodeProviderAPIError)
}

func ErrProviderRateLimited() *errx.Error {
	return ErrRegistry.New(CodeProviderRateLimited)
}

// Webhook errors
func ErrInvalidWebhookSignature() *errx.Error {
	return ErrRegistry.New(CodeInvalidWebhookSignature)
}

func ErrWebhookProcessingFailed() *errx.Error {
	return ErrRegistry.New(CodeWebhookProcessingFailed)
}

// Feature errors
func ErrFeatureNotSupported() *errx.Error {
	return ErrRegistry.New(CodeFeatureNotSupported)
}

package engine

import (
	"time"

	"github.com/Abraxas-365/relay/pkg/kernel"
)

// ============================================================================
// Message Entity
// ============================================================================

// Message representa un mensaje normalizado
type Message struct {
	ID        kernel.MessageID `db:"id" json:"id"`
	TenantID  kernel.TenantID  `db:"tenant_id" json:"tenant_id"`
	ChannelID kernel.ChannelID `db:"channel_id" json:"channel_id"`
	SenderID  string           `db:"sender_id" json:"sender_id"`
	Content   MessageContent   `db:"content" json:"content"`
	Context   map[string]any   `db:"context" json:"context"`
	Status    MessageStatus    `db:"status" json:"status"`
	CreatedAt time.Time        `db:"created_at" json:"created_at"`
	UpdatedAt time.Time        `db:"updated_at" json:"updated_at"`
}

// MessageContent contenido del mensaje
type MessageContent struct {
	Type        string         `json:"type"` // text, image, audio, video, document
	Text        string         `json:"text,omitempty"`
	Attachments []string       `json:"attachments,omitempty"`
	Metadata    map[string]any `json:"metadata,omitempty"`
}

// MessageStatus estado del mensaje
type MessageStatus string

const (
	MessageStatusPending    MessageStatus = "PENDING"
	MessageStatusProcessing MessageStatus = "PROCESSING"
	MessageStatusProcessed  MessageStatus = "PROCESSED"
	MessageStatusFailed     MessageStatus = "FAILED"
)

// ============================================================================
// Workflow Entity
// ============================================================================

// Workflow representa un flujo de trabajo
type Workflow struct {
	ID          kernel.WorkflowID `db:"id" json:"id"`
	TenantID    kernel.TenantID   `db:"tenant_id" json:"tenant_id"`
	Name        string            `db:"name" json:"name"`
	Description string            `db:"description" json:"description"`
	Trigger     WorkflowTrigger   `db:"trigger" json:"trigger"`
	Steps       []WorkflowStep    `db:"steps" json:"steps"`
	IsActive    bool              `db:"is_active" json:"is_active"`
	CreatedAt   time.Time         `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time         `db:"updated_at" json:"updated_at"`
}

// WorkflowTrigger define cu√°ndo se ejecuta el workflow
type WorkflowTrigger struct {
	Type       TriggerType    `json:"type"` // message_received, scheduled, webhook, manual
	ChannelIDs []string       `json:"channel_ids,omitempty"`
	Schedule   *string        `json:"schedule,omitempty"` // Cron expression
	Filters    map[string]any `json:"filters,omitempty"`  // Filtros adicionales
}

// TriggerType tipo de trigger
type TriggerType string

const (
	TriggerTypeMessageReceived TriggerType = "MESSAGE_RECEIVED"
	TriggerTypeScheduled       TriggerType = "SCHEDULED"
	TriggerTypeWebhook         TriggerType = "WEBHOOK"
	TriggerTypeManual          TriggerType = "MANUAL"
)

// WorkflowStep paso de un workflow
type WorkflowStep struct {
	ID        string         `json:"id"`
	Name      string         `json:"name"`
	Type      StepType       `json:"type"` // condition, parser, tool, action, delay
	Config    map[string]any `json:"config"`
	OnSuccess string         `json:"on_success,omitempty"` // next step ID
	OnFailure string         `json:"on_failure,omitempty"` // next step ID
	Timeout   *int           `json:"timeout,omitempty"`    // seconds
}

// StepType tipo de paso
type StepType string

const (
	StepTypeCondition StepType = "CONDITION"
	StepTypeParser    StepType = "PARSER"
	StepTypeTool      StepType = "TOOL"
	StepTypeAction    StepType = "ACTION"
	StepTypeDelay     StepType = "DELAY"
	StepTypeResponse  StepType = "RESPONSE"
)

// ============================================================================
// Session Entity
// ============================================================================

// Session representa contexto de conversaci√≥n
type Session struct {
	ID             string           `db:"id" json:"id"`
	TenantID       kernel.TenantID  `db:"tenant_id" json:"tenant_id"`
	ChannelID      kernel.ChannelID `db:"channel_id" json:"channel_id"`
	SenderID       string           `db:"sender_id" json:"sender_id"`
	Context        map[string]any   `db:"context" json:"context"`
	History        []MessageRef     `db:"history" json:"history"` // Referencias a mensajes
	CurrentState   string           `db:"current_state" json:"current_state"`
	ExpiresAt      time.Time        `db:"expires_at" json:"expires_at"`
	CreatedAt      time.Time        `db:"created_at" json:"created_at"`
	LastActivityAt time.Time        `db:"last_activity_at" json:"last_activity_at"`
}

// MessageRef referencia a un mensaje en el historial
type MessageRef struct {
	MessageID kernel.MessageID `json:"message_id"`
	Role      string           `json:"role"` // user, assistant, system
	Timestamp time.Time        `json:"timestamp"`
}

// ============================================================================
// Execution Result
// ============================================================================

// ExecutionResult resultado de la ejecuci√≥n de un workflow
type ExecutionResult struct {
	Success       bool           `json:"success"`
	Response      string         `json:"response,omitempty"`
	ShouldRespond bool           `json:"should_respond"`
	NextState     string         `json:"next_state,omitempty"`
	Context       map[string]any `json:"context,omitempty"`
	Error         error          `json:"-"`
	ErrorMessage  string         `json:"error,omitempty"`
	ExecutedSteps []StepResult   `json:"executed_steps,omitempty"`
}

// StepResult resultado de un paso
type StepResult struct {
	StepID    string         `json:"step_id"`
	StepName  string         `json:"step_name"`
	Success   bool           `json:"success"`
	Output    map[string]any `json:"output,omitempty"`
	Error     string         `json:"error,omitempty"`
	Duration  int64          `json:"duration_ms"`
	Timestamp time.Time      `json:"timestamp"`
}

// ============================================================================
// Domain Methods - Message
// ============================================================================

// IsValid verifica si el mensaje es v√°lido
func (m *Message) IsValid() bool {
	return !m.ID.IsEmpty() && !m.ChannelID.IsEmpty() && m.SenderID != ""
}

// MarkAsProcessing marca el mensaje como en procesamiento
func (m *Message) MarkAsProcessing() {
	m.Status = MessageStatusProcessing
	m.UpdatedAt = time.Now()
}

// MarkAsProcessed marca el mensaje como procesado
func (m *Message) MarkAsProcessed() {
	m.Status = MessageStatusProcessed
	m.UpdatedAt = time.Now()
}

// MarkAsFailed marca el mensaje como fallido
func (m *Message) MarkAsFailed() {
	m.Status = MessageStatusFailed
	m.UpdatedAt = time.Now()
}

// HasTextContent verifica si el mensaje tiene contenido de texto
func (m *Message) HasTextContent() bool {
	return m.Content.Type == "text" && m.Content.Text != ""
}

// HasAttachments verifica si el mensaje tiene adjuntos
func (m *Message) HasAttachments() bool {
	return len(m.Content.Attachments) > 0
}

// ============================================================================
// Domain Methods - Workflow
// ============================================================================

// IsValid verifica si el workflow es v√°lido
func (w *Workflow) IsValid() bool {
	return w.Name != "" && len(w.Steps) > 0 && !w.TenantID.IsEmpty()
}

// Activate activa el workflow
func (w *Workflow) Activate() {
	w.IsActive = true
	w.UpdatedAt = time.Now()
}

// Deactivate desactiva el workflow
func (w *Workflow) Deactivate() {
	w.IsActive = false
	w.UpdatedAt = time.Now()
}

// UpdateDetails actualiza nombre y descripci√≥n
func (w *Workflow) UpdateDetails(name, description string) {
	if name != "" {
		w.Name = name
	}
	if description != "" {
		w.Description = description
	}
	w.UpdatedAt = time.Now()
}

// UpdateSteps actualiza los pasos del workflow
func (w *Workflow) UpdateSteps(steps []WorkflowStep) {
	w.Steps = steps
	w.UpdatedAt = time.Now()
}

// GetStepByID obtiene un paso por ID
func (w *Workflow) GetStepByID(stepID string) *WorkflowStep {
	for i := range w.Steps {
		if w.Steps[i].ID == stepID {
			return &w.Steps[i]
		}
	}
	return nil
}

// MatchesTrigger verifica si el workflow coincide con un trigger dado
func (w *Workflow) MatchesTrigger(trigger WorkflowTrigger) bool {
	if w.Trigger.Type != trigger.Type {
		return false
	}

	// Si tiene filtro de canales, verificar coincidencia
	if len(w.Trigger.ChannelIDs) > 0 && len(trigger.ChannelIDs) > 0 {
		for _, wChannelID := range w.Trigger.ChannelIDs {
			for _, tChannelID := range trigger.ChannelIDs {
				if wChannelID == tChannelID {
					return true
				}
			}
		}
		return false
	}

	return true
}

// ============================================================================
// Domain Methods - Session
// ============================================================================

// IsValid verifica si la sesi√≥n es v√°lida
func (s *Session) IsValid() bool {
	return s.ID != "" && !s.ChannelID.IsEmpty() && s.SenderID != ""
}

// IsExpired verifica si la sesi√≥n ha expirado
func (s *Session) IsExpired() bool {
	return time.Now().After(s.ExpiresAt)
}

// UpdateActivity actualiza la √∫ltima actividad
func (s *Session) UpdateActivity() {
	s.LastActivityAt = time.Now()
}

// AddMessage a√±ade un mensaje al historial
func (s *Session) AddMessage(messageID kernel.MessageID, role string) {
	s.History = append(s.History, MessageRef{
		MessageID: messageID,
		Role:      role,
		Timestamp: time.Now(),
	})
	s.UpdateActivity()
}

// SetContext establece contexto
func (s *Session) SetContext(key string, value any) {
	if s.Context == nil {
		s.Context = make(map[string]any)
	}
	s.Context[key] = value
	s.UpdateActivity()
}

// GetContext obtiene un valor del contexto
func (s *Session) GetContext(key string) (any, bool) {
	if s.Context == nil {
		return nil, false
	}
	val, ok := s.Context[key]
	return val, ok
}

// UpdateState actualiza el estado actual
func (s *Session) UpdateState(state string) {
	s.CurrentState = state
	s.UpdateActivity()
}

// ExtendExpiration extiende la expiraci√≥n de la sesi√≥n
func (s *Session) ExtendExpiration(duration time.Duration) {
	s.ExpiresAt = time.Now().Add(duration)
	s.UpdateActivity()
}

// GetHistoryCount retorna el n√∫mero de mensajes en el historial
func (s *Session) GetHistoryCount() int {
	return len(s.History)
}
package engine

import (
	"context"

	"github.com/Abraxas-365/relay/pkg/kernel"
)

// ============================================================================
// Repository Interfaces
// ============================================================================

// MessageRepository persistencia de mensajes
type MessageRepository interface {
	// CRUD b√°sico
	Save(ctx context.Context, msg Message) error
	FindByID(ctx context.Context, id kernel.MessageID) (*Message, error)
	Delete(ctx context.Context, id kernel.MessageID) error

	// B√∫squedas
	FindByChannel(ctx context.Context, channelID kernel.ChannelID) ([]*Message, error)
	FindBySender(ctx context.Context, senderID string, tenantID kernel.TenantID) ([]*Message, error)
	FindByStatus(ctx context.Context, status MessageStatus, tenantID kernel.TenantID) ([]*Message, error)

	// List con paginaci√≥n
	List(ctx context.Context, req MessageListRequest) (MessageListResponse, error)

	// Bulk operations
	BulkUpdateStatus(ctx context.Context, ids []kernel.MessageID, status MessageStatus) error

	// Stats
	CountByStatus(ctx context.Context, status MessageStatus, tenantID kernel.TenantID) (int, error)
	CountByChannel(ctx context.Context, channelID kernel.ChannelID) (int, error)
}

// WorkflowRepository persistencia de workflows
type WorkflowRepository interface {
	// CRUD b√°sico
	Save(ctx context.Context, wf Workflow) error
	FindByID(ctx context.Context, id kernel.WorkflowID) (*Workflow, error)
	FindByName(ctx context.Context, name string, tenantID kernel.TenantID) (*Workflow, error)
	Delete(ctx context.Context, id kernel.WorkflowID, tenantID kernel.TenantID) error
	ExistsByName(ctx context.Context, name string, tenantID kernel.TenantID) (bool, error)

	// B√∫squedas
	FindByTenant(ctx context.Context, tenantID kernel.TenantID) ([]*Workflow, error)
	FindActive(ctx context.Context, tenantID kernel.TenantID) ([]*Workflow, error)
	FindByTriggerType(ctx context.Context, triggerType TriggerType, tenantID kernel.TenantID) ([]*Workflow, error)
	FindActiveByTrigger(ctx context.Context, trigger WorkflowTrigger, tenantID kernel.TenantID) ([]*Workflow, error)

	// List con paginaci√≥n
	List(ctx context.Context, req WorkflowListRequest) (WorkflowListResponse, error)

	// Bulk operations
	BulkUpdateStatus(ctx context.Context, ids []kernel.WorkflowID, tenantID kernel.TenantID, isActive bool) error
}

// SessionRepository persistencia de sesiones
type SessionRepository interface {
	// CRUD b√°sico
	Save(ctx context.Context, session Session) error
	FindByID(ctx context.Context, id string) (*Session, error)
	Delete(ctx context.Context, id string) error

	// B√∫squedas
	FindByChannelAndSender(ctx context.Context, channelID kernel.ChannelID, senderID string) (*Session, error)
	FindByChannel(ctx context.Context, channelID kernel.ChannelID) ([]*Session, error)
	FindActive(ctx context.Context, tenantID kernel.TenantID) ([]*Session, error)
	FindExpired(ctx context.Context) ([]*Session, error)

	// List con paginaci√≥n
	List(ctx context.Context, req SessionListRequest) (SessionListResponse, error)

	// Mantenimiento
	CleanExpired(ctx context.Context) error
	ExtendExpiration(ctx context.Context, id string, duration int64) error // duration en segundos

	// Stats
	CountActive(ctx context.Context, tenantID kernel.TenantID) (int, error)
}

// ============================================================================
// Manager Interfaces
// ============================================================================

// SessionManager manejo de sesiones con l√≥gica de negocio
type SessionManager interface {
	// Obtener o crear sesi√≥n
	GetOrCreate(ctx context.Context, channelID kernel.ChannelID, senderID string, tenantID kernel.TenantID) (*Session, error)

	// Actualizar sesi√≥n
	Update(ctx context.Context, session Session) error
	UpdateContext(ctx context.Context, sessionID string, key string, value any) error
	UpdateState(ctx context.Context, sessionID string, state string) error

	// Eliminar sesi√≥n
	Delete(ctx context.Context, sessionID string) error

	// Obtener sesi√≥n
	Get(ctx context.Context, sessionID string) (*Session, error)

	// Extender expiraci√≥n
	ExtendSession(ctx context.Context, sessionID string) error

	// Limpiar sesiones expiradas
	CleanExpiredSessions(ctx context.Context) error
}

// ============================================================================
// Executor Interfaces
// ============================================================================

// WorkflowExecutor ejecuta workflows
type WorkflowExecutor interface {
	// Ejecutar workflow completo
	Execute(ctx context.Context, workflow Workflow, message Message, session *Session) (*ExecutionResult, error)

	// Ejecutar paso espec√≠fico
	ExecuteStep(ctx context.Context, step WorkflowStep, message Message, session *Session, stepContext map[string]any) (*StepResult, error)

	// Validar workflow
	ValidateWorkflow(ctx context.Context, workflow Workflow) error
}

// StepExecutor ejecuta pasos espec√≠ficos de workflow
type StepExecutor interface {
	// Ejecutar paso
	Execute(ctx context.Context, step WorkflowStep, input map[string]any) (*StepResult, error)

	// Soporta el tipo de paso
	SupportsType(stepType StepType) bool

	// Validar configuraci√≥n del paso
	ValidateConfig(config map[string]any) error
}

// ============================================================================
// Processor Interface
// ============================================================================

// MessageProcessor procesa mensajes entrantes
type MessageProcessor interface {
	// Procesar mensaje
	ProcessMessage(ctx context.Context, msg Message) error

	// Procesar mensaje con workflow espec√≠fico
	ProcessWithWorkflow(ctx context.Context, msg Message, workflowID kernel.WorkflowID) error

	// Procesar respuesta
	ProcessResponse(ctx context.Context, msg Message, response string) error
}
package enginesrv

import (
	"context"
	"time"

	"github.com/Abraxas-365/craftable/errx"
	"github.com/Abraxas-365/relay/channels"
	"github.com/Abraxas-365/relay/engine"
	"github.com/Abraxas-365/relay/parser"
	"github.com/Abraxas-365/relay/pkg/kernel"
)

// MessageProcessor procesa mensajes entrantes
type MessageProcessor struct {
	messageRepo    engine.MessageRepository
	workflowRepo   engine.WorkflowRepository
	sessionManager engine.SessionManager
	workflowExec   engine.WorkflowExecutor
	channelManager channels.ChannelManager
	parserSelector parser.ParserSelector
}

// NewMessageProcessor crea una nueva instancia del procesador de mensajes
func NewMessageProcessor(
	messageRepo engine.MessageRepository,
	workflowRepo engine.WorkflowRepository,
	sessionManager engine.SessionManager,
	workflowExec engine.WorkflowExecutor,
	channelManager channels.ChannelManager,
	parserSelector parser.ParserSelector,
) *MessageProcessor {
	return &MessageProcessor{
		messageRepo:    messageRepo,
		workflowRepo:   workflowRepo,
		sessionManager: sessionManager,
		workflowExec:   workflowExec,
		channelManager: channelManager,
		parserSelector: parserSelector,
	}
}

// ProcessMessage es el entry point principal para procesar mensajes
func (mp *MessageProcessor) ProcessMessage(ctx context.Context, msg engine.Message) error {
	// 1. Validar mensaje
	if !msg.IsValid() {
		return engine.ErrMessageProcessingFailed().WithDetail("reason", "invalid message")
	}

	// 2. Marcar mensaje como en procesamiento
	msg.MarkAsProcessing()
	if err := mp.messageRepo.Save(ctx, msg); err != nil {
		return errx.Wrap(err, "failed to save message", errx.TypeInternal)
	}

	// 3. Obtener o crear sesi√≥n
	session, err := mp.sessionManager.GetOrCreate(ctx, msg.ChannelID, msg.SenderID, msg.TenantID)
	if err != nil {
		msg.MarkAsFailed()
		mp.messageRepo.Save(ctx, msg)
		return errx.Wrap(err, "failed to get or create session", errx.TypeInternal)
	}

	// 4. A√±adir mensaje al historial de la sesi√≥n
	session.AddMessage(msg.ID, "user")

	// 5. Buscar workflow apropiado
	workflows, err := mp.findMatchingWorkflows(ctx, msg)
	if err != nil {
		msg.MarkAsFailed()
		mp.messageRepo.Save(ctx, msg)
		return errx.Wrap(err, "failed to find workflows", errx.TypeInternal)
	}

	// 6. Si no hay workflows, manejar con l√≥gica por defecto
	if len(workflows) == 0 {
		return mp.handleNoWorkflow(ctx, msg, session)
	}

	// 7. Ejecutar el primer workflow que coincida (por prioridad)
	result, err := mp.executeWorkflowWithTimeout(ctx, workflows[0], msg, session)
	if err != nil {
		msg.MarkAsFailed()
		mp.messageRepo.Save(ctx, msg)
		return errx.Wrap(err, "failed to execute workflow", errx.TypeInternal)
	}

	// 8. Actualizar sesi√≥n con el resultado
	if err := mp.updateSessionFromResult(ctx, session, result); err != nil {
		// Log error pero no fallar
		// logger.Error("Failed to update session", err)
	}

	// 9. Enviar respuesta si es necesario
	if result.ShouldRespond && result.Response != "" {
		if err := mp.sendResponse(ctx, msg, result.Response); err != nil {
			// Log error pero marcar mensaje como procesado
			// logger.Error("Failed to send response", err)
		}
	}

	// 10. Marcar mensaje como procesado
	msg.MarkAsProcessed()
	return mp.messageRepo.Save(ctx, msg)
}

// ProcessWithWorkflow procesa un mensaje con un workflow espec√≠fico
func (mp *MessageProcessor) ProcessWithWorkflow(ctx context.Context, msg engine.Message, workflowID kernel.WorkflowID) error {
	// 1. Validar mensaje
	if !msg.IsValid() {
		return engine.ErrMessageProcessingFailed().WithDetail("reason", "invalid message")
	}

	// 2. Buscar workflow espec√≠fico
	workflow, err := mp.workflowRepo.FindByID(ctx, workflowID)
	if err != nil {
		return engine.ErrWorkflowNotFound().WithDetail("workflow_id", workflowID.String())
	}

	// 3. Verificar que el workflow est√© activo
	if !workflow.IsActive {
		return engine.ErrWorkflowInactive().WithDetail("workflow_id", workflowID.String())
	}

	// 4. Verificar que pertenezca al mismo tenant
	if workflow.TenantID != msg.TenantID {
		return errx.New("workflow does not belong to message tenant", errx.TypeBusiness).
			WithDetail("workflow_tenant", workflow.TenantID.String()).
			WithDetail("message_tenant", msg.TenantID.String())
	}

	// 5. Marcar mensaje como en procesamiento
	msg.MarkAsProcessing()
	if err := mp.messageRepo.Save(ctx, msg); err != nil {
		return errx.Wrap(err, "failed to save message", errx.TypeInternal)
	}

	// 6. Obtener sesi√≥n
	session, err := mp.sessionManager.GetOrCreate(ctx, msg.ChannelID, msg.SenderID, msg.TenantID)
	if err != nil {
		msg.MarkAsFailed()
		mp.messageRepo.Save(ctx, msg)
		return errx.Wrap(err, "failed to get session", errx.TypeInternal)
	}

	// 7. A√±adir mensaje al historial
	session.AddMessage(msg.ID, "user")

	// 8. Ejecutar workflow
	result, err := mp.executeWorkflowWithTimeout(ctx, workflow, msg, session)
	if err != nil {
		msg.MarkAsFailed()
		mp.messageRepo.Save(ctx, msg)
		return errx.Wrap(err, "failed to execute workflow", errx.TypeInternal)
	}

	// 9. Actualizar sesi√≥n
	if err := mp.updateSessionFromResult(ctx, session, result); err != nil {
		// Log error pero continuar
	}

	// 10. Enviar respuesta
	if result.ShouldRespond && result.Response != "" {
		if err := mp.sendResponse(ctx, msg, result.Response); err != nil {
			// Log error pero continuar
		}
	}

	// 11. Marcar como procesado
	msg.MarkAsProcessed()
	return mp.messageRepo.Save(ctx, msg)
}

// ProcessResponse procesa una respuesta y la env√≠a
func (mp *MessageProcessor) ProcessResponse(ctx context.Context, msg engine.Message, response string) error {
	if response == "" {
		return nil
	}

	// Enviar respuesta
	return mp.sendResponse(ctx, msg, response)
}

// ============================================================================
// Helper Methods
// ============================================================================

// findMatchingWorkflows encuentra workflows que coincidan con el mensaje
func (mp *MessageProcessor) findMatchingWorkflows(ctx context.Context, msg engine.Message) ([]*engine.Workflow, error) {
	// Buscar workflows activos con trigger de mensaje recibido
	trigger := engine.WorkflowTrigger{
		Type:       engine.TriggerTypeMessageReceived,
		ChannelIDs: []string{msg.ChannelID.String()},
	}

	workflows, err := mp.workflowRepo.FindActiveByTrigger(ctx, trigger, msg.TenantID)
	if err != nil {
		return nil, err
	}

	// Filtrar workflows que realmente coincidan
	var matching []*engine.Workflow
	for _, wf := range workflows {
		if wf.MatchesTrigger(trigger) {
			matching = append(matching, wf)
		}
	}

	return matching, nil
}

// executeWorkflowWithTimeout ejecuta un workflow con timeout
func (mp *MessageProcessor) executeWorkflowWithTimeout(
	ctx context.Context,
	workflow *engine.Workflow,
	msg engine.Message,
	session *engine.Session,
) (*engine.ExecutionResult, error) {
	// Crear contexto con timeout (default 30 segundos)
	timeout := 30 * time.Second
	ctxWithTimeout, cancel := context.WithTimeout(ctx, timeout)
	defer cancel()

	// Canal para resultado
	resultChan := make(chan *engine.ExecutionResult, 1)
	errorChan := make(chan error, 1)

	// Ejecutar en goroutine
	go func() {
		result, err := mp.workflowExec.Execute(ctxWithTimeout, *workflow, msg, session)
		if err != nil {
			errorChan <- err
		} else {
			resultChan <- result
		}
	}()

	// Esperar resultado o timeout
	select {
	case result := <-resultChan:
		return result, nil
	case err := <-errorChan:
		return nil, err
	case <-ctxWithTimeout.Done():
		return nil, engine.ErrExecutionTimeout().
			WithDetail("workflow_id", workflow.ID.String()).
			WithDetail("timeout", timeout.String())
	}
}

// updateSessionFromResult actualiza la sesi√≥n con el resultado de la ejecuci√≥n
func (mp *MessageProcessor) updateSessionFromResult(
	ctx context.Context,
	session *engine.Session,
	result *engine.ExecutionResult,
) error {
	// Actualizar contexto
	if result.Context != nil {
		for key, value := range result.Context {
			session.SetContext(key, value)
		}
	}

	// Actualizar estado
	if result.NextState != "" {
		session.UpdateState(result.NextState)
	}

	// Extender expiraci√≥n de la sesi√≥n
	session.ExtendExpiration(30 * time.Minute)

	// Guardar sesi√≥n
	return mp.sessionManager.Update(ctx, *session)
}

// sendResponse env√≠a una respuesta al canal
func (mp *MessageProcessor) sendResponse(ctx context.Context, msg engine.Message, response string) error {
	outgoingMsg := channels.OutgoingMessage{
		RecipientID: msg.SenderID,
		Content: channels.MessageContent{
			Type: "text",
			Text: response,
		},
		Metadata: map[string]any{
			"in_reply_to": msg.ID.String(),
			"timestamp":   time.Now().Unix(),
		},
	}

	return mp.channelManager.SendMessage(ctx, msg.ChannelID, outgoingMsg)
}

// handleNoWorkflow maneja mensajes cuando no hay workflow disponible
func (mp *MessageProcessor) handleNoWorkflow(ctx context.Context, msg engine.Message, session *engine.Session) error {
	// Intentar usar parser por defecto si est√° disponible
	if mp.parserSelector != nil {
		// Buscar parsers disponibles para el tenant
		// parsers, err := mp.parserRepo.FindByTenant(ctx, msg.TenantID)
		// if err == nil && len(parsers) > 0 {
		//     parser, err := mp.parserSelector.SelectParser(ctx, msg, parsers)
		//     if err == nil && parser != nil {
		//         // Ejecutar parser y responder
		//     }
		// }
	}

	// Respuesta por defecto
	defaultResponse := "Gracias por tu mensaje. En este momento no hay workflows configurados para procesarlo."

	if err := mp.sendResponse(ctx, msg, defaultResponse); err != nil {
		// Log error pero no fallar
		// logger.Error("Failed to send default response", err)
	}

	// Marcar mensaje como procesado
	msg.MarkAsProcessed()
	return mp.messageRepo.Save(ctx, msg)
}

// ============================================================================
// Additional Utility Methods
// ============================================================================

// GetMessageStatus obtiene el estado de un mensaje
func (mp *MessageProcessor) GetMessageStatus(ctx context.Context, messageID kernel.MessageID) (engine.MessageStatus, error) {
	msg, err := mp.messageRepo.FindByID(ctx, messageID)
	if err != nil {
		return "", engine.ErrMessageNotFound().WithDetail("message_id", messageID.String())
	}
	return msg.Status, nil
}

// RetryFailedMessage reintenta procesar un mensaje fallido
func (mp *MessageProcessor) RetryFailedMessage(ctx context.Context, messageID kernel.MessageID) error {
	msg, err := mp.messageRepo.FindByID(ctx, messageID)
	if err != nil {
		return engine.ErrMessageNotFound().WithDetail("message_id", messageID.String())
	}

	if msg.Status != engine.MessageStatusFailed {
		return errx.New("message is not in failed state", errx.TypeBusiness).
			WithDetail("current_status", string(msg.Status))
	}

	// Resetear estado y procesar de nuevo
	msg.Status = engine.MessageStatusPending
	return mp.ProcessMessage(ctx, *msg)
}

// GetProcessingStats obtiene estad√≠sticas de procesamiento
func (mp *MessageProcessor) GetProcessingStats(ctx context.Context, tenantID kernel.TenantID) (*ProcessingStats, error) {
	pendingCount, _ := mp.messageRepo.CountByStatus(ctx, engine.MessageStatusPending, tenantID)
	processingCount, _ := mp.messageRepo.CountByStatus(ctx, engine.MessageStatusProcessing, tenantID)
	processedCount, _ := mp.messageRepo.CountByStatus(ctx, engine.MessageStatusProcessed, tenantID)
	failedCount, _ := mp.messageRepo.CountByStatus(ctx, engine.MessageStatusFailed, tenantID)

	return &ProcessingStats{
		TenantID:           tenantID,
		PendingMessages:    pendingCount,
		ProcessingMessages: processingCount,
		ProcessedMessages:  processedCount,
		FailedMessages:     failedCount,
		Timestamp:          time.Now(),
	}, nil
}

// ProcessingStats estad√≠sticas de procesamiento
type ProcessingStats struct {
	TenantID           kernel.TenantID `json:"tenant_id"`
	PendingMessages    int             `json:"pending_messages"`
	ProcessingMessages int             `json:"processing_messages"`
	ProcessedMessages  int             `json:"processed_messages"`
	FailedMessages     int             `json:"failed_messages"`
	ActiveSessions     int             `json:"active_sessions"`
	Timestamp          time.Time       `json:"timestamp"`
}

// CleanupSessions limpia sesiones expiradas
func (mp *MessageProcessor) CleanupSessions(ctx context.Context) error {
	return mp.sessionManager.CleanExpiredSessions(ctx)
}

// BulkRetryFailedMessages reintenta procesar m√∫ltiples mensajes fallidos
func (mp *MessageProcessor) BulkRetryFailedMessages(ctx context.Context, tenantID kernel.TenantID, limit int) (*BulkRetryResult, error) {
	// Buscar mensajes fallidos
	failedMessages, err := mp.messageRepo.FindByStatus(ctx, engine.MessageStatusFailed, tenantID)
	if err != nil {
		return nil, err
	}

	// Limitar cantidad
	if limit > 0 && len(failedMessages) > limit {
		failedMessages = failedMessages[:limit]
	}

	result := &BulkRetryResult{
		Total:      len(failedMessages),
		Successful: []kernel.MessageID{},
		Failed:     make(map[kernel.MessageID]string),
	}

	// Reintentar cada mensaje
	for _, msg := range failedMessages {
		if err := mp.RetryFailedMessage(ctx, msg.ID); err != nil {
			result.Failed[msg.ID] = err.Error()
		} else {
			result.Successful = append(result.Successful, msg.ID)
		}
	}

	return result, nil
}

// BulkRetryResult resultado de reintento masivo
type BulkRetryResult struct {
	Total      int                         `json:"total"`
	Successful []kernel.MessageID          `json:"successful"`
	Failed     map[kernel.MessageID]string `json:"failed"`
}
package engine

import (
	"github.com/Abraxas-365/craftable/storex"
	"github.com/Abraxas-365/relay/pkg/kernel"
)

// ============================================================================
// Message DTOs
// ============================================================================

// CreateMessageRequest request para crear un mensaje
type CreateMessageRequest struct {
	TenantID  kernel.TenantID  `json:"tenant_id" validate:"required"`
	ChannelID kernel.ChannelID `json:"channel_id" validate:"required"`
	SenderID  string           `json:"sender_id" validate:"required"`
	Content   MessageContent   `json:"content" validate:"required"`
	Context   map[string]any   `json:"context,omitempty"`
}

// MessageResponse respuesta con mensaje
type MessageResponse struct {
	Message Message `json:"message"`
}

// MessageListRequest request para listar mensajes
type MessageListRequest struct {
	storex.PaginationOptions

	TenantID  kernel.TenantID   `json:"tenant_id" validate:"required"`
	ChannelID *kernel.ChannelID `json:"channel_id,omitempty"`
	SenderID  *string           `json:"sender_id,omitempty"`
	Status    *MessageStatus    `json:"status,omitempty"`
	From      *string           `json:"from,omitempty"` // ISO 8601 date
	To        *string           `json:"to,omitempty"`   // ISO 8601 date
}

// MessageListResponse lista paginada de mensajes
type MessageListResponse = storex.Paginated[Message]

// ============================================================================
// Workflow DTOs
// ============================================================================

// CreateWorkflowRequest request para crear un workflow
type CreateWorkflowRequest struct {
	TenantID kernel.TenantID `json:"tenant_id" validate:"required"`
	Name     string          `json:"name" validate:"required,min=2"`
	Trigger  WorkflowTrigger `json:"trigger" validate:"required"`
	Steps    []WorkflowStep  `json:"steps" validate:"required,min=1"`
}

// UpdateWorkflowRequest request para actualizar un workflow
type UpdateWorkflowRequest struct {
	Name     *string          `json:"name,omitempty"`
	Trigger  *WorkflowTrigger `json:"trigger,omitempty"`
	Steps    *[]WorkflowStep  `json:"steps,omitempty"`
	IsActive *bool            `json:"is_active,omitempty"`
}

// ExecuteWorkflowRequest request para ejecutar un workflow manualmente
type ExecuteWorkflowRequest struct {
	WorkflowID kernel.WorkflowID `json:"workflow_id" validate:"required"`
	MessageID  kernel.MessageID  `json:"message_id" validate:"required"`
	Context    map[string]any    `json:"context,omitempty"`
}

// WorkflowResponse respuesta con workflow
type WorkflowResponse struct {
	Workflow Workflow `json:"workflow"`
}

// WorkflowListRequest request para listar workflows
type WorkflowListRequest struct {
	storex.PaginationOptions

	TenantID kernel.TenantID `json:"tenant_id" validate:"required"`
	IsActive *bool           `json:"is_active,omitempty"`
	Search   string          `json:"search,omitempty"`
}

// WorkflowListResponse lista paginada de workflows
type WorkflowListResponse = storex.Paginated[Workflow]

// WorkflowExecutionResponse respuesta de ejecuci√≥n de workflow
type WorkflowExecutionResponse struct {
	WorkflowID    kernel.WorkflowID `json:"workflow_id"`
	MessageID     kernel.MessageID  `json:"message_id"`
	Success       bool              `json:"success"`
	Response      string            `json:"response,omitempty"`
	ShouldRespond bool              `json:"should_respond"`
	NextState     string            `json:"next_state,omitempty"`
	Context       map[string]any    `json:"context,omitempty"`
	Error         string            `json:"error,omitempty"`
}

// ============================================================================
// Session DTOs
// ============================================================================

// SessionResponse respuesta con sesi√≥n
type SessionResponse struct {
	Session Session `json:"session"`
}

// SessionListRequest request para listar sesiones
type SessionListRequest struct {
	storex.PaginationOptions

	TenantID  kernel.TenantID   `json:"tenant_id" validate:"required"`
	ChannelID *kernel.ChannelID `json:"channel_id,omitempty"`
	SenderID  *string           `json:"sender_id,omitempty"`
	Active    *bool             `json:"active,omitempty"` // Si no ha expirado
}

// SessionListResponse lista paginada de sesiones
type SessionListResponse = storex.Paginated[Session]

// UpdateSessionRequest request para actualizar sesi√≥n
type UpdateSessionRequest struct {
	Context      *map[string]any `json:"context,omitempty"`
	CurrentState *string         `json:"current_state,omitempty"`
}

// ============================================================================
// Stats DTOs
// ============================================================================

// MessageStatsResponse estad√≠sticas de mensajes
type MessageStatsResponse struct {
	TenantID         kernel.TenantID         `json:"tenant_id"`
	Period           string                  `json:"period"` // day, week, month
	TotalMessages    int                     `json:"total_messages"`
	ProcessedCount   int                     `json:"processed_count"`
	FailedCount      int                     `json:"failed_count"`
	AvgProcessTime   float64                 `json:"avg_process_time_ms"`
	ChannelBreakdown []ChannelStatsBreakdown `json:"channel_breakdown"`
}

type ChannelStatsBreakdown struct {
	ChannelID      kernel.ChannelID `json:"channel_id"`
	ChannelName    string           `json:"channel_name"`
	MessageCount   int              `json:"message_count"`
	ProcessingRate float64          `json:"processing_rate"`
}

// WorkflowStatsResponse estad√≠sticas de workflows
type WorkflowStatsResponse struct {
	WorkflowID       kernel.WorkflowID `json:"workflow_id"`
	WorkflowName     string            `json:"workflow_name"`
	TotalExecutions  int               `json:"total_executions"`
	SuccessCount     int               `json:"success_count"`
	FailureCount     int               `json:"failure_count"`
	AvgExecutionTime float64           `json:"avg_execution_time_ms"`
	LastExecutedAt   *string           `json:"last_executed_at,omitempty"`
}

// SessionStatsResponse estad√≠sticas de sesiones
type SessionStatsResponse struct {
	TenantID       kernel.TenantID `json:"tenant_id"`
	ActiveSessions int             `json:"active_sessions"`
	TotalSessions  int             `json:"total_sessions"`
	AvgDuration    float64         `json:"avg_duration_minutes"`
}

// ============================================================================
// Bulk Operation DTOs
// ============================================================================

// BulkWorkflowOperationRequest request para operaciones masivas
type BulkWorkflowOperationRequest struct {
	TenantID    kernel.TenantID     `json:"tenant_id" validate:"required"`
	WorkflowIDs []kernel.WorkflowID `json:"workflow_ids" validate:"required,min=1"`
	Operation   string              `json:"operation" validate:"required,oneof=activate deactivate delete"`
}

// BulkWorkflowOperationResponse respuesta de operaci√≥n masiva
type BulkWorkflowOperationResponse struct {
	Successful []kernel.WorkflowID          `json:"successful"`
	Failed     map[kernel.WorkflowID]string `json:"failed"`
	Total      int                          `json:"total"`
}

// ============================================================================
// Validation DTOs
// ============================================================================

// ValidateWorkflowRequest request para validar un workflow
type ValidateWorkflowRequest struct {
	Trigger WorkflowTrigger `json:"trigger" validate:"required"`
	Steps   []WorkflowStep  `json:"steps" validate:"required,min=1"`
}

// ValidateWorkflowResponse respuesta de validaci√≥n
type ValidateWorkflowResponse struct {
	IsValid  bool     `json:"is_valid"`
	Errors   []string `json:"errors,omitempty"`
	Warnings []string `json:"warnings,omitempty"`
}

// ============================================================================
// Simple DTOs
// ============================================================================

// MessageDetailsDTO DTO simplificado de mensaje
type MessageDetailsDTO struct {
	ID        kernel.MessageID `json:"id"`
	ChannelID kernel.ChannelID `json:"channel_id"`
	SenderID  string           `json:"sender_id"`
	Content   MessageContent   `json:"content"`
	Status    MessageStatus    `json:"status"`
	CreatedAt string           `json:"created_at"`
}

// ToDTO convierte Message a MessageDetailsDTO
func (m *Message) ToDTO() MessageDetailsDTO {
	return MessageDetailsDTO{
		ID:        m.ID,
		ChannelID: m.ChannelID,
		SenderID:  m.SenderID,
		Content:   m.Content,
		Status:    m.Status,
		CreatedAt: m.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
	}
}

// WorkflowDetailsDTO DTO simplificado de workflow
type WorkflowDetailsDTO struct {
	ID        kernel.WorkflowID `json:"id"`
	Name      string            `json:"name"`
	IsActive  bool              `json:"is_active"`
	StepCount int               `json:"step_count"`
}

// ToDTO convierte Workflow a WorkflowDetailsDTO
func (w *Workflow) ToDTO() WorkflowDetailsDTO {
	return WorkflowDetailsDTO{
		ID:        w.ID,
		Name:      w.Name,
		IsActive:  w.IsActive,
		StepCount: len(w.Steps),
	}
}
package engine

import (
	"net/http"

	"github.com/Abraxas-365/craftable/errx"
)

// ============================================================================
// Error Registry
// ============================================================================

var ErrRegistry = errx.NewRegistry("ENGINE")

// ============================================================================
// Error Codes
// ============================================================================

var (
	// Message errors
	CodeMessageNotFound         = ErrRegistry.Register("MESSAGE_NOT_FOUND", errx.TypeNotFound, http.StatusNotFound, "Mensaje no encontrado")
	CodeMessageAlreadyExists    = ErrRegistry.Register("MESSAGE_ALREADY_EXISTS", errx.TypeConflict, http.StatusConflict, "Mensaje ya existe")
	CodeInvalidMessageStatus    = ErrRegistry.Register("INVALID_MESSAGE_STATUS", errx.TypeValidation, http.StatusBadRequest, "Estado de mensaje inv√°lido")
	CodeMessageProcessingFailed = ErrRegistry.Register("MESSAGE_PROCESSING_FAILED", errx.TypeInternal, http.StatusInternalServerError, "Fallo al procesar mensaje")

	// Workflow errors
	CodeWorkflowNotFound        = ErrRegistry.Register("WORKFLOW_NOT_FOUND", errx.TypeNotFound, http.StatusNotFound, "Workflow no encontrado")
	CodeWorkflowAlreadyExists   = ErrRegistry.Register("WORKFLOW_ALREADY_EXISTS", errx.TypeConflict, http.StatusConflict, "Workflow ya existe")
	CodeInvalidWorkflowConfig   = ErrRegistry.Register("INVALID_WORKFLOW_CONFIG", errx.TypeValidation, http.StatusBadRequest, "Configuraci√≥n de workflow inv√°lida")
	CodeWorkflowInactive        = ErrRegistry.Register("WORKFLOW_INACTIVE", errx.TypeBusiness, http.StatusForbidden, "Workflow est√° inactivo")
	CodeWorkflowExecutionFailed = ErrRegistry.Register("WORKFLOW_EXECUTION_FAILED", errx.TypeInternal, http.StatusInternalServerError, "Ejecuci√≥n de workflow fall√≥")
	CodeInvalidWorkflowStep     = ErrRegistry.Register("INVALID_WORKFLOW_STEP", errx.TypeValidation, http.StatusBadRequest, "Paso de workflow inv√°lido")
	CodeStepNotFound            = ErrRegistry.Register("STEP_NOT_FOUND", errx.TypeNotFound, http.StatusNotFound, "Paso no encontrado")
	CodeCyclicWorkflow          = ErrRegistry.Register("CYCLIC_WORKFLOW", errx.TypeValidation, http.StatusBadRequest, "Workflow tiene ciclos")

	// Session errors
	CodeSessionNotFound     = ErrRegistry.Register("SESSION_NOT_FOUND", errx.TypeNotFound, http.StatusNotFound, "Sesi√≥n no encontrada")
	CodeSessionExpired      = ErrRegistry.Register("SESSION_EXPIRED", errx.TypeBusiness, http.StatusGone, "Sesi√≥n expirada")
	CodeInvalidSessionState = ErrRegistry.Register("INVALID_SESSION_STATE", errx.TypeValidation, http.StatusBadRequest, "Estado de sesi√≥n inv√°lido")

	// Trigger errors
	CodeInvalidTrigger     = ErrRegistry.Register("INVALID_TRIGGER", errx.TypeValidation, http.StatusBadRequest, "Trigger inv√°lido")
	CodeNoMatchingWorkflow = ErrRegistry.Register("NO_MATCHING_WORKFLOW", errx.TypeBusiness, http.StatusNotFound, "No hay workflow que coincida con el trigger")

	// Execution errors
	CodeExecutionTimeout    = ErrRegistry.Register("EXECUTION_TIMEOUT", errx.TypeInternal, http.StatusRequestTimeout, "Ejecuci√≥n excedi√≥ timeout")
	CodeStepExecutionFailed = ErrRegistry.Register("STEP_EXECUTION_FAILED", errx.TypeInternal, http.StatusInternalServerError, "Ejecuci√≥n de paso fall√≥")
)

// ============================================================================
// Error Constructor Functions
// ============================================================================

// Message errors
func ErrMessageNotFound() *errx.Error {
	return ErrRegistry.New(CodeMessageNotFound)
}

func ErrMessageAlreadyExists() *errx.Error {
	return ErrRegistry.New(CodeMessageAlreadyExists)
}

func ErrInvalidMessageStatus() *errx.Error {
	return ErrRegistry.New(CodeInvalidMessageStatus)
}

func ErrMessageProcessingFailed() *errx.Error {
	return ErrRegistry.New(CodeMessageProcessingFailed)
}

// Workflow errors
func ErrWorkflowNotFound() *errx.Error {
	return ErrRegistry.New(CodeWorkflowNotFound)
}

func ErrWorkflowAlreadyExists() *errx.Error {
	return ErrRegistry.New(CodeWorkflowAlreadyExists)
}

func ErrInvalidWorkflowConfig() *errx.Error {
	return ErrRegistry.New(CodeInvalidWorkflowConfig)
}

func ErrWorkflowInactive() *errx.Error {
	return ErrRegistry.New(CodeWorkflowInactive)
}

func ErrWorkflowExecutionFailed() *errx.Error {
	return ErrRegistry.New(CodeWorkflowExecutionFailed)
}

func ErrInvalidWorkflowStep() *errx.Error {
	return ErrRegistry.New(CodeInvalidWorkflowStep)
}

func ErrStepNotFound() *errx.Error {
	return ErrRegistry.New(CodeStepNotFound)
}

func ErrCyclicWorkflow() *errx.Error {
	return ErrRegistry.New(CodeCyclicWorkflow)
}

// Session errors
func ErrSessionNotFound() *errx.Error {
	return ErrRegistry.New(CodeSessionNotFound)
}

func ErrSessionExpired() *errx.Error {
	return ErrRegistry.New(CodeSessionExpired)
}

func ErrInvalidSessionState() *errx.Error {
	return ErrRegistry.New(CodeInvalidSessionState)
}

// Trigger errors
func ErrInvalidTrigger() *errx.Error {
	return ErrRegistry.New(CodeInvalidTrigger)
}

func ErrNoMatchingWorkflow() *errx.Error {
	return ErrRegistry.New(CodeNoMatchingWorkflow)
}

// Execution errors
func ErrExecutionTimeout() *errx.Error {
	return ErrRegistry.New(CodeExecutionTimeout)
}

func ErrStepExecutionFailed() *errx.Error {
	return ErrRegistry.New(CodeStepExecutionFailed)
}
